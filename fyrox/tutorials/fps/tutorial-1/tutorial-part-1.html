<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Character controller - Fyrox Book</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../../../../favicon.svg">
        <link rel="shortcut icon" href="../../../../favicon.png">
        <link rel="stylesheet" href="../../../../css/variables.css">
        <link rel="stylesheet" href="../../../../css/general.css">
        <link rel="stylesheet" href="../../../../css/chrome.css">
        <link rel="stylesheet" href="../../../../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../../../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../../../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../../../highlight.css">
        <link rel="stylesheet" href="../../../../tomorrow-night.css">
        <link rel="stylesheet" href="../../../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../../../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../../../../introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../../../../fyrox/introduction.html"><strong aria-hidden="true">2.</strong> fyrox</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../../fyrox/beginning/getting_started.html"><strong aria-hidden="true">2.1.</strong> Getting started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../../fyrox/beginning/scripting.html"><strong aria-hidden="true">2.1.1.</strong> Editor, Plugins and Scripts</a></li><li class="chapter-item expanded "><a href="../../../../fyrox/beginning/editor_overview.html"><strong aria-hidden="true">2.1.2.</strong> Editor Overview</a></li><li class="chapter-item expanded "><a href="../../../../fyrox/beginning/scene_and_scene_graph.html"><strong aria-hidden="true">2.1.3.</strong> Scene and scene graph</a></li><li class="chapter-item expanded "><a href="../../../../fyrox/beginning/assets.html"><strong aria-hidden="true">2.1.4.</strong> Assets</a></li><li class="chapter-item expanded "><a href="../../../../fyrox/beginning/data_management.html"><strong aria-hidden="true">2.1.5.</strong> Data management</a></li><li class="chapter-item expanded "><a href="../../../../fyrox/beginning/installation.html"><strong aria-hidden="true">2.1.6.</strong> Installation (Obsolete)</a></li><li class="chapter-item expanded "><a href="../../../../fyrox/beginning/framework.html"><strong aria-hidden="true">2.1.7.</strong> Framework (Obsolete)</a></li><li class="chapter-item expanded "><a href="../../../../fyrox/beginning/custom_game_loop.html"><strong aria-hidden="true">2.1.8.</strong> Custom game loop (Obsolete)</a></li></ol></li><li class="chapter-item expanded "><a href="../../../../fyrox/scene/scene.html"><strong aria-hidden="true">2.2.</strong> Scene</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../../fyrox/scene/graph.html"><strong aria-hidden="true">2.2.1.</strong> Graph</a></li><li class="chapter-item expanded "><a href="../../../../fyrox/scene/prefab.html"><strong aria-hidden="true">2.2.2.</strong> Prefabs</a></li><li class="chapter-item expanded "><a href="../../../../fyrox/scene/base_node.html"><strong aria-hidden="true">2.2.3.</strong> Base node</a></li><li class="chapter-item expanded "><a href="../../../../fyrox/scene/mesh_node.html"><strong aria-hidden="true">2.2.4.</strong> Mesh node</a></li><li class="chapter-item expanded "><a href="../../../../fyrox/scene/light_node.html"><strong aria-hidden="true">2.2.5.</strong> Light node</a></li><li class="chapter-item expanded "><a href="../../../../fyrox/scene/sprite_node.html"><strong aria-hidden="true">2.2.6.</strong> Sprite node</a></li><li class="chapter-item expanded "><a href="../../../../fyrox/scene/particle_system_node.html"><strong aria-hidden="true">2.2.7.</strong> Particle system node (WIP)</a></li><li class="chapter-item expanded "><a href="../../../../fyrox/scene/terrain_node.html"><strong aria-hidden="true">2.2.8.</strong> Terrain node (WIP)</a></li><li class="chapter-item expanded "><a href="../../../../fyrox/scene/camera_node.html"><strong aria-hidden="true">2.2.9.</strong> Camera node</a></li><li class="chapter-item expanded "><a href="../../../../fyrox/scene/decal_node.html"><strong aria-hidden="true">2.2.10.</strong> Decal node</a></li><li class="chapter-item expanded "><a href="../../../../fyrox/scene/rectangle.html"><strong aria-hidden="true">2.2.11.</strong> Rectangle node</a></li><li class="chapter-item expanded "><a href="../../../../fyrox/scene/custom_node.html"><strong aria-hidden="true">2.2.12.</strong> Custom node</a></li><li class="chapter-item expanded "><a href="../../../../fyrox/physics/physics.html"><strong aria-hidden="true">2.2.13.</strong> Physics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../../fyrox/physics/rigid_body.html"><strong aria-hidden="true">2.2.13.1.</strong> Rigid body</a></li><li class="chapter-item expanded "><a href="../../../../fyrox/physics/collider.html"><strong aria-hidden="true">2.2.13.2.</strong> Collider</a></li><li class="chapter-item expanded "><a href="../../../../fyrox/physics/joint.html"><strong aria-hidden="true">2.2.13.3.</strong> Joint (WIP)</a></li></ol></li><li class="chapter-item expanded "><a href="../../../../fyrox/sound/sound.html"><strong aria-hidden="true">2.2.14.</strong> Sound</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../../fyrox/sound/hrtf.html"><strong aria-hidden="true">2.2.14.1.</strong> HRTF (WIP)</a></li></ol></li><li class="chapter-item expanded "><a href="../../../../fyrox/animation/animation.html"><strong aria-hidden="true">2.2.15.</strong> Animation (WIP)</a></li></ol></li><li class="chapter-item expanded "><a href="../../../../fyrox/rendering/rendering.html"><strong aria-hidden="true">2.3.</strong> Rendering</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../../fyrox/rendering/shaders.html"><strong aria-hidden="true">2.3.1.</strong> Shaders</a></li><li class="chapter-item expanded "><a href="../../../../fyrox/rendering/materials.html"><strong aria-hidden="true">2.3.2.</strong> Materials</a></li></ol></li><li class="chapter-item expanded "><a href="../../../../fyrox/resources/resources.html"><strong aria-hidden="true">2.4.</strong> Resource Management</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../../fyrox/resources/model.html"><strong aria-hidden="true">2.4.1.</strong> 3D Models</a></li><li class="chapter-item expanded "><a href="../../../../fyrox/resources/texture.html"><strong aria-hidden="true">2.4.2.</strong> Textures</a></li><li class="chapter-item expanded "><a href="../../../../fyrox/resources/sound.html"><strong aria-hidden="true">2.4.3.</strong> Sound Buffers</a></li><li class="chapter-item expanded "><a href="../../../../fyrox/resources/curve.html"><strong aria-hidden="true">2.4.4.</strong> Curves</a></li><li class="chapter-item expanded "><a href="../../../../fyrox/resources/absm.html"><strong aria-hidden="true">2.4.5.</strong> Animation Machines</a></li></ol></li><li class="chapter-item expanded "><a href="../../../../fyrox/ui/ui.html"><strong aria-hidden="true">2.5.</strong> User Interface</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../../fyrox/ui/basic_concepts/basic_concepts.html"><strong aria-hidden="true">2.5.1.</strong> Basic concepts</a></li><li class="chapter-item expanded "><a href="../../../../fyrox/ui/setting_up.html"><strong aria-hidden="true">2.5.2.</strong> Setting up a user interface</a></li><li class="chapter-item expanded "><a href="../../../../fyrox/ui/general_rules.html"><strong aria-hidden="true">2.5.3.</strong> General rules</a></li><li class="chapter-item expanded "><a href="../../../../fyrox/ui/font.html"><strong aria-hidden="true">2.5.4.</strong> Fonts</a></li><li class="chapter-item expanded "><a href="../../../../fyrox/ui/theme.html"><strong aria-hidden="true">2.5.5.</strong> Theme</a></li><li class="chapter-item expanded "><a href="../../../../fyrox/ui/widgets.html"><strong aria-hidden="true">2.5.6.</strong> Widgets</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../../fyrox/ui/button.html"><strong aria-hidden="true">2.5.6.1.</strong> Button</a></li><li class="chapter-item expanded "><a href="../../../../fyrox/ui/border.html"><strong aria-hidden="true">2.5.6.2.</strong> Border</a></li><li class="chapter-item expanded "><a href="../../../../fyrox/ui/canvas.html"><strong aria-hidden="true">2.5.6.3.</strong> Canvas</a></li><li class="chapter-item expanded "><a href="../../../../fyrox/ui/checkbox/check_box.html"><strong aria-hidden="true">2.5.6.4.</strong> Check box</a></li><li class="chapter-item expanded "><a href="../../../../fyrox/ui/curve_editor.html"><strong aria-hidden="true">2.5.6.5.</strong> Curve editor (WIP)</a></li><li class="chapter-item expanded "><a href="../../../../fyrox/ui/decorator.html"><strong aria-hidden="true">2.5.6.6.</strong> Decorator (WIP)</a></li><li class="chapter-item expanded "><a href="../../../../fyrox/ui/dock.html"><strong aria-hidden="true">2.5.6.7.</strong> Docking manager (WIP)</a></li><li class="chapter-item expanded "><a href="../../../../fyrox/ui/dropdown_list.html"><strong aria-hidden="true">2.5.6.8.</strong> Dropdown list (WIP)</a></li><li class="chapter-item expanded "><a href="../../../../fyrox/ui/expander.html"><strong aria-hidden="true">2.5.6.9.</strong> Expander (WIP)</a></li><li class="chapter-item expanded "><a href="../../../../fyrox/ui/file_browser.html"><strong aria-hidden="true">2.5.6.10.</strong> File browser (WIP)</a></li><li class="chapter-item expanded "><a href="../../../../fyrox/ui/grid.html"><strong aria-hidden="true">2.5.6.11.</strong> Grid</a></li><li class="chapter-item expanded "><a href="../../../../fyrox/ui/image.html"><strong aria-hidden="true">2.5.6.12.</strong> Image</a></li><li class="chapter-item expanded "><a href="../../../../fyrox/ui/inspector.html"><strong aria-hidden="true">2.5.6.13.</strong> Inspector (WIP)</a></li><li class="chapter-item expanded "><a href="../../../../fyrox/ui/list_view.html"><strong aria-hidden="true">2.5.6.14.</strong> List view (WIP)</a></li><li class="chapter-item expanded "><a href="../../../../fyrox/ui/menu.html"><strong aria-hidden="true">2.5.6.15.</strong> Menu (WIP)</a></li><li class="chapter-item expanded "><a href="../../../../fyrox/ui/message_box.html"><strong aria-hidden="true">2.5.6.16.</strong> Message box (WIP)</a></li><li class="chapter-item expanded "><a href="../../../../fyrox/ui/numeric.html"><strong aria-hidden="true">2.5.6.17.</strong> Numeric field (WIP)</a></li><li class="chapter-item expanded "><a href="../../../../fyrox/ui/popup.html"><strong aria-hidden="true">2.5.6.18.</strong> Popup (WIP)</a></li><li class="chapter-item expanded "><a href="../../../../fyrox/ui/progress_bar.html"><strong aria-hidden="true">2.5.6.19.</strong> Progress bar (WIP)</a></li><li class="chapter-item expanded "><a href="../../../../fyrox/ui/range.html"><strong aria-hidden="true">2.5.6.20.</strong> Range (WIP)</a></li><li class="chapter-item expanded "><a href="../../../../fyrox/ui/rect.html"><strong aria-hidden="true">2.5.6.21.</strong> Rect (WIP)</a></li><li class="chapter-item expanded "><a href="../../../../fyrox/ui/scroll_bar.html"><strong aria-hidden="true">2.5.6.22.</strong> Scroll bar (WIP)</a></li><li class="chapter-item expanded "><a href="../../../../fyrox/ui/scroll_panel.html"><strong aria-hidden="true">2.5.6.23.</strong> Scroll panel (WIP)</a></li><li class="chapter-item expanded "><a href="../../../../fyrox/ui/scroll_viewer.html"><strong aria-hidden="true">2.5.6.24.</strong> Scroll viewer (WIP)</a></li><li class="chapter-item expanded "><a href="../../../../fyrox/ui/stack_panel.html"><strong aria-hidden="true">2.5.6.25.</strong> Stack panel</a></li><li class="chapter-item expanded "><a href="../../../../fyrox/ui/tab_control.html"><strong aria-hidden="true">2.5.6.26.</strong> Tab Control</a></li><li class="chapter-item expanded "><a href="../../../../fyrox/ui/text.html"><strong aria-hidden="true">2.5.6.27.</strong> Text</a></li><li class="chapter-item expanded "><a href="../../../../fyrox/ui/text_box.html"><strong aria-hidden="true">2.5.6.28.</strong> Text box</a></li><li class="chapter-item expanded "><a href="../../../../fyrox/ui/tree.html"><strong aria-hidden="true">2.5.6.29.</strong> Tree (WIP)</a></li><li class="chapter-item expanded "><a href="../../../../fyrox/ui/vector_image.html"><strong aria-hidden="true">2.5.6.30.</strong> Vector image (WIP)</a></li><li class="chapter-item expanded "><a href="../../../../fyrox/ui/window.html"><strong aria-hidden="true">2.5.6.31.</strong> Window</a></li><li class="chapter-item expanded "><a href="../../../../fyrox/ui/wrap_panel.html"><strong aria-hidden="true">2.5.6.32.</strong> Wrap panel</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../../../../fyrox/serialization/serialization.html"><strong aria-hidden="true">2.6.</strong> Serialization (WIP)</a></li><li class="chapter-item expanded "><a href="../../../../fyrox/tutorials/tutorials.html"><strong aria-hidden="true">2.7.</strong> Tutorials</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../../fyrox/tutorials/fps/intro.html"><strong aria-hidden="true">2.7.1.</strong> FPS Tutorial</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../../fyrox/tutorials/fps/tutorial-1/tutorial-part-1.html" class="active"><strong aria-hidden="true">2.7.1.1.</strong> Character controller</a></li><li class="chapter-item expanded "><a href="../../../../fyrox/tutorials/fps/tutorial-2/tutorial-part-2.html"><strong aria-hidden="true">2.7.1.2.</strong> Weapons</a></li><li class="chapter-item expanded "><a href="../../../../fyrox/tutorials/fps/tutorial-3/tutorial-part-3.html"><strong aria-hidden="true">2.7.1.3.</strong> Bots and AI</a></li></ol></li><li class="chapter-item expanded "><a href="../../../../fyrox/tutorials/rpg/intro.html"><strong aria-hidden="true">2.7.2.</strong> RPG Tutorial</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../../fyrox/tutorials/rpg/tutorial-1/tutorial-part-1.html"><strong aria-hidden="true">2.7.2.1.</strong> Character controller</a></li></ol></li><li class="chapter-item expanded "><a href="../../../../fyrox/tutorials/platformer/part1.html"><strong aria-hidden="true">2.7.3.</strong> 2D Platformer tutorial</a></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Fyrox Book</h1>

                    <div class="right-buttons">
                        <a href="../../../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/fyrox-book/fyrox-book.github.io" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="fps-tutorial-part-1---character-controller"><a class="header" href="#fps-tutorial-part-1---character-controller">FPS Tutorial Part 1 - Character Controller.</a></h1>
<p><strong>Source code</strong>: <a href="https://github.com/FyroxEngine/Fyrox-tutorials/tree/main/tutorial1-character-controller">GitHub</a></p>
<h2 id="table-of-contents"><a class="header" href="#table-of-contents">Table of contents</a></h2>
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#creating-a-window">Creating a window</a></li>
<li><a href="#creating-your-first-scene">Creating your first scene</a></li>
<li><a href="#using-the-scene">Using the scene</a></li>
<li><a href="#character-controller">Character controller</a></li>
<li><a href="#finishing-touch">Finishing touch</a></li>
<li><a href="#conclusion">Conclusion</a></li>
</ul>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>Fyrox is a general purpose 3D engine, it allows creating any kind of 3D game, but today we'll focus on classic 3D shooter.
In this tutorial we'll write a simple character controller. This is what we're aiming for:</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/VcN3NUdfg3E" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<p>Let's start by creating a new cargo project, make a folder and execute this:</p>
<pre><code class="language-bash">cargo init --bin
</code></pre>
<p>Open Cargo.toml and add <code>fyrox</code> dependency:</p>
<pre><code class="language-toml">[dependencies]
fyrox = &quot;0.26.0&quot;
</code></pre>
<h3 id="creating-a-window"><a class="header" href="#creating-a-window">Creating a window</a></h3>
<p>Great! Now we can start writing the game. Let's start from something very simple - a window and a main loop. Just copy 
and paste this code in the <code>main.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">extern crate fyrox;
</span>use fyrox::{
    core::{
        algebra::{UnitQuaternion, Vector3},
        pool::Handle,
    },
    engine::{resource_manager::ResourceManager, Engine, EngineInitParams, SerializationContext},
    event::{DeviceEvent, ElementState, Event, VirtualKeyCode, WindowEvent},
    event_loop::{ControlFlow, EventLoop},
    resource::texture::TextureWrapMode,
    scene::{
        base::BaseBuilder,
        camera::{CameraBuilder, SkyBox, SkyBoxBuilder},
        collider::{ColliderBuilder, ColliderShape},
        node::Node,
        rigidbody::RigidBodyBuilder,
        transform::TransformBuilder,
        Scene,
    },
    window::WindowBuilder,
};
use std::{sync::Arc, time};

// Our game logic will be updated at 60 Hz rate.
const TIMESTEP: f32 = 1.0 / 60.0;

struct Game {
    // Empty for now.
}

impl Game {
    pub fn new() -&gt; Self {
        Self {}
    }

    pub fn update(&amp;mut self) {
        // Game logic will be placed here.
    }
}

fn main() {
    // Configure main window first.
    let window_builder = WindowBuilder::new().with_title(&quot;3D Shooter Tutorial&quot;);
    // Create event loop that will be used to &quot;listen&quot; events from the OS.
    let event_loop = EventLoop::new();

    // Finally create an instance of the engine.
    let serialization_context = Arc::new(SerializationContext::new());
    let mut engine = Engine::new(EngineInitParams {
        window_builder,
        resource_manager: ResourceManager::new(serialization_context.clone()),
        serialization_context,
        events_loop: &amp;event_loop,
        vsync: false,
    })
    .unwrap();

    // Initialize game instance. It is empty for now.
    let mut game = Game::new();

    // Run the event loop of the main window. which will respond to OS and window events and update
    // engine's state accordingly. Engine lets you to decide which event should be handled,
    // this is a minimal working example of how it should be.
    let clock = time::Instant::now();

    let mut elapsed_time = 0.0;
    event_loop.run(move |event, _, control_flow| {
        match event {
            Event::MainEventsCleared =&gt; {
                // This main game loop - it has fixed time step which means that game
                // code will run at fixed speed even if renderer can't give you desired
                // 60 fps.
                let mut dt = clock.elapsed().as_secs_f32() - elapsed_time;
                while dt &gt;= TIMESTEP {
                    dt -= TIMESTEP;
                    elapsed_time += TIMESTEP;

                    // Run our game's logic.
                    game.update();

                    // Update engine each frame.
                    engine.update(TIMESTEP);
                }

                // Rendering must be explicitly requested and handled after RedrawRequested event is received.
                engine.get_window().request_redraw();
            }
            Event::RedrawRequested(_) =&gt; {
                // Render at max speed - it is not tied to the game code.
                engine.render().unwrap();
            }
            Event::WindowEvent { event, .. } =&gt; match event {
                WindowEvent::CloseRequested =&gt; *control_flow = ControlFlow::Exit,
                WindowEvent::KeyboardInput { input, .. } =&gt; {
                    // Exit game by hitting Escape.
                    if let Some(VirtualKeyCode::Escape) = input.virtual_keycode {
                        *control_flow = ControlFlow::Exit
                    }
                }
			    WindowEvent::Resized(size) =&gt; {
                    // It is very important to handle Resized event from window, because
                    // renderer knows nothing about window size - it must be notified
                    // directly when window size has changed.
                    engine.set_frame_size(size.into()).unwrap();
                }
                _ =&gt; (),
            },
            _ =&gt; *control_flow = ControlFlow::Poll,
        }
    });
}
</code></pre></pre>
<p>Wow! There is lots of code for such a simple task. Fear not, everything here is pretty straightforward, let's dive into
this code and disassemble it line by line. Just skip imports, it's too boring. Let's look at this line:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const TIMESTEP: f32 = 1.0 / 60.0;
<span class="boring">}
</span></code></pre></pre>
<p>Here we define a rate of update for logic of our future game, just sticking to common 60 FPS. Next goes the skeleton of
the game, just a struct with two methods. It will be filled later in this tutorial.</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Game {
    // Empty for now.
}

impl Game {
    pub fn new() -&gt; Self {
        Self {}
    }

    pub fn update(&amp;mut self) {
        // Game logic will be placed here.
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Finally, we at the point where the interesting stuff happens - <code>fn main()</code>. We're starting by creating a window builder:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::window::WindowBuilder;
</span>let window_builder = WindowBuilder::new().with_title(&quot;3D Shooter Tutorial&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>The builder will be used later by the engine to create a window. Next we're creating our event loop: </p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::event_loop::EventLoop;
</span>let event_loop = EventLoop::new();
<span class="boring">}
</span></code></pre></pre>
<p>The event loop is a &quot;magic&quot; thing that receives events from the operating system and feeds your application, this is a very 
important part which makes the application work. Finally, we're creating an instance of the engine:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let serialization_context = Arc::new(SerializationContext::new());
let mut engine = Engine::new(EngineInitParams {
    window_builder,
    resource_manager: ResourceManager::new(serialization_context.clone()),
    serialization_context,
    events_loop: &amp;event_loop,
    vsync: false,
})
.unwrap();
<span class="boring">}
</span></code></pre></pre>
<p>At first, we're creating an instance of <code>SerializationContext</code> - it is used to store type constructors used for 
serialization needs. Next, we're filling <code>EngineInitParams</code> structure, there is nothing interesting there, except maybe
a flag that is responsible for vertical synchronization (VSync). In this tutorial we'll have VSync disabled, because
it requires specific platform-dependent extensions which are not always available and calling <code>.unwrap()</code> might result
in panic on some platforms. Next we're creating an instance of the game, remember this line, it will be changed soon:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut game = Game::new();
<span class="boring">}
</span></code></pre></pre>
<p>Next we define two variables for the game loop: </p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let clock = time::Instant::now();
let mut elapsed_time = 0.0;
<span class="boring">}
</span></code></pre></pre>
<p>At first, we &quot;remember&quot; the starting point of the game in time. The next variable is used to control the game loop. Finally, we run the
event loop and start checking for events coming from the OS:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>event_loop.run(move |event, _, control_flow| {
    match event {
        ...
    }
});
<span class="boring">}
</span></code></pre></pre>
<p>Let's look at each event separately starting from <code>Event::MainEventsCleared</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Event::MainEventsCleared =&gt; {
    // This main game loop - it has fixed time step which means that game
    // code will run at fixed speed even if renderer can't give you desired
    // 60 fps.
    let mut dt = clock.elapsed().as_secs_f32() - elapsed_time;
    while dt &gt;= TIMESTEP {
        dt -= TIMESTEP;
        elapsed_time += TIMESTEP;

        // Run our game's logic.
        game.update();

        // Update engine each frame.
        engine.update(TIMESTEP);
    }

    // Rendering must be explicitly requested and handled after RedrawRequested event is received.
    engine.get_window().request_redraw();
}
<span class="boring">}
</span></code></pre></pre>
<p>This is the heart of game loop - it stabilizes update rate of game logic by measuring time from last update call
and performs a various amount of iterations based on an amount of time since last update. This makes the game logic update
rate independent of FPS - it will be always 60 Hz for game logic even if FPS is 10. The <code>while</code> loop contains 
<code>game.update()</code> and <code>engine.update(TIMESTEP)</code> calls to update game's logic and engine internals respectively. After the
loop we're asking the engine to render the next frame. In the next match arm <code>Event::RedrawRequested</code> we're handing our request: </p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Event::RedrawRequested(_) =&gt; {
    // Render at max speed - it is not tied to the game code.
    engine.render().unwrap();
}
<span class="boring">}
</span></code></pre></pre>
<p>As you can see rendering happens in a single line of code. Next we need to handle window events:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Event::WindowEvent { event, .. } =&gt; match event {
    WindowEvent::CloseRequested =&gt; *control_flow = ControlFlow::Exit,
    WindowEvent::KeyboardInput { input, .. } =&gt; {
        // Exit game by hitting Escape.
        if let Some(VirtualKeyCode::Escape) = input.virtual_keycode {
            *control_flow = ControlFlow::Exit
        }
    }
	WindowEvent::Resized(size) =&gt; {
		// It is very important to handle Resized event from window, because
		// renderer knows nothing about window size - it must be notified
		// directly when window size has changed.
		engine.set_frame_size(size.into()).unwrap();
	}
    _ =&gt; (),
},
<span class="boring">}
</span></code></pre></pre>
<p>Here we're just checking if the player has hit Escape button and exit game if so. Also, when <code>WindowEvent::Resized</code> is 
received, we're notifying renderer about that, so it's render targets will be resized too. The final match arm is for 
every other event, nothing fancy here - just asking engine to continue listening for new events.</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>_ =&gt; *control_flow = ControlFlow::Poll,
<span class="boring">}
</span></code></pre></pre>
<p>So far so good. This small piece of code just creates a new window and fills it with black color, now we can start 
writing the game. </p>
<p><img src="./tutorial1-window.jpg" alt="Window" /></p>
<p>Let's start by creating a simple scene where we'll test our character controller. This is the time when 
<a href="https://github.com/FyroxEngine/Fyrox/tree/master/editor">Fyroxed</a> comes into play - Fyroxed is a native scene editor of the
engine. It is worth mentioning what &quot;scene editor&quot; means: unlike many other engines (Unity, UnrealEngine, etc.),
Fyroxed does <strong>not</strong> allow you to run your game inside it, instead you just edit your scene, save it in the editor and load it in
your game. Being able to run a game inside the editor was a very huge task for one person, and I just chose the 
easiest way. Alright, back to the interesting stuff. Build the editor first using instructions from its
<a href="https://github.com/FyroxEngine/Fyrox/tree/master/editor">GitHub page</a> using specific commit stated in the beginning of the article.</p>
<h2 id="creating-your-first-scene"><a class="header" href="#creating-your-first-scene">Creating your first scene</a></h2>
<p>This section is completely optional, if you eager to make the game - just use a 
<a href="./data.zip">pre-made scene</a> (download it and unpack in the folder of your game) and go to
the <a href="#using-the-scene">next section</a>. Open Fyroxed, it should look like this:</p>
<p><img src="./tutorial1-rusty-editor.jpg" alt="Fyroxed" /></p>
<p>It will ask you to choose a working directory.</p>
<p><img src="./tutorial1-configurator.jpg" alt="configurator" /></p>
<p>The working directory is simply a path to your game's executable, in most cases it will be the root folder of your
project.</p>
<p>Next, click <code>File -&gt; CreateScene</code>. Now you can start modifying your scene. All we need for now is a floor and maybe 
some decorations. To do that, you can either create everything from simple objects (cubes, cones, cylinders,
etc.) or load some assets made in 3D editors (like Blender, 3Ds max, etc.). Here we combine two approaches: floor will 
be just a squashed cube and decorations will be 3D models. Let's start from the floor. Click <code>Create -&gt; Mesh -&gt; Cube</code>, 
select the cube and use Scale tool from the toolbar to squash it to form the floor.</p>
<p><img src="./tutorial1-rusty-editor-floor.jpg" alt="Floor" /></p>
<p>Next we need to add physical body to the floor to not fall through it. This is very simple, click <code>Create -&gt; Physics -&gt; Rigid Body</code>
then right-click on the rigid body in the World Viewer and click <code>Create -&gt; Physics -&gt; Collider</code>. Next we need to bind the 
floor 3D model with the rigid body, to do that drag'n'drop the floor entity to the rigid body. Now we need to configure the
collider of the rigid body. Select it and go to Inspector, find Shape property and select Trimesh from the dropdown list.
Next, click <code>+</code> sign in Sources and then drag'n'drop floor entity to <code>Unassigned</code> entry while holding <code>Alt</code> on the keyboard.
By doing this, we've added a source of geometry for triangle mesh collider. Also, we need to make the rigid body
static, so it won't be affected by gravity and external forces, otherwise the floor will fall as any other
dynamic rigid body. To do that, simply select the body and change its <code>Body Type</code> property to <code>Static</code>.</p>
<p><img src="./tutorial1-rusty-editor-floor-body.jpg" alt="Floor Body" /></p>
<p>Ok, good, but it looks awful, let's add some texture to it, to do that, 
<a href="./floor.jpg">download floor texture</a>, place it to <code>data/textures</code> and apply it to the floor. 
To do that, use the asset browser: at its left side it shows file system of your project, locate <code>data/textures</code> folder 
and select <code>floor.jpg</code>. Now just drag-n-drop the texture to the floor, this is what you should get.</p>
<p><img src="./tutorial1-rusty-editor-floor-texture.jpg" alt="Floor Texture" /></p>
<p>Now let's add some decorations, to do that <a href="./barrel.zip">download 3D model</a> I prepared for
this tutorial and unpack it in <code>data/models</code>. Now go to the <code>data/models</code> in the asset browser and just drag-n-drop the
<code>barrel.FBX</code> to the scene. Now use the Scale and Move tools to adjust scale and position of the barrel, it should look 
like this: </p>
<p><img src="./tutorial1-rusty-editor-barrel-body.jpg" alt="Barrel Body" /></p>
<p>Barrel does not have any rigid body yet, and it won't interact with world. Let's fix this. As usual, click <code>Create -&gt; Physics -&gt; Rigid Body</code> 
then click on the added rigid body and add a cylinder collider by right-click on it and selecting <code>Create -&gt; Physics -&gt; Colider</code>.
Now select the collider and set its shape to Cylinder adjust its height and radius. As a final step drag'n'drop the <code>barrel.FBX</code> scene 
node on the rigid body node.</p>
<p>Now clone some barrels, to do that select a parent rigid body of some <code>barrel.FBX</code> in the <code>World Outliner</code>, 
right-click on the scene preview and press <code>Ctrl+C</code> to copy the barrel and <code>Ctrl+V</code> to paste. Repeat multiple times.</p>
<p><img src="./tutorial1-rusty-editor-barrels.jpg" alt="Barrel" /></p>
<p>Also add a light source, to do that go to <code>Create -&gt; Light -&gt; Point</code> and adjust its position using the Move tool.</p>
<p><img src="./tutorial1-rusty-editor-light.jpg" alt="Barrel" /></p>
<p>The final step: save your scene in <code>data/models</code>, to do that go to <code>File -&gt; Save</code> and select the folder and type name 
of the scene in the field it should be <code>scene.rgs</code>.</p>
<h2 id="using-the-scene"><a class="header" href="#using-the-scene">Using the scene</a></h2>
<p>Now it's the time to load the scene we've made earlier in the game. This is very simple, all we need to do is to load
scene as resource and create its instance. Change <code>fn new()</code> body to:</p>
<pre><pre class="playground"><code class="language-rust no_run edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::{algebra::Vector3, pool::Handle},
</span><span class="boring">    engine::Engine,
</span><span class="boring">    scene::{
</span><span class="boring">        base::BaseBuilder, camera::CameraBuilder, node::Node, transform::TransformBuilder,
</span><span class="boring">        Scene,
</span><span class="boring">    },
</span><span class="boring">};
</span><span class="boring">struct Stub {
</span><span class="boring">    camera: Handle&lt;Node&gt;,
</span><span class="boring">    scene: Handle&lt;Scene&gt;,
</span><span class="boring">}
</span><span class="boring">impl Stub {
</span>pub async fn new(engine: &amp;mut Engine) -&gt; Self {
    let mut scene = Scene::new();

    // Load a scene resource and create its instance.
    engine
        .resource_manager
        .request_model(&quot;data/models/scene.rgs&quot;)
        .await
        .unwrap()
        .instantiate_geometry(&amp;mut scene);

    // Next create a camera, it is our &quot;eyes&quot; in the world.
    // This can also be made in editor, but for educational purpose we'll made it by hand.
    let camera = CameraBuilder::new(
        BaseBuilder::new().with_local_transform(
            TransformBuilder::new()
                .with_local_position(Vector3::new(0.0, 1.0, -3.0))
                .build(),
        ),
    )
    .build(&amp;mut scene.graph);

    Self {
        camera,
        scene: engine.scenes.add(scene),
    }
}
<span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p>You may have noticed that the <code>Game</code> structure now has two new fields: </p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Game {
    scene: Handle&lt;Scene&gt;, // A handle to the scene
    camera: Handle&lt;Node&gt;, // A handle to the camera
}
<span class="boring">}
</span></code></pre></pre>
<p>These fields are just handles to the &quot;entities&quot; we've created in the <code>Game::new()</code>. Also, change <code>let mut game = Game::new();</code> to this:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut game = fyrox::core::futures::executor::block_on(Game::new(&amp;mut engine));
<span class="boring">}
</span></code></pre></pre>
<p>Here we execute async function <code>Game::new()</code> and it creates game's instance with the scene we've made previously.
Run the game and you should see this:</p>
<p><img src="./tutorial1-scene.jpg" alt="Barrel" /></p>
<p>Cool! Now let's disassemble <code>fn new()</code> line by line. First, we're creating an empty scene:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut scene = Scene::new();
<span class="boring">}
</span></code></pre></pre>
<p>The next few lines are the most interesting:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>engine
    .resource_manager
    .request_model(&quot;data/models/scene.rgs&quot;)
    .await
    .unwrap()
    .instantiate_geometry(&amp;mut scene);
<span class="boring">}
</span></code></pre></pre>
<p>Here we're asking the resource manager to load the scene we've made previously, awaiting while it loads and then instantiating
it on the <code>scene</code>. What does &quot;instantiation&quot; mean? In short, it means that we're creating a copy of a scene and adding the copy
to some other scene, the engine remembers connections between clones and original entities and is capable of restoring data
from resource for the instance. At this point we've successfully instantiated the scene. However, we won't see anything
yet - we need a camera:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let camera = CameraBuilder::new(
    BaseBuilder::new().with_local_transform(
        TransformBuilder::new()
            .with_local_position(Vector3::new(0.0, 1.0, -3.0))
            .build(),
    ),
)
.build(&amp;mut scene.graph);
<span class="boring">}
</span></code></pre></pre>
<p>Camera is our &quot;eyes&quot; in the world, here we're just creating a camera and moving it a bit up and back to be able to see the 
scene. Finally, we're adding the scene to the engine's container for scenes, and it gives us a handle to the scene. Later
we'll use the handle to borrow scene and modify it.</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Self {
    camera,
    scene: engine.scenes.add(scene),
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="character-controller"><a class="header" href="#character-controller">Character controller</a></h2>
<p>We've made a lot of things already, but still can't move in the scene. Let's fix this! We'll start writing the character
controller which will allow us to walk in our scene. Let's start with a chunk of code as usual:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::{
</span><span class="boring">        algebra::{UnitQuaternion, Vector3},
</span><span class="boring">        pool::Handle,
</span><span class="boring">    },
</span><span class="boring">    engine::{resource_manager::ResourceManager, Engine},
</span><span class="boring">    event::{DeviceEvent, ElementState, Event, VirtualKeyCode, WindowEvent},
</span><span class="boring">    event_loop::{ControlFlow, EventLoop},
</span><span class="boring">    resource::texture::TextureWrapMode,
</span><span class="boring">    scene::{
</span><span class="boring">        base::BaseBuilder,
</span><span class="boring">        camera::{CameraBuilder, SkyBox, SkyBoxBuilder},
</span><span class="boring">        collider::{ColliderBuilder, ColliderShape},
</span><span class="boring">        node::Node,
</span><span class="boring">        rigidbody::RigidBodyBuilder,
</span><span class="boring">        transform::TransformBuilder,
</span><span class="boring">        Scene,
</span><span class="boring">    },
</span><span class="boring">    window::WindowBuilder,
</span><span class="boring">};
</span><span class="boring">use std::time;
</span>
#[derive(Default)]
struct InputController {
    move_forward: bool,
    move_backward: bool,
    move_left: bool,
    move_right: bool,
    pitch: f32,
    yaw: f32,
}

struct Player {
    camera: Handle&lt;Node&gt;,
    rigid_body: Handle&lt;Node&gt;,
    controller: InputController,
}

impl Player {
    fn new(scene: &amp;mut Scene) -&gt; Self {
        // Create rigid body with a camera, move it a bit up to &quot;emulate&quot; head.
        let camera;
        let rigid_body_handle = RigidBodyBuilder::new(
            BaseBuilder::new()
                .with_local_transform(
                    TransformBuilder::new()
                        // Offset player a bit.
                        .with_local_position(Vector3::new(0.0, 1.0, -1.0))
                        .build(),
                )
                .with_children(&amp;[
                    {
                        camera = CameraBuilder::new(
                            BaseBuilder::new().with_local_transform(
                                TransformBuilder::new()
                                    .with_local_position(Vector3::new(0.0, 0.25, 0.0))
                                    .build(),
                            ),
                        )
                        .build(&amp;mut scene.graph);
                        camera
                    },
                    // Add capsule collider for the rigid body.
                    ColliderBuilder::new(BaseBuilder::new())
                        .with_shape(ColliderShape::capsule_y(0.25, 0.2))
                        .build(&amp;mut scene.graph),
                ]),
        )
        // We don't want the player to tilt.
        .with_locked_rotations(true)
        // We don't want the rigid body to sleep (be excluded from simulation)
        .with_can_sleep(false)
        .build(&amp;mut scene.graph);

        Self {
            camera,
            rigid_body: rigid_body_handle,
            controller: Default::default(),
        }
    }

    fn update(&amp;mut self, scene: &amp;mut Scene) {
        // Set pitch for the camera. These lines responsible for up-down camera rotation.
        scene.graph[self.camera].local_transform_mut().set_rotation(
            UnitQuaternion::from_axis_angle(&amp;Vector3::x_axis(), self.controller.pitch.to_radians()),
        );

        // Borrow rigid body node.
        let body = scene.graph[self.rigid_body].as_rigid_body_mut();

        // Keep only vertical velocity, and drop horizontal.
        let mut velocity = Vector3::new(0.0, body.lin_vel().y, 0.0);

        // Change the velocity depending on the keys pressed.
        if self.controller.move_forward {
            // If we moving forward then add &quot;look&quot; vector of the body.
            velocity += body.look_vector();
        }
        if self.controller.move_backward {
            // If we moving backward then subtract &quot;look&quot; vector of the body.
            velocity -= body.look_vector();
        }
        if self.controller.move_left {
            // If we moving left then add &quot;side&quot; vector of the body.
            velocity += body.side_vector();
        }
        if self.controller.move_right {
            // If we moving right then subtract &quot;side&quot; vector of the body.
            velocity -= body.side_vector();
        }

        // Finally new linear velocity.
        body.set_lin_vel(velocity);

        // Change the rotation of the rigid body according to current yaw. These lines responsible for
        // left-right rotation.
        body.local_transform_mut()
            .set_rotation(UnitQuaternion::from_axis_angle(
                &amp;Vector3::y_axis(),
                self.controller.yaw.to_radians(),
            ));
    }

    fn process_input_event(&amp;mut self, event: &amp;Event&lt;()&gt;) {
        match event {
            Event::WindowEvent { event, .. } =&gt; {
                if let WindowEvent::KeyboardInput { input, .. } = event {
                    if let Some(key_code) = input.virtual_keycode {
                        match key_code {
                            VirtualKeyCode::W =&gt; {
                                self.controller.move_forward = input.state == ElementState::Pressed;
                            }
                            VirtualKeyCode::S =&gt; {
                                self.controller.move_backward =
                                    input.state == ElementState::Pressed;
                            }
                            VirtualKeyCode::A =&gt; {
                                self.controller.move_left = input.state == ElementState::Pressed;
                            }
                            VirtualKeyCode::D =&gt; {
                                self.controller.move_right = input.state == ElementState::Pressed;
                            }
                            _ =&gt; (),
                        }
                    }
                }
            }
            Event::DeviceEvent { event, .. } =&gt; {
                if let DeviceEvent::MouseMotion { delta } = event {
                    self.controller.yaw -= delta.0 as f32;

                    self.controller.pitch =
                        (self.controller.pitch + delta.1 as f32).clamp(-90.0, 90.0);
                }
            }
            _ =&gt; (),
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>This is all the code we need for character controller, quite a lot actually, but as usual everything here is pretty
straightforward.</p>
<pre><pre class="playground"><code class="language-rust no_run edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::core::pool::Handle;
</span><span class="boring">use fyrox::engine::Engine;
</span><span class="boring">use fyrox::scene::Scene;
</span><span class="boring">struct Player;
</span><span class="boring">impl Player {
</span><span class="boring">    fn new(_scene: &amp;mut Scene) -&gt; Self {
</span><span class="boring">        Self
</span><span class="boring">    }
</span><span class="boring">    fn update(&amp;mut self, _scene: &amp;mut Scene) {}
</span><span class="boring">}
</span>// Also we must change Game structure a bit too and the new() code.
struct Game {
    scene: Handle&lt;Scene&gt;,
    player: Player, // New
}

impl Game {
    pub async fn new(engine: &amp;mut Engine) -&gt; Self {
        let mut scene = Scene::new();

        // Load a scene resource and create its instance.
        engine
            .resource_manager
            .request_model(&quot;data/models/scene.rgs&quot;)
            .await
            .unwrap()
            .instantiate_geometry(&amp;mut scene);

        Self {
            player: Player::new(&amp;mut scene), // New
            scene: engine.scenes.add(scene),
        }
    }

    pub fn update(&amp;mut self, engine: &amp;mut Engine) {
        self.player.update(&amp;mut engine.scenes[self.scene]); // New
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>We've moved camera creation to <code>Player</code>, because now the camera is attached to the player's body. Also, we must add this line
in the beginning of <code>event_loop.run(...)</code> to let <code>player</code> handle input events:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>game.player.process_input_event(&amp;event);        
<span class="boring">}
</span></code></pre></pre>
<p>So, let's try to understand what happens in this huge chunk of code. Let's start from the <code>InputController</code> struct,
it holds the state of the input for a single frame and rotations of player &quot;parts&quot;. </p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Default)]
struct InputController {
    move_forward: bool,
    move_backward: bool,
    move_left: bool,
    move_right: bool,
    pitch: f32,
    yaw: f32,
}
<span class="boring">}
</span></code></pre></pre>
<p>Next goes the <code>Player::new()</code> function. First, we're creating a simple chain of nodes of different kinds in the
<a href="https://en.wikipedia.org/wiki/Scene_graph">scene graph</a>. </p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let camera;
let rigid_body_handle = RigidBodyBuilder::new(
        BaseBuilder::new()
            .with_local_transform(
                TransformBuilder::new()
                    // Offset player a bit.
                    .with_local_position(Vector3::new(0.0, 1.0, -1.0))
                    .build(),
            )
            .with_children(&amp;[
                {
                    camera = CameraBuilder::new(
                        BaseBuilder::new().with_local_transform(
                            TransformBuilder::new()
                                .with_local_position(Vector3::new(0.0, 0.25, 0.0))
                                .build(),
                        ),
                    )
                    .build(&amp;mut scene.graph);
                    camera
                },
                // Add capsule collider for the rigid body.
                ColliderBuilder::new(BaseBuilder::new())
                    .with_shape(ColliderShape::capsule_y(0.25, 0.2))
                    .build(&amp;mut scene.graph),
            ]),
    )
    // We don't want the player to tilt.
    .with_locked_rotations(true)
    // We don't want the rigid body to sleep (be excluded from simulation)
    .with_can_sleep(false)
    .build(&amp;mut scene.graph);
<span class="boring">}
</span></code></pre></pre>
<p>Basically we're making something like this:</p>
<p><img src="./tutorial1-graph-example.png" alt="Graph" /></p>
<p>As you can see, the camera is attached to the rigid body and has a <strong>relative</strong> position of <code>(0.0, 0.25, 0.0)</code>. So when we'll
move rigid body, the camera will move too (and rotate of course). </p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Self {
    camera,
    rigid_body: rigid_body_handle,
    controller: Default::default(),
}
<span class="boring">}
</span></code></pre></pre>
<p>Next goes the <code>fn update(...)</code> function, it is responsible for movement of the player. It starts from these lines:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Set pitch for the camera. These lines responsible for up-down camera rotation.
scene.graph[self.camera].local_transform_mut().set_rotation(
    UnitQuaternion::from_axis_angle(&amp;Vector3::x_axis(), self.controller.pitch.to_radians()),
);
<span class="boring">}
</span></code></pre></pre>
<p>We're borrowing the camera from the graph (<code>scene.graph[self.camera]</code>) and modifying its <strong>local</strong> rotation, using a 
<a href="https://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation">quaternion</a> built from an axis, and an angle.
This rotates camera in vertical direction. Let's talk about borrowing in the engine. Almost every object in the 
engine &quot;lives&quot; in generational arenas (pool in fyrox's terminology). Pool is a contiguous chunk of memory, to be
able to &quot;reference&quot; an object in a pool Fyrox uses handles. Almost every entity has a single owner - the engine,
so to mutate or read data from an entity your have to borrow it first, like this:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Borrow rigid body node.
let body = scene.graph[self.rigid_body].as_rigid_body_mut();
<span class="boring">}
</span></code></pre></pre>
<p>This piece of code <code>scene.graph[self.rigid_body]</code> borrows <code>rigid_body</code> as either mutable or shared, depending on the context (basically
it is just an implementation of Index + IndexMut traits). Once we've borrowed objects, we can modify them. As the next
step we calculate new horizontal speed for the player:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Keep only vertical velocity, and drop horizontal.
let mut velocity = Vector3::new(0.0, body.lin_vel().y, 0.0);

// Change the velocity depending on the keys pressed.
if self.controller.move_forward {
    // If we moving forward then add &quot;look&quot; vector of the body.
    velocity += body.look_vector();
}
if self.controller.move_backward {
    // If we moving backward then subtract &quot;look&quot; vector of the body.
    velocity -= body.look_vector();
}
if self.controller.move_left {
    // If we moving left then add &quot;side&quot; vector of the body.
    velocity += body.side_vector();
}
if self.controller.move_right {
    // If we moving right then subtract &quot;side&quot; vector of the body.
    velocity -= body.side_vector();
}

// Finally new linear velocity.
body.set_lin_vel(velocity);
<span class="boring">}
</span></code></pre></pre>
<p>We don't need to modify vertical speed, because it should be controlled by the physics engine. Finally, we're setting
rotation of the rigid body:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Change the rotation of the rigid body according to current yaw. These lines responsible for
// left-right rotation.
body.local_transform_mut()
    .set_rotation(UnitQuaternion::from_axis_angle(
        &amp;Vector3::y_axis(),
        self.controller.yaw.to_radians(),
    ));
<span class="boring">}
</span></code></pre></pre>
<p>The next piece of code is a bit boring, but still should be addressed - it is input handling. In the <code>process_input_event</code>
we check input events and configure input controller accordingly. Basically we're just checking if W, S, A, D keys were 
pressed or released. In the <code>MouseMotion</code> arm, we're modifying yaw and pitch of the controller according to mouse 
velocity. Nothing fancy, except this line:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>self.controller.pitch = (self.controller.pitch + delta.1 as f32).clamp(-90.0, 90.0);
<span class="boring">}
</span></code></pre></pre>
<p>Here we're just restricting pitch to [-90; 90] degree range to not let flipping camera upside-down. Now let's run the 
game, you should see something like this and be able to walk and turn the camera.</p>
<p><img src="./tutorial1-controller.jpg" alt="Controller" /></p>
<h2 id="finishing-touch"><a class="header" href="#finishing-touch">Finishing touch</a></h2>
<p>One more thing before we end the tutorial. Black &quot;void&quot; around us isn't nice, let's add skybox for the camera to improve
that. Skybox is a very simple effect that significantly improves scene quality. To add a skybox, add this code first
somewhere before <code>impl Player</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    engine::{
</span><span class="boring">        resource_manager::{ResourceManager},
</span><span class="boring">    },
</span><span class="boring">    resource::texture::TextureWrapMode,
</span><span class="boring">    scene::{
</span><span class="boring">        camera::{SkyBox, SkyBoxBuilder},
</span><span class="boring">    },
</span><span class="boring">};
</span>async fn create_skybox(resource_manager: ResourceManager) -&gt; SkyBox {
    // Load skybox textures in parallel.
    let (front, back, left, right, top, bottom) = fyrox::core::futures::join!(
        resource_manager.request_texture(&quot;data/textures/skybox/front.jpg&quot;),
        resource_manager.request_texture(&quot;data/textures/skybox/back.jpg&quot;),
        resource_manager.request_texture(&quot;data/textures/skybox/left.jpg&quot;),
        resource_manager.request_texture(&quot;data/textures/skybox/right.jpg&quot;),
        resource_manager.request_texture(&quot;data/textures/skybox/up.jpg&quot;),
        resource_manager.request_texture(&quot;data/textures/skybox/down.jpg&quot;)
    );

    // Unwrap everything.
    let skybox = SkyBoxBuilder {
        front: Some(front.unwrap()),
        back: Some(back.unwrap()),
        left: Some(left.unwrap()),
        right: Some(right.unwrap()),
        top: Some(top.unwrap()),
        bottom: Some(bottom.unwrap()),
    }
        .build()
        .unwrap();

    // Set S and T coordinate wrap mode, ClampToEdge will remove any possible seams on edges
    // of the skybox.
    let skybox_texture = skybox.cubemap().unwrap();
    let mut data = skybox_texture.data_ref();
    data.set_s_wrap_mode(TextureWrapMode::ClampToEdge);
    data.set_t_wrap_mode(TextureWrapMode::ClampToEdge);

    skybox
}
<span class="boring">}
</span></code></pre></pre>
<p>Then modify signature of <code>Player::new</code> to </p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn new(scene: &amp;mut Scene, resource_manager: ResourceManager) -&gt; Self
<span class="boring">}
</span></code></pre></pre>
<p>We just added resource manager parameter here, and made the function async, because we'll load a bunch of textures 
in the <code>create_skybox</code> function. Add following line at camera builder (before <code>.build</code>):</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>.with_skybox(create_skybox(resource_manager).await)
<span class="boring">}
</span></code></pre></pre>
<p>Also modify player creation in <code>Game::new</code> to this</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>player: Player::new(&amp;mut scene, engine.resource_manager.clone()).await,
<span class="boring">}
</span></code></pre></pre>
<p>Next, download skybox textures from <a href="./skybox.zip">here</a> and extract the archive in 
<code>data/textures</code> (all textures from  the archive must be in <code>data/textures/skybox</code>). Now you can run the game, and you
should see something like this:</p>
<p><img src="./tutorial1-skybox.jpg" alt="Controller" /></p>
<p>This was the last step of this tutorial.</p>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>In this tutorial we've learned how to use the engine and the editor. Created simple character controller and walked on
the scene we've made in the editor. I hope you liked this tutorial, and if so, please consider supporting the project on 
<a href="https://patreon.com/mrdimas">Patreon</a> or <a href="https://liberapay.com/mrDIMAS">LiberaPay</a>. Source code is available on
<a href="https://github.com/FyroxEngine/Fyrox-tutorials">GitHub</a>. In the next tutorial we'll start adding weapons.</p>
<p>Discussion: <a href="https://www.reddit.com/r/rust/comments/lyj1tq/writing_a_3d_shooter_using_rg3d_game_engine_1/">Reddit</a>,
<a href="https://discord.gg/xENF5Uh">Discord</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../../../fyrox/tutorials/fps/intro.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../../../../fyrox/tutorials/fps/tutorial-2/tutorial-part-2.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../../../fyrox/tutorials/fps/intro.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../../../../fyrox/tutorials/fps/tutorial-2/tutorial-part-2.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../../../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../../../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../../../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../../../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../../../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
