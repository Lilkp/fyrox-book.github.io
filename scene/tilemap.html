<!DOCTYPE HTML>
<html lang="en" class="navy sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Tile Map - Fyrox Book</title>


        <!-- Custom HTML head -->
        <!-- Google tag (gtag.js) -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-ETGWNBR03Y"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-ETGWNBR03Y');
        </script>

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('navy')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Fyrox Book</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/fyrox-book/fyrox-book.github.io/tree/main" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/fyrox-book/fyrox-book.github.io/edit/main/src/scene/tilemap.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="tile-map"><a class="header" href="#tile-map">Tile Map</a></h1>
<p>Tile map is a 2D "image", made out of a small blocks called tiles. Tile maps used in 2D games to build game worlds
quickly and easily.</p>
<blockquote>
<p>⚠️ This functionality is available only on nightly version of the engine and will be a part of the next stable release.
If you want to use it, read <a href="../beginning/scripting.html#using-the-latest-engine-version">this chapter</a> to learn how to
switch to the nightly version of the engine.</p>
</blockquote>
<p>An example of a tile map could be something like this:</p>
<p><img src="tile_map.png" alt="tile map" /></p>
<h2 id="how-to-create"><a class="header" href="#how-to-create">How to Create</a></h2>
<p>As usual, there are two major ways of creating a tile map - via code or via the editor. Code-based approach is ideal for
procedural worlds, while the editor-based approach is good for hand-crafted worlds.</p>
<h3 id="code"><a class="header" href="#code">Code</a></h3>
<p>The following example creates a simple tile map with two tile types - grass and stone. It creates stone foundation and
lays grass on top of it.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_tile_map(graph: &amp;mut Graph) -&gt; Handle&lt;Node&gt; {
    // Each tile could have its own material, for simplicity it is just a standard 2D material.
    let material = MaterialResource::new_ok(ResourceKind::Embedded, Material::standard_2d());

    // Create a tile set - it is a data source for the tile map. Tile map will reference the tiles
    // stored in the tile set by handles. We'll create two tile types with different colors.
    let mut tile_set = TileSet::default();
    let stone_tile = tile_set.add_tile(TileDefinition {
        material: material.clone(),
        uv_rect: Rect::new(0.0, 0.0, 1.0, 1.0),
        collider: TileCollider::Rectangle,
        color: Color::BROWN,
        position: Default::default(),
        properties: vec![],
    });
    let grass_tile = tile_set.add_tile(TileDefinition {
        material,
        uv_rect: Rect::new(0.0, 0.0, 1.0, 1.0),
        collider: TileCollider::Rectangle,
        color: Color::GREEN,
        position: Default::default(),
        properties: vec![],
    });
    let tile_set = TileSetResource::new_ok(ResourceKind::Embedded, tile_set);

    let mut tiles = Tiles::default();

    // Create stone foundation.
    for x in 0..10 {
        for y in 0..2 {
            tiles.insert(Tile {
                position: Vector2::new(x, y),
                definition_handle: stone_tile,
            });
        }
    }

    // Add grass on top of it.
    for x in 0..10 {
        tiles.insert(Tile {
            position: Vector2::new(x, 2),
            definition_handle: grass_tile,
        });
    }

    // Finally create the tile map.
    TileMapBuilder::new(BaseBuilder::new())
        .with_tile_set(tile_set)
        .with_tiles(tiles)
        .build(graph)
}
<span class="boring">}</span></code></pre></pre>
<p>Please refer to the API docs for more info about each method.</p>
<h3 id="editor"><a class="header" href="#editor">Editor</a></h3>
<p>Editor-based approach requires a bit of preparation, yet it is still simple. At first, create a scene, then you need a
tile set, something like this:</p>
<p><img src="tileset.png" alt="tile set" /></p>
<p>It is a 11x11 sprite sheet for a top-down game. Now you need to create a tile set resource from this tile set. Navigate
the asset browser and click on <code>+</code> button near the search bar. Select <code>TileSet</code> resource and click <code>OK</code>. Find the resource
you've just created in the asset browser, double-click on it, and you should see something like this:</p>
<p><img src="tile_set_editor.png" alt="tile set editor" /></p>
<p>At this point you could add tiles individually, or import them all at once from a sprite sheet. Keep in mind, that unlike
other game engine, Fyrox allows you to specify not just textures, but materials for each tile. This is much more flexible
solution, since it allows you to have custom shaders for each tile. To sum everything up there are three ways of adding
tiles to the tile set:</p>
<ol>
<li>Import from a sprite sheet - this way the engine will create a unique embedded material (based on standard 2D shader),
that will use the sprite sheet as diffuse texture. Sprite sheet will be split into a number of tiles and each tile will
have its own portion (texture coordinates) of the sprite sheet.</li>
<li>Drag and drop a texture to the tile set - almost the same as the previous option, but the texture coordinates will
take the entire image.</li>
<li>Drag and drop a material to the tile set - the most flexible way, since it allows you to specify your own material for
tile.</li>
</ol>
<p>For simplicity, we'll use the sprite sheet. Click on <code>Import</code> button and drop the sprite sheet to the region with
checkerboard, set the appropriate number of rows and columns:</p>
<p><img src="import_tile_set.png" alt="import tile set" /></p>
<p>Now click <code>Import</code> and you should see something like this:</p>
<p><img src="imported_tile_set.png" alt="imported tile set" /></p>
<p>At this point you can select desired tiles and edit their properties in the inspector on the right side. As you can see
you can change tile's material, texture coordinates, collider (more on this below), color.</p>
<p>Now we have the tile set, and we can start creating a tile map using it. Click <code>Create -&gt; 2D -&gt; Tile Map</code> and you should
see something like this:</p>
<p><img src="empty_tile_map.png" alt="empty tile map" /></p>
<p>If you look closely, the editor warns us about missing tile set. Find the tile set you've just made and drag'n'drop it
from the asset browser to the <code>Tile Set</code> field in the inspector. There's one more step before we can start editing the
tile map - we need a brush to paint on the tile map. Click <code>+</code> button in the asset browser and select <code>TileMapBrush</code>,
set a name for it and click <code>OK</code>. Now select the tile map scene node and click on <code>+</code> sign in the <code>Brushes</code> field, drag'n'drop
the brush you've just created to the newly created property. Navigate to the <code>Tile Map Control Panel</code> and select the
brush from the dropdown list. For now the brush is empty, the simplest way to fill it is to just drag'n'drop the tile set
to it:</p>
<p><img src="brush.png" alt="brush" /></p>
<p>At this point everything is ready for painting, click <code>Edit</code> button on the <code>Tile Map Control Panel</code> and you should see the
grid:</p>
<p><img src="grid.png" alt="grid" /></p>
<p>Select some tiles on the palette and start drawing:</p>
<p><img src="drawing.png" alt="drawing" /></p>
<h2 id="drawing-tools"><a class="header" href="#drawing-tools">Drawing Tools</a></h2>
<p>There are number of tools (apart from the drawing itself) that could be useful while editing tile maps.</p>
<h3 id="erase"><a class="header" href="#erase">Erase</a></h3>
<p><img src="erase.gif" alt="erase" /></p>
<p>Erases tiles using the shape of the current brush, could be activated using <code>Shift</code> key or by clicking on the
button with eraser icon.</p>
<h3 id="flood-fill"><a class="header" href="#flood-fill">Flood fill</a></h3>
<p><img src="flood_fill.gif" alt="flood fill" /></p>
<p>Fills a region with the same tile kind (or empty space) using random tiles from the current brush. Could
be activated using the button with paint bucket icon.</p>
<h3 id="pick"><a class="header" href="#pick">Pick</a></h3>
<p><img src="pick.gif" alt="pick" /></p>
<p>Picks a rectangular region of tiles from the tile map itself and turns them into the current brush. Could be
activated using <code>Alt</code> key or by clicking the button with pipette icon.</p>
<h3 id="rectangular-fill"><a class="header" href="#rectangular-fill">Rectangular fill</a></h3>
<p><img src="rect_fill.gif" alt="rect fill" /></p>
<p>Fills a rectangular region with the tiles from the current brush. It tiles the given region using the
tiles from current brush. Could be activated using <code>Ctrl</code> key of by clicking on the button with the tiles icon.</p>
<h3 id="nine-slice"><a class="header" href="#nine-slice">Nine slice</a></h3>
<p><img src="nine_slice.gif" alt="nine slice" /></p>
<p>Fills a rectangular region using a 3x3 brush (the size limitation could be dropped in the future). The
corners of the brush will be placed at the corners of the selected region, the middle tiles between corners will be
duplicated from corner to corner. The center tile will be used to fill the rest of the rectangle.</p>
<h2 id="physics"><a class="header" href="#physics">Physics</a></h2>
<p>Tile maps supports physics for tiles, and it could be enabled by using special collider shape called <code>TileMap</code>. In code
it could be done something like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn add_tile_map_physics(tile_map: Handle&lt;Node&gt;, graph: &amp;mut Graph) {
    // Create a new collider with tile map shape.
    let collider = ColliderBuilder::new(BaseBuilder::new())
        .with_shape(ColliderShape::TileMap(TileMapShape {
            tile_map: GeometrySource(tile_map),
        }))
        .build(graph);

    // Create a static rigid body with the tile map collider.
    let rigid_body = RigidBodyBuilder::new(BaseBuilder::new().with_children(&amp;[collider]))
        .with_body_type(RigidBodyType::Static)
        .build(graph);
}
<span class="boring">}</span></code></pre></pre>
<p>In the editor it could be done by creating a static 2D rigid body with a 2D collider that has <code>TileMap</code> shape:</p>
<p><img src="tile_map_physics.png" alt="tile map physics" /></p>
<h2 id="layers"><a class="header" href="#layers">Layers</a></h2>
<p>Tile map does not support any layers on its own, but layers could be added very easy by simply creating another tile
map with its own tile set and shifting this new layer by Z axis towards camera on some small value.</p>
<h2 id="tile-properties"><a class="header" href="#tile-properties">Tile Properties</a></h2>
<p>Tile set could contain custom properties for each tile, these properties could be used to attach additional information
to the tiles in your game. This could include surface type (water, lava, dirt, etc.), physics properties (friction,
restitution, etc.) and any other you need. This is how it could be used in a game:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const SOIL: u8 = 1;
const SLIME: u8 = 2;

fn create_tile_map_with_props(graph: &amp;mut Graph) {
    let material = MaterialResource::new_ok(ResourceKind::Embedded, Material::standard_2d());

    let mut tile_set = TileSet::default();
    let stone_tile = tile_set.add_tile(TileDefinition {
        material: material.clone(),
        uv_rect: Rect::new(0.0, 0.0, 1.0, 1.0),
        collider: TileCollider::Rectangle,
        color: Color::BROWN,
        position: Default::default(),
        properties: vec![Property {
            name: "SurfaceType".to_string(),
            value: PropertyValue::U8(SOIL),
        }],
    });
    let slime_tile = tile_set.add_tile(TileDefinition {
        material,
        uv_rect: Rect::new(0.0, 0.0, 1.0, 1.0),
        collider: TileCollider::Rectangle,
        color: Color::GREEN,
        position: Default::default(),
        properties: vec![Property {
            name: "SurfaceType".to_string(),
            value: PropertyValue::U8(SLIME),
        }],
    });
    let tile_set = TileSetResource::new_ok(ResourceKind::Embedded, tile_set);

    // ..
}

fn calculate_speed_factor(tile_map: &amp;TileMap, player_position: Vector3&lt;f32&gt;) -&gt; f32 {
    let grid_position = tile_map.world_to_grid(player_position);

    if let Some(tile) = tile_map.tiles.get(&amp;grid_position) {
        if let Some(tile_set) = tile_map.tile_set() {
            if let Some(tile_set_data) = tile_set.data_ref().as_loaded_ref() {
                let tile_definition = &amp;tile_set_data.tiles[tile.definition_handle];

                if let Some(property) = tile_definition
                    .properties
                    .iter()
                    .find(|p| p.name == "SurfaceType")
                {
                    if let PropertyValue::U8(surface_type) = property.value {
                        return match surface_type {
                            SOIL =&gt; 1.0,
                            // Green slime tile slows down the player.
                            SLIME =&gt; 0.7,
                            _ =&gt; 1.0,
                        };
                    }
                }
            }
        }
    }

    1.0
}

<span class="boring">}</span></code></pre></pre>
<p>Here we have two types of tiles - soil and slime, soil does not have any effect on player's movement speed, while the
slime slows down the player by 30%. This code does not actually use any physical contact information and just uses tile
position, but it could be fixed pretty easily - supply physical contact position to it, and it will return correct results.</p>
<p>Tile custom properties could be edited in the tile set editor:</p>
<p><img src="tile_map_properties.PNG" alt="tile map properties" /></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../scene/rectangle.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../scene/custom_node.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../scene/rectangle.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../scene/custom_node.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="../ace.js"></script>
        <script src="../editor.js"></script>
        <script src="../mode-rust.js"></script>
        <script src="../theme-dawn.js"></script>
        <script src="../theme-tomorrow_night.js"></script>

        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
