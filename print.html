<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Fyrox Book</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> About the Book</a></li><li class="chapter-item expanded "><a href="fyrox/introduction/index.html"><strong aria-hidden="true">2.</strong> Introduction</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="fyrox/introduction/introduction.html"><strong aria-hidden="true">2.1.</strong> Introduction to Fyrox</a></li><li class="chapter-item expanded "><a href="fyrox/introduction/basic_concepts.html"><strong aria-hidden="true">2.2.</strong> Basic concepts</a></li><li class="chapter-item expanded "><a href="fyrox/introduction/philosophy_and_goals.html"><strong aria-hidden="true">2.3.</strong> Design Philosophy and Goals</a></li><li class="chapter-item expanded "><a href="fyrox/introduction/faq.html"><strong aria-hidden="true">2.4.</strong> Frequently Asked Questions</a></li></ol></li><li class="chapter-item expanded "><a href="fyrox/beginning/getting_started.html"><strong aria-hidden="true">3.</strong> Getting started</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="fyrox/beginning/scripting.html"><strong aria-hidden="true">3.1.</strong> Editor, Plugins and Scripts</a></li><li class="chapter-item expanded "><a href="fyrox/beginning/editor_overview.html"><strong aria-hidden="true">3.2.</strong> Editor Overview</a></li><li class="chapter-item expanded "><a href="fyrox/beginning/scene_and_scene_graph.html"><strong aria-hidden="true">3.3.</strong> Scene and scene graph</a></li><li class="chapter-item expanded "><a href="fyrox/beginning/assets.html"><strong aria-hidden="true">3.4.</strong> Assets</a></li><li class="chapter-item expanded "><a href="fyrox/beginning/data_management.html"><strong aria-hidden="true">3.5.</strong> Data management</a></li></ol></li><li class="chapter-item expanded "><a href="fyrox/scripting/scripting.html"><strong aria-hidden="true">4.</strong> Scripting</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="fyrox/scripting/plugin.html"><strong aria-hidden="true">4.1.</strong> Plugins</a></li><li class="chapter-item expanded "><a href="fyrox/scripting/executor.html"><strong aria-hidden="true">4.2.</strong> Executor</a></li><li class="chapter-item expanded "><a href="fyrox/scripting/script.html"><strong aria-hidden="true">4.3.</strong> Scripts</a></li></ol></li><li class="chapter-item expanded "><a href="fyrox/scene/scene.html"><strong aria-hidden="true">5.</strong> Scene</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="fyrox/scene/graph.html"><strong aria-hidden="true">5.1.</strong> Graph</a></li><li class="chapter-item expanded "><a href="fyrox/scene/transform.html"><strong aria-hidden="true">5.2.</strong> Transformation</a></li><li class="chapter-item expanded "><a href="fyrox/scene/prefab.html"><strong aria-hidden="true">5.3.</strong> Prefabs</a></li><li class="chapter-item expanded "><a href="fyrox/scene/inheritance.html"><strong aria-hidden="true">5.4.</strong> Property Inheritance</a></li><li class="chapter-item expanded "><a href="fyrox/scene/base_node.html"><strong aria-hidden="true">5.5.</strong> Base Node</a></li><li class="chapter-item expanded "><a href="fyrox/scene/mesh_node.html"><strong aria-hidden="true">5.6.</strong> Mesh Node</a></li><li class="chapter-item expanded "><a href="fyrox/scene/light_node.html"><strong aria-hidden="true">5.7.</strong> Light Node</a></li><li class="chapter-item expanded "><a href="fyrox/scene/sprite_node.html"><strong aria-hidden="true">5.8.</strong> Sprite Node</a></li><li class="chapter-item expanded "><a href="fyrox/scene/particle_system_node.html"><strong aria-hidden="true">5.9.</strong> Particle System Node</a></li><li class="chapter-item expanded "><a href="fyrox/scene/terrain_node.html"><strong aria-hidden="true">5.10.</strong> Terrain Node</a></li><li class="chapter-item expanded "><a href="fyrox/scene/camera_node.html"><strong aria-hidden="true">5.11.</strong> Camera Node</a></li><li class="chapter-item expanded "><a href="fyrox/scene/decal_node.html"><strong aria-hidden="true">5.12.</strong> Decal Node</a></li><li class="chapter-item expanded "><a href="fyrox/scene/rectangle.html"><strong aria-hidden="true">5.13.</strong> Rectangle Node</a></li><li class="chapter-item expanded "><a href="fyrox/scene/custom_node.html"><strong aria-hidden="true">5.14.</strong> Custom Node</a></li><li class="chapter-item expanded "><a href="fyrox/physics/physics.html"><strong aria-hidden="true">5.15.</strong> Physics</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="fyrox/physics/rigid_body.html"><strong aria-hidden="true">5.15.1.</strong> Rigid Body</a></li><li class="chapter-item expanded "><a href="fyrox/physics/collider.html"><strong aria-hidden="true">5.15.2.</strong> Collider</a></li><li class="chapter-item expanded "><a href="fyrox/physics/joint.html"><strong aria-hidden="true">5.15.3.</strong> Joint</a></li><li class="chapter-item expanded "><a href="fyrox/physics/ray.html"><strong aria-hidden="true">5.15.4.</strong> Ray Casting</a></li></ol></li><li class="chapter-item expanded "><a href="fyrox/sound/index.html"><strong aria-hidden="true">5.16.</strong> Sound</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="fyrox/sound/bus.html"><strong aria-hidden="true">5.16.1.</strong> Audio Bus</a></li><li class="chapter-item expanded "><a href="fyrox/sound/sound.html"><strong aria-hidden="true">5.16.2.</strong> Sound Node</a></li><li class="chapter-item expanded "><a href="fyrox/sound/hrtf.html"><strong aria-hidden="true">5.16.3.</strong> HRTF</a></li></ol></li><li class="chapter-item expanded "><a href="fyrox/animation/animation.html"><strong aria-hidden="true">5.17.</strong> Animation</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="fyrox/animation/anim_editor.html"><strong aria-hidden="true">5.17.1.</strong> Animation Editor</a></li><li class="chapter-item expanded "><a href="fyrox/animation/blending.html"><strong aria-hidden="true">5.17.2.</strong> Animation Blending</a></li><li class="chapter-item expanded "><a href="fyrox/animation/absm_editor.html"><strong aria-hidden="true">5.17.3.</strong> ABSM Editor</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="fyrox/ai/ai.html"><strong aria-hidden="true">6.</strong> Artificial Intelligence (WIP)</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="fyrox/ai/beh_tree.html"><strong aria-hidden="true">6.1.</strong> Behaviour Trees (WIP)</a></li><li class="chapter-item expanded "><a href="fyrox/ai/pathfinding.html"><strong aria-hidden="true">6.2.</strong> Path Finding</a></li><li class="chapter-item expanded "><a href="fyrox/ai/navmesh.html"><strong aria-hidden="true">6.3.</strong> Navigational Meshes</a></li></ol></li><li class="chapter-item expanded "><a href="fyrox/rendering/rendering.html"><strong aria-hidden="true">7.</strong> Rendering</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="fyrox/rendering/shaders.html"><strong aria-hidden="true">7.1.</strong> Shaders</a></li><li class="chapter-item expanded "><a href="fyrox/rendering/materials.html"><strong aria-hidden="true">7.2.</strong> Materials</a></li><li class="chapter-item expanded "><a href="fyrox/rendering/lightmaps.html"><strong aria-hidden="true">7.3.</strong> Light Maps (WIP)</a></li><li class="chapter-item expanded "><a href="fyrox/rendering/settings.html"><strong aria-hidden="true">7.4.</strong> Settings</a></li><li class="chapter-item expanded "><a href="fyrox/rendering/render_pass.html"><strong aria-hidden="true">7.5.</strong> Render Pass</a></li></ol></li><li class="chapter-item expanded "><a href="fyrox/resources/resources.html"><strong aria-hidden="true">8.</strong> Resource Management</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="fyrox/resources/model.html"><strong aria-hidden="true">8.1.</strong> Models</a></li><li class="chapter-item expanded "><a href="fyrox/resources/texture.html"><strong aria-hidden="true">8.2.</strong> Textures</a></li><li class="chapter-item expanded "><a href="fyrox/resources/sound.html"><strong aria-hidden="true">8.3.</strong> Sound Buffers (WIP)</a></li><li class="chapter-item expanded "><a href="fyrox/resources/curve.html"><strong aria-hidden="true">8.4.</strong> Curves (WIP)</a></li><li class="chapter-item expanded "><a href="fyrox/resources/custom.html"><strong aria-hidden="true">8.5.</strong> Custom Resource</a></li></ol></li><li class="chapter-item expanded "><a href="fyrox/ui/ui.html"><strong aria-hidden="true">9.</strong> User Interface</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="fyrox/ui/basic_concepts/basic_concepts.html"><strong aria-hidden="true">9.1.</strong> Basic concepts</a></li><li class="chapter-item expanded "><a href="fyrox/ui/general_rules.html"><strong aria-hidden="true">9.2.</strong> General rules</a></li><li class="chapter-item expanded "><a href="fyrox/ui/font.html"><strong aria-hidden="true">9.3.</strong> Fonts</a></li><li class="chapter-item expanded "><a href="fyrox/ui/theme.html"><strong aria-hidden="true">9.4.</strong> Theme</a></li><li class="chapter-item expanded "><a href="fyrox/ui/widgets.html"><strong aria-hidden="true">9.5.</strong> Widgets</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="fyrox/ui/button.html"><strong aria-hidden="true">9.5.1.</strong> Button</a></li><li class="chapter-item expanded "><a href="fyrox/ui/border.html"><strong aria-hidden="true">9.5.2.</strong> Border</a></li><li class="chapter-item expanded "><a href="fyrox/ui/canvas.html"><strong aria-hidden="true">9.5.3.</strong> Canvas</a></li><li class="chapter-item expanded "><a href="fyrox/ui/checkbox/check_box.html"><strong aria-hidden="true">9.5.4.</strong> Check box</a></li><li class="chapter-item expanded "><a href="fyrox/ui/curve_editor.html"><strong aria-hidden="true">9.5.5.</strong> Curve editor (WIP)</a></li><li class="chapter-item expanded "><a href="fyrox/ui/decorator.html"><strong aria-hidden="true">9.5.6.</strong> Decorator (WIP)</a></li><li class="chapter-item expanded "><a href="fyrox/ui/dock.html"><strong aria-hidden="true">9.5.7.</strong> Docking manager (WIP)</a></li><li class="chapter-item expanded "><a href="fyrox/ui/dropdown_list.html"><strong aria-hidden="true">9.5.8.</strong> Dropdown list (WIP)</a></li><li class="chapter-item expanded "><a href="fyrox/ui/expander.html"><strong aria-hidden="true">9.5.9.</strong> Expander (WIP)</a></li><li class="chapter-item expanded "><a href="fyrox/ui/file_browser.html"><strong aria-hidden="true">9.5.10.</strong> File browser (WIP)</a></li><li class="chapter-item expanded "><a href="fyrox/ui/grid.html"><strong aria-hidden="true">9.5.11.</strong> Grid</a></li><li class="chapter-item expanded "><a href="fyrox/ui/image.html"><strong aria-hidden="true">9.5.12.</strong> Image</a></li><li class="chapter-item expanded "><a href="fyrox/ui/inspector.html"><strong aria-hidden="true">9.5.13.</strong> Inspector (WIP)</a></li><li class="chapter-item expanded "><a href="fyrox/ui/list_view.html"><strong aria-hidden="true">9.5.14.</strong> List view (WIP)</a></li><li class="chapter-item expanded "><a href="fyrox/ui/menu.html"><strong aria-hidden="true">9.5.15.</strong> Menu (WIP)</a></li><li class="chapter-item expanded "><a href="fyrox/ui/message_box.html"><strong aria-hidden="true">9.5.16.</strong> Message box (WIP)</a></li><li class="chapter-item expanded "><a href="fyrox/ui/numeric.html"><strong aria-hidden="true">9.5.17.</strong> Numeric field</a></li><li class="chapter-item expanded "><a href="fyrox/ui/popup.html"><strong aria-hidden="true">9.5.18.</strong> Popup (WIP)</a></li><li class="chapter-item expanded "><a href="fyrox/ui/progress_bar.html"><strong aria-hidden="true">9.5.19.</strong> Progress bar (WIP)</a></li><li class="chapter-item expanded "><a href="fyrox/ui/range.html"><strong aria-hidden="true">9.5.20.</strong> Range (WIP)</a></li><li class="chapter-item expanded "><a href="fyrox/ui/rect.html"><strong aria-hidden="true">9.5.21.</strong> Rect (WIP)</a></li><li class="chapter-item expanded "><a href="fyrox/ui/scroll_bar.html"><strong aria-hidden="true">9.5.22.</strong> Scroll bar (WIP)</a></li><li class="chapter-item expanded "><a href="fyrox/ui/scroll_panel.html"><strong aria-hidden="true">9.5.23.</strong> Scroll panel (WIP)</a></li><li class="chapter-item expanded "><a href="fyrox/ui/scroll_viewer.html"><strong aria-hidden="true">9.5.24.</strong> Scroll viewer (WIP)</a></li><li class="chapter-item expanded "><a href="fyrox/ui/stack_panel.html"><strong aria-hidden="true">9.5.25.</strong> Stack panel</a></li><li class="chapter-item expanded "><a href="fyrox/ui/tab_control.html"><strong aria-hidden="true">9.5.26.</strong> Tab Control</a></li><li class="chapter-item expanded "><a href="fyrox/ui/text.html"><strong aria-hidden="true">9.5.27.</strong> Text</a></li><li class="chapter-item expanded "><a href="fyrox/ui/text_box.html"><strong aria-hidden="true">9.5.28.</strong> Text box</a></li><li class="chapter-item expanded "><a href="fyrox/ui/tree.html"><strong aria-hidden="true">9.5.29.</strong> Tree (WIP)</a></li><li class="chapter-item expanded "><a href="fyrox/ui/vector_image.html"><strong aria-hidden="true">9.5.30.</strong> Vector image (WIP)</a></li><li class="chapter-item expanded "><a href="fyrox/ui/window.html"><strong aria-hidden="true">9.5.31.</strong> Window</a></li><li class="chapter-item expanded "><a href="fyrox/ui/wrap_panel.html"><strong aria-hidden="true">9.5.32.</strong> Wrap panel</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="fyrox/serialization/index.html"><strong aria-hidden="true">10.</strong> Serialization</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="fyrox/serialization/save.html"><strong aria-hidden="true">10.1.</strong> Saved Games (WIP)</a></li></ol></li><li class="chapter-item expanded "><a href="fyrox/editor/index.html"><strong aria-hidden="true">11.</strong> Editor</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="fyrox/editor/settings.html"><strong aria-hidden="true">11.1.</strong> Settings</a></li></ol></li><li class="chapter-item expanded "><a href="fyrox/misc/misc.html"><strong aria-hidden="true">12.</strong> Miscellaneous</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="fyrox/misc/log.html"><strong aria-hidden="true">12.1.</strong> Log</a></li></ol></li><li class="chapter-item expanded "><a href="fyrox/tutorials/tutorials.html"><strong aria-hidden="true">13.</strong> Tutorials</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="fyrox/tutorials/fps/intro.html"><strong aria-hidden="true">13.1.</strong> FPS Tutorial</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="fyrox/tutorials/fps/tutorial-1/tutorial-part-1.html"><strong aria-hidden="true">13.1.1.</strong> Character controller</a></li><li class="chapter-item expanded "><a href="fyrox/tutorials/fps/tutorial-2/tutorial-part-2.html"><strong aria-hidden="true">13.1.2.</strong> Weapons</a></li><li class="chapter-item expanded "><a href="fyrox/tutorials/fps/tutorial-3/tutorial-part-3.html"><strong aria-hidden="true">13.1.3.</strong> Bots and AI</a></li></ol></li><li class="chapter-item expanded "><a href="fyrox/tutorials/rpg/intro.html"><strong aria-hidden="true">13.2.</strong> RPG Tutorial</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="fyrox/tutorials/rpg/tutorial-1/tutorial-part-1.html"><strong aria-hidden="true">13.2.1.</strong> Character controller</a></li></ol></li><li class="chapter-item expanded "><a href="fyrox/tutorials/platformer/part1.html"><strong aria-hidden="true">13.3.</strong> 2D Platformer tutorial</a></li></ol></li><li class="chapter-item expanded "><a href="fyrox/performance/index.html"><strong aria-hidden="true">14.</strong> Performance</a></li><li class="chapter-item expanded "><a href="fyrox/obsolete/obsolete.html"><strong aria-hidden="true">15.</strong> Obsolete</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="fyrox/obsolete/installation.html"><strong aria-hidden="true">15.1.</strong> Installation (Obsolete)</a></li><li class="chapter-item expanded "><a href="fyrox/obsolete/custom_game_loop.html"><strong aria-hidden="true">15.2.</strong> Custom game loop (Obsolete)</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Fyrox Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/fyrox-book/fyrox-book.github.io" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="fyrox-game-engine-book"><a class="header" href="#fyrox-game-engine-book">Fyrox Game Engine Book</a></h1>
<p>Practical reference and user guides for <a href="https://github.com/FyroxEngine/Fyrox">Fyrox Game Engine</a> and its 
editor <a href="https://github.com/FyroxEngine/Fyrox/tree/master/editor">FyroxEd</a>.</p>
<p><strong>Warning:</strong> The book is in early development stage, you can help to improve it by making a contribution in its
<a href="https://github.com/fyrox-book/fyrox-book.github.io">repository</a>. Don't be shy, every tip is helpful!</p>
<h2 id="engine-version"><a class="header" href="#engine-version">Engine Version</a></h2>
<p>Fyrox Team is trying to keep the book up-to-date with the latest version from <code>master</code> branch. If something does not 
compile with the latest release from crates.io, then you need to 
<a href="./fyrox/beginning/scripting.html#using-latest-engine-version">use the latest engine from GitHub repo</a>.</p>
<h2 id="how-to-read-the-book"><a class="header" href="#how-to-read-the-book">How to read the book</a></h2>
<p>Almost every chapter in this book can be read in any order, but we recommend reading Chapters 1, 2, 3 (they're quite small)
and then going through <a href="fyrox/tutorials/platformer/part1.html">Platformer Tutorial (2D)</a> while learning more about specific 
areas that interest you from the other chapters. </p>
<p>There is also a <a href="fyrox/tutorials/fps/intro.html">First-Person Shooter Tutorial (3D)</a>, but it is based on framework which
considered obsolete, yet it is still very helpful. </p>
<h2 id="api-documentation"><a class="header" href="#api-documentation">API Documentation</a></h2>
<p>The book is primarily focused on game development with Fyrox, not on its API. You can find API docs
<a href="https://docs.rs/fyrox/latest/fyrox/">here</a>.</p>
<h2 id="required-knowledge"><a class="header" href="#required-knowledge">Required knowledge</a></h2>
<p>We're expecting that you know basics of Rust programming language, its package manager Cargo. It is also necessary
to know the <em>basics</em> of the game development, linear algebra, principles of software development and patterns, 
otherwise the book will probably be very hard for you. </p>
<h2 id="support-the-development"><a class="header" href="#support-the-development">Support the development</a></h2>
<p>The future of the project fully depends on community support, every bit is important!</p>
<p><a href="https://www.patreon.com/mrdimas"><img src="https://c5.patreon.com/external/logo/become_a_patron_button.png" alt="Become a patron!" /></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>This section of the book contains brief overview of engine's features, it should help you to decide if the engine suits
your needs and will it be easy enough for you to use. Following chapters takes you into a tour over engine's features,
its editor, basic concepts and design philosophy.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction-to-fyrox"><a class="header" href="#introduction-to-fyrox">Introduction to Fyrox</a></h1>
<p>Fyrox is a feature-rich, general purpose game engine that is suitable for any kind of games. It is capable to power
games with small- or medium-sized worlds, large-sized world most likely will require some manual work. </p>
<p>Games made with the engine are capable to run on desktop platforms (PC, Mac, Linux) and Web (WebAssembly). Mobile is
planned for future releases.</p>
<h2 id="what-can-the-engine-do"><a class="header" href="#what-can-the-engine-do">What can the engine do?</a></h2>
<p>You can create pretty much any kind of game or interactive applications. Here's some examples of what the engine can 
do:</p>
<p><img src="fyrox/introduction/game_example1.jpg" alt="Station Iapetus" />
<img src="fyrox/introduction/game_example2.jpg" alt="Fish Folly" />
<img src="fyrox/introduction/game_example3.jpg" alt="2D Platformer" /></p>
<h2 id="how-the-engine-work"><a class="header" href="#how-the-engine-work">How the engine work?</a></h2>
<p>The engine consists of two parts that you'll be actively using: the framework and the editor. The framework is a 
foundation of the engine, it manages rendering, sound, scripts, plugins, etc. While the editor contains lots of tools 
that can be used to create game worlds, manage assets, edit game objects, scripts and more.</p>
<p><img src="fyrox/introduction/editor.png" alt="Fish Folly" /></p>
<h2 id="programming-languages"><a class="header" href="#programming-languages">Programming languages</a></h2>
<p>Everything of your game can be written entirely in Rust, utilizing its safety guarantees as well as speed. However, it
is possible to use any scripting language you want, but that's have no built-in support and you need to implement this
manually.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basic-concepts"><a class="header" href="#basic-concepts">Basic concepts</a></h1>
<p>Let's briefly get over some basic concepts of the engine, there's not much, but all of them are crucial to understand
design decisions made in the engine.</p>
<h2 id="classic-oop"><a class="header" href="#classic-oop">Classic OOP</a></h2>
<p>The engine uses somewhat classic OOP with composition over inheritance - complex objects in the engine can be constructed
using simpler objects.</p>
<h2 id="scenes"><a class="header" href="#scenes">Scenes</a></h2>
<p>In Fyrox, you break down your game in a set of reusable scenes. Pretty much anything can be a scene: a player, a weapon,
a bot, level parts, etc. Scenes can be nested one into another, this helps you to break down complex scenes into reusable
parts. Scene in Fyrox is also plays a role of prefab, there's pretty much no difference between them.</p>
<h2 id="nodes-and-scene-graph"><a class="header" href="#nodes-and-scene-graph">Nodes and Scene Graph</a></h2>
<p>A scene is made of one or more nodes (every scene must have at least one root node, to which everything else is attached).
Scene node contains specific set of properties as well as <em>one</em> optional script instance which is responsible for custom
game logic. </p>
<p>Typical structure of a scene node could be represented by the following example. The base object for every scene node is 
a <code>Base</code> node, it contains a transform, a list of children, etc. A more complex node, that <em>extends</em> functionality of the <code>Base</code> 
node stores an instance of <code>Base</code> inside of them. For example, a <code>Mesh</code> node is a <code>Base</code> node <em>plus</em> some specific info 
(a list of surfaces, material, etc.). The &quot;hierarchy&quot; depth is unlimited - a <code>Light</code> node in the engine is an enumeration 
of three possible types of light source. <code>Directional</code>, <code>Point</code>, and <code>Spot</code> light sources both use <code>BaseLight</code> node,
which in its turn contains <code>Base</code> node inside. Graphically it can be represented like so:</p>
<pre><code class="language-text">`Point`
|__ Point Light Properties (radius, etc.)
|__`BaseLight`
   |__ Base Light Properties (color, etc.)
   |__`Base`
      |__ Base Node Properties (transform, children nodes, etc.)
</code></pre>
<p>As you can see, this forms the nice tree (graph) that shows what the object contains. This is very natural way of describing
scene nodes, it gives you the full power of building an object of any complexity.</p>
<h2 id="plugins"><a class="header" href="#plugins">Plugins</a></h2>
<p>Plugin is a container for &quot;global&quot; game data and logic, its main usage is to provide scripts with some data and to 
manage global game state.</p>
<h2 id="scripts"><a class="header" href="#scripts">Scripts</a></h2>
<p>Script - is a separate piece of data and logic, that can be attached to scene nodes. This is primary (but not single)
way of adding custom game logic.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="design-philosophy-and-goals"><a class="header" href="#design-philosophy-and-goals">Design Philosophy and Goals</a></h1>
<p>Let's talk a bit about design philosophy and goals of the engine. Development of the engine started in the beginning
of 2019 as a hobby project to learn Rust, and it quickly showed that Rust can be a game changer in the game development
industry. Initially, the engine was just a port of <a href="https://github.com/mrDIMAS/DmitrysEngine">an engine</a> that is written 
in C. At the beginning, it was very interesting to build such complex thing as game engine in such low level language without
any safety guarantees. After a year of development it became annoying to fix memory related issues (memory corruption,
leaks, etc.), luckily at that time Rust's popularity grew, and it showed on my radar. I (<a href="https://github.com/mrDIMAS">@mrDIMAS</a>) 
was able to port the engine to it in less than a year. Stability has improved dramatically, no more random crashes, 
performance was at the same or better levels - time invested in learning new language was paid off. Development speed 
does not degrade over time as it was in C, it is very easy to manage growing project.</p>
<h2 id="safety"><a class="header" href="#safety">Safety</a></h2>
<p>One of the main goals of in the development of the engine is to provide high level of safety. What does this mean? 
In short: protect from memory-unsafety bugs. This does not include any logic errors, but when your game is free 
of random crashes due to memory unsafety it is much easier to fix logic bugs, because you don't have to think about
potentially corrupted memory.</p>
<p>Safety is also dictates architecture design decisions of your game, typical callback hell, that is possible to do in
many other languages, is very tedious to implement in Rust. It is possible, but it requires quite a lot of manual work
and quickly tell you that you're doing it wrong.</p>
<h2 id="performance"><a class="header" href="#performance">Performance</a></h2>
<p>Game engines usually built using system-level programming languages, that provides peak performance levels. Fyrox is not
an exception. One if its design goals is to provide high levels of performance by default, leaving an opportunity for
adding custom solutions for performance-critical places.</p>
<h2 id="ease-of-use"><a class="header" href="#ease-of-use">Ease of use</a></h2>
<p>Other very important part is that the engine should be friendly to newcomers. It should lower entry threshold, not make
it worse. Fyrox uses well known and battle-tested concepts, thus making it easier to make games with it. On other hand,
it still can be extended with anything you need - it tries to be as good for veterans of the game industry as for 
newcomers.</p>
<h2 id="battle-tested"><a class="header" href="#battle-tested">Battle-tested</a></h2>
<p>Fyrox has large projects built on it, that helps to understand real needs for general-purpose game engine. This helps
in revealing weak spots in design and fix them.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="frequently-asked-questions"><a class="header" href="#frequently-asked-questions">Frequently Asked Questions</a></h1>
<p>This chapter contains answers for frequently asked questions.</p>
<h2 id="which-graphics-api-the-engine-uses"><a class="header" href="#which-graphics-api-the-engine-uses">Which graphics API the engine uses?</a></h2>
<p>Fyrox uses quite old OpenGL 3.3 on PC and OpenGL ES 3.0 on WebAssembly. Why? Mainly due to historical reasons, back in 
the day (Q4 of 2018), there wasn't any good alternatives to it with wide amount of supported platforms. For example <code>wgpu</code>
<a href="https://crates.io/crates/wgpu/0.1.0">wasn't even exist</a>, since its first version was released in January 2019. Other
crates did their first baby steps and weren't ready for production.</p>
<p>Why not use alternatives now? There's no need for this, the engine has <strong>a lot</strong> of stuff that needs to be implemented,
and graphics is not a top-priority task.</p>
<h2 id="does-the-engine-based-on-ecs"><a class="header" href="#does-the-engine-based-on-ecs">Does the engine based on ECS?</a></h2>
<p>No, the engine uses mixed composition-based, object-oriented design with message passing and other different approaches
that fits the most for a particular task. Why not ECS for everything, though? Pragmatism. Use a right tool for the job,
don't use a microscope to hammer nails.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<p>This section of the book will guide you through the basics of the engine. You will learn how to create a project, use
plugins, scripts, assets, and the editor. Fyrox is a modern game engine with its own scene editor, that helps you to edit 
game worlds, manage assets, and many more. At the end of reading this section, you'll also learn how to manage game and 
engine entities, how they're structured and what are the basics of data management in the engine. </p>
<p>Next chapter will guide you through major setup of the engine - creating a game project using special project generator
tool.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="editor-plugins-and-scripts"><a class="header" href="#editor-plugins-and-scripts">Editor, Plugins and Scripts</a></h1>
<p>Every Fyrox game is just a plugin for both the engine and the editor, such approach allows you to run your game from the 
editor and to be able to edit the game entities in it. Your game can define any number of scripts, which can be assigned 
to scene objects to run custom game logic on them. In this chapter you'll learn the basics: how to install the engine with
its platform-specific dependencies, how to use the plugins and scripting system, how to run the editor.</p>
<h2 id="platform-specific-dependencies"><a class="header" href="#platform-specific-dependencies">Platform-specific Dependencies</a></h2>
<p>Before you start using the engine, make sure you have all required platform-specific development dependencies installed,
otherwise you'll get compilation errors. If you're on Windows or macOS, you don't need to install anything specific - 
all you need to have is the latest Rust installed with appropriate toolchain for your platform.</p>
<h3 id="linux"><a class="header" href="#linux">Linux</a></h3>
<p>On Linux Fyrox needs the development files for the following libraries: <code>libxcb-shape0</code>, <code>libxcb-xfixes0</code>, <code>libxcb1</code>, 
<code>libxkbcommon</code>, <code>libasound2</code>.</p>
<p>For Debian based distros like Ubuntu, they can be installed like below:</p>
<pre><code class="language-shell">sudo apt install libxcb-shape0-dev libxcb-xfixes0-dev libxcb1-dev libxkbcommon-dev libasound2-dev
</code></pre>
<h2 id="project-generator"><a class="header" href="#project-generator">Project Generator</a></h2>
<p>Fyrox plugins are static, this means that you must re-compile your game or editor if the source code of your game changes,
such architecture requires some boilerplate code for any game. Fyrox offers a special tiny tool - 
<code>fyrox-template</code> - that helps you generate all this boilerplate with a single command. Install it by running the following 
command:</p>
<pre><code class="language-shell">cargo install fyrox-template
</code></pre>
<p><em>Note for Linux:</em> This installs it in <code>$user/.cargo/bin</code>. If you get errors about the <code>fyrox-template</code> command not found 
then you need to add this folder to your <code>$PATH</code> still.</p>
<p>Navigate to the folder where you want the project to be created and run the following command:</p>
<pre><code class="language-shell">fyrox-template init --name my_game --style 3d
</code></pre>
<p>Note that unlike <code>cargo init</code>, this will create a new folder with the given name.</p>
<p>The tool accepts two arguments - a project name (<code>--name</code>) and a style (<code>--style</code>), which defines the contents of the default
scene. Once you initialize your project, go to <code>game/src/lib.rs</code> - this is where your game logic is located, as you can 
see, the <code>fyrox-template</code> generated quite a bit of code for you. There are comments explaining what each place is for. For 
more info about each method, please refer <a href="https://docs.rs/fyrox/latest/fyrox/plugin/trait.Plugin.html">to the docs</a>.</p>
<p>Once the project is generated, you should memorize the two commands that will help you to run your game in different modes:</p>
<ul>
<li><code>cargo run --package editor --release</code> - launches the editor with your game attached. The editor allows you to run your game
from it and edit its game entities. It is intended to be used only for development.</li>
<li><code>cargo run --package executor --release</code> - creates and runs the production binary of your game, which can be shipped (for
example - to a store).</li>
</ul>
<p>Navigate to your project's directory and run <code>cargo run --package editor --release</code>, after some time you should see the 
editor:</p>
<p><img src="fyrox/beginning/editor.png" alt="editor" /></p>
<p>In the editor you can start building your game scene. <strong>Important note:</strong> your scene must have at least one camera,
otherwise you won't see a thing. Read the next chapter to learn how to use the editor.</p>
<h2 id="using-the-latest-engine-version"><a class="header" href="#using-the-latest-engine-version">Using the Latest Engine Version</a></h2>
<p>Due to the nature of the software development, some bugs will inevitably sneak into the major releases, due to this, 
you may want to use the latest engine version from the repository on GitHub, since it is the most likely to have bugs fixed
(you can also contribute by fixing any bugs you find or at least, by <a href="https://github.com/FyroxEngine/Fyrox/issues">filing an issue</a>).</p>
<blockquote>
<p>⚠️ Latest <code>fyrox-template</code> from the engine's repo has special sub-command - <code>upgrade</code> to quickly upgrade to desired engine
version. To upgrade to the latest version (&quot;nightly&quot;) you should execute <code>fyrox-template upgrade --version nightly</code> 
command in your game's directory.</p>
</blockquote>
<p>The first step you need to take is to install the latest <code>fyrox-template</code>, this can be done with a single <code>cargo</code> command:</p>
<pre><code class="language-shell">cargo install fyrox-template --force --git https://github.com/FyroxEngine/Fyrox
</code></pre>
<p>This will ensure you're using the latest project/script template generator, which is important, since old versions
of the template generator will most likely generate outdated code, no longer be compatible with the engine.</p>
<p>To switch existing projects to the latest version of the engine, you need to specify paths pointing to the remote repository 
for the <code>fyrox</code> and <code>fyroxed_base</code> dependencies. You need to do this in the <code>game</code>, <code>executor</code>, and <code>editor</code> projects. First,
open <code>game/Cargo.toml</code> and change the <code>fyrox</code> dependency to the following:</p>
<pre><code class="language-toml">[dependencies]
fyrox = { git = &quot;https://github.com/FyroxEngine/Fyrox&quot; }
</code></pre>
<p>Do the same for <code>executor/Cargo.toml</code>. The <code>editor</code> has two dependencies we need to change: <code>fyrox</code> and <code>fyroxed_base</code>.
Open the <code>editor/Cargo.toml</code> and set both dependencies to the following:</p>
<pre><code class="language-toml">[dependencies]
fyrox = { git = &quot;https://github.com/FyroxEngine/Fyrox&quot; }
fyroxed_base = { git = &quot;https://github.com/FyroxEngine/Fyrox&quot; }
</code></pre>
<p>Now your game will use the latest engine and editor, but beware - new commits could bring some API breaks. You can avoid these by 
specifying a particular commit, just add <code>rev = &quot;desired_commit_hash&quot;</code> to every dependency like so:</p>
<pre><code class="language-toml">[dependencies]
fyrox = { git = &quot;https://github.com/FyroxEngine/Fyrox&quot;, rev = &quot;0195666b30562c1961a9808be38b5e5715da43af&quot; }
fyroxed_base = { git = &quot;https://github.com/FyroxEngine/Fyrox&quot;, rev = &quot;0195666b30562c1961a9808be38b5e5715da43af&quot; }
</code></pre>
<p>To bring a local git repository of the engine to being up-to-date, just call <code>cargo update</code> at the root of the project's
workspace. This will pull the latest changes from the remote, unless there is no <code>rev</code> specified.</p>
<p>Learn more about dependency paths on the official <code>cargo</code> documentation, 
<a href="https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#specifying-dependencies-from-git-repositories">here</a>.</p>
<h2 id="adding-game-logic"><a class="header" href="#adding-game-logic">Adding Game Logic</a></h2>
<p>Any object-specific game logic should be added using scripts. A script is a &quot;container&quot; for data and code, that will be
executed by the engine. Read the <a href="fyrox/beginning/../scripting/script.html">Scripts</a> chapter to learn how to create, edit, and use scripts in
your game.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fyroxed-overview"><a class="header" href="#fyroxed-overview">FyroxEd Overview</a></h1>
<p>FyroxEd - is the native editor of Fyrox, it is made with one purpose - to be an integrated game development environment
that helps you build your game from start to finish with relatively low effort.</p>
<p>You'll be spending a lot of time in the editor, so you should get familiar with it and learn how to use its basic functionalities.
This chapter will guide you through the basics, advanced topics will be covered in their respective chapters.</p>
<h2 id="windows"><a class="header" href="#windows">Windows</a></h2>
<p>When you open the editor for the first time you may be confused by the amount of windows, buttons, lists, etc. you'll be presented 
with. Each window serves a different purpose, but all of them work together to help you make your game. Let's take a look at a 
screenshot of the editor and learn what each part of it is responsible for (please note that this can change over time, because
development is quite fast and images can easily become outdated):</p>
<p><img src="fyrox/beginning/./overview.png" alt="Windows" /></p>
<ul>
<li><strong>World viewer</strong> - shows every object in the scene and their relationships. Allows inspecting and editing the 
contents of the scene in a hierarchical form.</li>
<li><strong>Scene preview</strong> - renders the scene with debug info and various editor-specific objects (gizmos, entity icons,
etc.). Allows you to select, move, rotate, scale, delete, etc. various entities. The <strong>Toolbar</strong> on its left side
shows available context-dependent tools.</li>
<li><strong>Inspector</strong> - allows you to modify various properties of the selected object.</li>
<li><strong>Message Log</strong> - displays important messages from the editor.</li>
<li><strong>Navmesh Panel</strong> - allows you to create, delete, and edit navigational meshes.</li>
<li><strong>Command Stack</strong> - displays your most recent actions and allows you to undo or redo their changes.</li>
<li><strong>Asset Browser</strong> - allows you to inspect the assets of your game and to instantiate resources in the scene, among other things.</li>
<li><strong>Audio Context</strong> - allows you to edit the settings of the scene's sound context (global volume, available audio buses, effects,
etc.)</li>
</ul>
<h2 id="creating-or-loading-a-scene"><a class="header" href="#creating-or-loading-a-scene">Creating or loading a Scene</a></h2>
<p>FyroxEd works with scenes - a scene is a container for game entities, you can create and edit one scene at a time. You must have a
scene loaded to begin working with the editor. To create a scene go to <code>File -&gt; New Scene</code>.</p>
<p>To load an existing scene, go to <code>File -&gt; Load</code> and select the desired scene through the file browser. Recently opened
scenes can be loaded more quickly by going to <code>File -&gt; Recent Scenes</code> and selecting the desired one.</p>
<h2 id="populating-a-scene"><a class="header" href="#populating-a-scene">Populating a Scene</a></h2>
<p>A scene can contain various game entities. There are two equivalent ways of creating these:</p>
<ul>
<li>By going to <code>Create</code> in the main menu and selecting the desired entity from the drop down.</li>
<li>By right-clicking on a game entity in the <code>World Viewer</code> and selecting the desired entity from the <code>Add Child</code> sub-menu.</li>
</ul>
<p>Complex objects usually made in 3D modelling software (Blender, 3Ds Max, Maya, etc.) can be saved in various formats. Fyrox supports
FBX format, which is supported by pretty much any 3D modelling software. You can instantiate such objects by simply dragging the one you want and dropping it on the <code>Scene Preview</code>. While dragging it, you'll also see a preview of the object.</p>
<p>You can do the same with other scenes made in the editor (<code>rgs</code> files), for example, you can create a scene with a few objects in it
with some scripts and re-use them within other scenes. Such scenes are called <a href="fyrox/beginning/../scene/prefab.html">prefabs</a>.</p>
<h2 id="saving-a-scene"><a class="header" href="#saving-a-scene">Saving a Scene</a></h2>
<p>To save your work, go to <code>File -&gt; Save</code>. If you're saving a new scene, the editor will ask you to specify a file name and a
path to where the scene will be saved. Scenes loaded from a file will automatically be saved to the path they were loaded
from.</p>
<h2 id="undoing-and-redoing"><a class="header" href="#undoing-and-redoing">Undoing and redoing</a></h2>
<p>FyroxEd remembers your actions and allows you to undo and redo the changes done by these. You can undo or redo changes by either
going to <code>Edit -&gt; Undo/Redo</code> or through the usual shortcuts: <code>Ctrl+Z</code> - to undo, <code>Ctrl+Y</code> - to redo.</p>
<h2 id="controls"><a class="header" href="#controls">Controls</a></h2>
<p>There are number of control keys that you'll be using most of the time, pretty much all of them work in the <code>Scene Preview</code> window:</p>
<h3 id="editor-camera-movement"><a class="header" href="#editor-camera-movement">Editor camera movement</a></h3>
<p>Click and hold <code>[Right Mouse Button]</code> within the <code>Scene Preview</code> window to enable the movement controls:</p>
<ul>
<li><code>[W][S][A][D]</code> - Move camera forward/backward/left/right</li>
<li><code>[Space][Q]/[E]</code> - Raise/Lower Camera</li>
<li><code>[Ctrl]</code> - Speed up</li>
<li><code>[Shift]</code>- Slowdown</li>
</ul>
<h3 id="others"><a class="header" href="#others">Others</a></h3>
<ul>
<li><code>[Left Mouse Button]</code> - Select</li>
<li><code>[Middle Mouse Button]</code> - Pan camera in viewing plane</li>
<li><code>[1]</code> - Select interaction mode</li>
<li><code>[2]</code> - Move interaction mode</li>
<li><code>[3]</code> - Scale interaction mode</li>
<li><code>[4]</code> - Rotate interaction mode</li>
<li><code>[5]</code> - Navigational mesh editing mode</li>
<li><code>[6]</code> - Terrain editing interaction mode</li>
<li><code>[Ctrl]+[Z]</code> - Undo</li>
<li><code>[Ctrl]+[Y]</code> - Redo</li>
<li><code>[Delete]</code> - Delete current selection.</li>
</ul>
<h2 id="play-mode"><a class="header" href="#play-mode">Play Mode</a></h2>
<p>One of the key features of the editor is that it allows you to run your game from it in a separate process. Use the <code>Play/Stop</code>
button at the top of the <code>Scene Preview</code> window to enter or leave Play Mode. Keep in mind, that the editor UI will be locked while
you're in Play Mode. </p>
<p>Play Mode can be activated only for projects made with the <code>fyrox-template</code> (or for projects with a similar structure). The editor
calls <code>cargo</code> commands to build and run your game in a separate process. Running the game in a separate process ensures
that the editor won't crash if your game does, it also provides excellent isolation between the game and the editor, not
giving a chance to break the editor by running the game.</p>
<h2 id="additional-utilities"><a class="header" href="#additional-utilities">Additional Utilities</a></h2>
<p>There are also number of powerful utilities that will make your life easier, they can be found under the <code>Utils</code> section of the
main menu:</p>
<ul>
<li>Animation Editor - allows you to create and edit animation blending state machines which are responsible for 
animation mixing.</li>
<li>Curve Editor - allows you to create and edit curve resources to make complex laws for game parameters.</li>
<li>Path Fixer - helps you fix incorrect resource references in your scenes.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scene-and-scene-graph"><a class="header" href="#scene-and-scene-graph">Scene and Scene Graph</a></h1>
<p>When you're playing a game, you often see various objects scattered around the screen, all of them are forming a
<em>scene</em>. A scene is just a set of a variety objects, as in many other game engines, Fyrox allows you to create multiple
scenes for multiple purposes, for example, one scene could be used for a menu, a bunch of others for game levels,
and another one for an ending screen. Scenes can also be used to create a source of data for other scenes, such scenes are called
<em>prefabs</em>. Scenes can also be rendered in a texture, which can be used in other scenes - this way you
can create interactive screens that show other places.</p>
<p>While playing games, you may have noticed that some objects behaves as if they were linked to other objects, for example,
a character in a role-playing game could carry a sword. While the character holds the sword, it is linked to his
arm. Such relations between the objects can be presented by a graph structure.</p>
<p>Simply speaking, a graph is a set of objects with hierarchical relationships between each object. Each object in the
graph is called a <em>node</em>. In the example with the sword and the character, the sword is a <em>child</em> node of the character,
and the character is a <em>parent</em> node of the sword (here we ignore the fact that in reality, character
models usually contain complex skeletons, with the sword actually being attached to one of the hands' bones, not to the character).</p>
<p>You can change the hierarchy of nodes in the editor using a simple drag'n'drop functionality in the <code>World Viewer</code> - drag a 
node onto some other node, and it will attach itself to it.</p>
<h2 id="building-blocks-or-scene-nodes"><a class="header" href="#building-blocks-or-scene-nodes">Building Blocks or Scene Nodes</a></h2>
<p>The engine offers various types of &quot;building blocks&quot; for your scene, each such block is called a <em>scene node</em>.</p>
<ul>
<li><a href="fyrox/beginning/../scene/base_node.html">Base</a> - stores hierarchical information (a handle to the parent node and handles
to children nodes), local and global transform, name, tag, lifetime, etc. It has self-describing name - it's used as a base node 
for every other scene node via composition.</li>
<li><a href="fyrox/beginning/../scene/mesh_node.html">Mesh</a> - represents a 3D model. This one of the most commonly used nodes in almost every game.
Meshes can be easily created either programmatically, or be made in some 3D modelling software, such as Blender, 
and then loaded into the scene.</li>
<li><a href="fyrox/beginning/../scene/light_node.html">Light</a> - represents a light source. There are three types of light sources:
<ul>
<li><strong>Point</strong> - emits light in every direction. A real-world example would be a light bulb.</li>
<li><strong>Spot</strong> - emits light in a particular direction, with a cone-like shape. A real-world example would be a flashlight.</li>
<li><strong>Directional</strong> - emits light in a particular direction, but does not have position. The closest real-world example would be the Sun.</li>
</ul>
</li>
<li><a href="fyrox/beginning/../scene/camera_node.html">Camera</a> - allows you to see the world. You must have at least one camera in your scene to be able to see anything.</li>
<li><a href="fyrox/beginning/../scene/sprite_node.html">Sprite</a> - represents a quad that always faces towards a camera. It can have a texture and size and can also can be rotated around the &quot;look&quot; axis.</li>
<li><a href="fyrox/beginning/../scene/particle_system_node.html">Particle system</a> - allows you to create visual effects using a huge set of small particles. It
can be used to create smoke, sparks, blood splatters, etc.</li>
<li><a href="fyrox/beginning/../scene/terrain_node.html">Terrain</a> - allows you to create complex landscapes with minimal effort.</li>
<li><a href="fyrox/beginning/../scene/decal_node.html">Decal</a> - paints on other nodes using a texture. It is used to simulate cracks in concrete walls,
damaged parts of the road, blood splatters, bullet holes, etc.</li>
<li><a href="fyrox/beginning/../physics/rigid_body.html">Rigid Body</a> - a physical entity that is responsible for the dynamic of the rigid. There is a special 
variant for 2D - <code>RigidBody2D</code>.</li>
<li><a href="fyrox/beginning/../physics/collider.html">Collider</a> - a physical shape for a rigid body. It is responsible for contact manifold generation, 
without it, any rigid body will not participate in simulation correctly, so every rigid body must have at least
one collider. There is a special variant for 2D - <code>Collider2D</code>.</li>
<li><a href="fyrox/beginning/../physics/joint.html">Joint</a> - a physical entity that restricts motion between two rigid bodies. It has various amounts
of degrees of freedom depending on the type of the joint. There is a special variant for 2D - <code>Joint2D</code>.</li>
<li><a href="fyrox/beginning/../scene/rectangle.html">Rectangle</a> - a simple rectangle mesh that can have a texture and a color. It is a very simple version of 
a Mesh node, yet it uses very optimized renderer, that allows you to render dozens of rectangles simultaneously.
This node is intended for use in <strong>2D games</strong> only.</li>
<li><a href="fyrox/beginning/../sound/sound.html">Sound</a> - a sound source universal for 2D and 3D. Spatial blend factor allows you to select
a proportion between 2D and 3D.</li>
<li>Listener - an audio receiver that captures the sound at a particular point in your scene and sends it to an audio
context for processing and outputting to an audio playback device.</li>
<li>Animation Player - a container for multiple animations. It can play animations made in the 
<a href="fyrox/beginning/../animation/anim_editor.html">animation editor</a> and apply animation poses to respective scene nodes.</li>
<li>Animation Blending State Machine - a state machine that mixes multiple animations from multiple states into one; each
state is backed by one or more animation playing or blending nodes. See its <a href="fyrox/beginning/../animation/absm_editor.html">respective chapter</a> 
for more info.</li>
</ul>
<p>Every node can be created either in the editor (through <code>Create</code> on the main menu, or through <code>Add Child</code> after right-clicking on 
a game entity) or programmatically via their respective node builder (see <a href="https://docs.rs/fyrox/latest/fyrox/scene/index.html">API docs</a> 
for more info). These scene nodes allow you to build almost any kind of game. It is also possible to create your own 
types of nodes, but that is an advanced topic, which is covered in a <a href="fyrox/beginning/../scene/custom_node.html">future chapter</a>.</p>
<h2 id="local-and-global-coordinates"><a class="header" href="#local-and-global-coordinates">Local and Global Coordinates</a></h2>
<p>A graph describes your scene in a very natural way, allowing you think in terms of relative and absolute coordinates
when working with <em>scene nodes</em>.</p>
<p>A scene node has two kinds of transform - a local and global. The local transform defines where the node is located
relative to its origin, its scale as a percentage, and its rotation around any arbitrary axis.
The global transform is almost the same, but it also includes the whole chain of transforms of the parent nodes. Going 
back to the example of the character and the sword, if the character moves, and by extension the sword, the global 
transform of the sword will reflect the changes made to the character position, yet its local transform will not, since 
that represents the sword's position's relative to the character's, which didn't change.</p>
<p>This mechanism is very simple, yet powerful. The full grace of it unfolds when you're working with 3D models with
skeletons. Each bone in a skeleton has its parent and a set of children, which allows you to rotate, translate, or scale them to
animate your entire character.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="assets"><a class="header" href="#assets">Assets</a></h1>
<p>Pretty much every game depends on various assets, such as 3D models, textures, sounds, etc. Fyrox has its own 
assets pipeline made to make your life easier.</p>
<h2 id="asset-types"><a class="header" href="#asset-types">Asset Types</a></h2>
<p>The engine offers a set of assets that should cover all of your needs:</p>
<ul>
<li><a href="fyrox/beginning/../resources/model.html">Models</a> - are a set of objects. They can be a simple 3D model (barrels, bushes, weapons, 
etc.) or complex scenes with lots of objects and possibly other model instances. Fyrox supports two main formats:
FBX - which can be used to import 3D models, RGS - which are scenes made in Fyroxed. RGS models are special, as they can be 
used as <em>hierarchical prefabs</em>.</li>
<li><a href="fyrox/beginning/../resources/texture.html">Textures</a> - are images used to add graphical details to objects. The
engine supports multiple texture formats, such as PNG, JPG, BMP, etc. Compressed textures in DDS format are also supported.</li>
<li><a href="fyrox/beginning/../resources/sound.html">Sound buffers</a> - are data buffers for sound sources. Fyrox supports WAV and OGG formats. </li>
<li><a href="fyrox/beginning/../resources/curve.html">Curves</a> - are parametric curves. They're used to create complex functions for numeric parameters.
They can be made in the <code>Curve Editor</code> (<code>Utils -&gt; Curve Editor</code>)</li>
<li>It is also possible to create custom assets. See <a href="fyrox/beginning/../resources/custom.html">respective chapter</a> for more info.</li>
</ul>
<h2 id="asset-management"><a class="header" href="#asset-management">Asset Management</a></h2>
<p>Asset management is performed from the <code>Asset Browser</code> window in the editor, you can select an asset, preview it, and edit
its import options. Here's a screenshot of the asset browser with a texture selected:</p>
<p><img src="fyrox/beginning/assets.png" alt="asset browser" /></p>
<p>The most interesting part here is the import options section under the previewer. It allows you to set asset-specific import options
and apply them. Every asset has its own set of import options. See their respective asset page from the section above to learn
what each import option is for.</p>
<h2 id="asset-instantiation"><a class="header" href="#asset-instantiation">Asset Instantiation</a></h2>
<p>Some asset types can be instantiated in scenes; for now, you can only create direct instances from models. This
is done by simply dragging the model you want to instantiate and dropping it on the <code>Scene Preview</code>. While dragging it, you'll also see a preview of the model.</p>
<p><img src="fyrox/beginning/preview.gif" alt="preview" /></p>
<p>The maximum amount of asset instances is not limited by the engine but it is by the memory and CPU resources of your PC. 
Note that the engine does try to reuse data across instances as much as possible.</p>
<p>You can also instantiate assets dynamically from your code. Here's an example of that for a Model:</p>
<pre><pre class="playground"><code class="language-rust no_run edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    asset::manager::ResourceManager,
</span><span class="boring">    resource::model::{Model, ModelResourceExtension},
</span><span class="boring">    scene::{node::Node, Scene},
</span><span class="boring">};
</span><span class="boring">use std::path::Path;
</span>async fn instantiate_model(
    path: &amp;Path,
    resource_manager: ResourceManager,
    scene: &amp;mut Scene,
) -&gt; Handle&lt;Node&gt; {
    // Load the model first. Alternatively, you can store the resource handle somewhere and use it for instantiation.
    let model = resource_manager.request::&lt;Model, _&gt;(path).await.unwrap();

    model.instantiate(scene)
}
<span class="boring">}</span></code></pre></pre>
<p>This is very useful with prefabs that you may want to instantiate in a scene at runtime. </p>
<h2 id="loading-assets"><a class="header" href="#loading-assets">Loading Assets</a></h2>
<p>Usually, there is no need to manually handle the loading of assets since you have the editor to help with that - just create
a scene with all the required assets. However, there are times when you may need to instantiate some asset dynamically, for 
example, a bot prefab. For this cases, you can use the <code>ResourceManager</code> and its respective methods, such as <code>request_model</code>, 
<code>request_texture</code>, etc.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="data-management"><a class="header" href="#data-management">Data Management</a></h1>
<p>The engine uses pools to store most objects (scene nodes in a 
graph, animations in an animation player, sound sources in an audio context, etc.). Since you'll use them quite often, reading and understanding this chapter is recommended. </p>
<h2 id="motivation"><a class="header" href="#motivation">Motivation</a></h2>
<p>Rust ownership system and borrow checker, in particular, dictate the rules of data management. In game development, you
often have the need to reference objects from other objects. In languages like C, this is usually achieved by simply storing a raw 
pointer and calling it a day. That works, yet it's remarkably unsafe - you risk either forgetting to destroy an object and leaking 
memory or destroying an object still being referenced and then trying to access deallocated memory. Other languages, like C++, allow 
you to store <em>shared pointers</em> to your data, which by keeping a reference count, ensures the previous doesn't happen at the cost of 
a, most often, negligible overhead. Rust counts with smart pointers similar to this, though not without their limitations. There is the <code>Rc/Arc</code> - they function like <em>shared pointers</em>, except they don't allow mutating their content, only 
reading it. If you want mutability, you use either a <code>RefCell</code> for a
single-threaded environment, or a <code>Mutex</code> for a multithreaded environment. That is where the problems begin. For 
types such as <code>Rc&lt;RefCell&gt;</code> or <code>Arc&lt;Mutex&gt;</code>, Rust enforces its borrowing rules at runtime, which are unlimited readers but 
a single writer. Any attempt to borrow mutably more than once at a time will lead to a runtime error.</p>
<p>Another problem with these shared references is that is very easy to accidentally create cyclical references
that prevent objects from ever being destroyed. While the previous could be lived with, the last problem is especially
severe in the case of games: the overhead of runtime checks. In the case of a <code>Rc&lt;RefCell&gt;</code>, it is a single 
reference counter for given accesses to the data, but in the case of a <code>Arc&lt;Mutex&gt;</code>, it is a mutex lock. </p>
<p>The solution to these problems is far from ideal; it certainly has its own downfalls. Instead of scattering objects across memory 
and then having to manage the lifetime of each of them through reference counting, we can store all of the objects in a single
and contiguous memory block and then use indices to access each object. Such a structure is called a pool. </p>
<h2 id="technical-details"><a class="header" href="#technical-details">Technical Details</a></h2>
<p>A pool is an efficient method of data management. A pool is a vector with entries that can be either vacant or occupied. Each 
entry, regardless of its status, also stores a number called a <em>generation</em> number. This is used 
to understand whether an entry has changed over time or not. When an entry is reused, its generation number is 
increased, rendering all previously created handles leading to the entry invalid. This is a simple and efficient 
algorithm for tracking the lifetime of objects.</p>
<p>To access the data in the entries, the engine uses the previously mentioned <em>handles</em>. A handle is a pair of the index of an entry
and a generation number. When you put an object in the pool, this gives you the handle that leads to the object, as well as the 
entry's current generation number. The number remains valid until you &quot;free&quot; the object, which makes the entry vacant again.</p>
<h2 id="advantages"><a class="header" href="#advantages">Advantages</a></h2>
<ul>
<li>Since a pool is a contiguous memory block, it is far more CPU cache-friendly. This reduces the occurrences of CPU cache misses, which makes accesses to data blazingly fast.</li>
<li>Almost every entity in Fyrox lives on its own pool, which makes it easy to create data structures
like graphs, where nodes refer to other nodes. In this case, nodes simply need to store a handle to refer to other nodes.</li>
<li>Simple lifetime management. There is no way to leak memory since cross-references can only be done via handles.</li>
<li>Fast random access with a constant complexity.</li>
<li>Handles are the same size as a pointer on a 64-bit architecture, just 8 bytes.</li>
</ul>
<h2 id="disadvantages"><a class="header" href="#disadvantages">Disadvantages</a></h2>
<ul>
<li>Pools can contain lots of gaps between currently used memory, which may lead to less efficient memory usage. </li>
<li>Handles are sort of weak references, but worse. Since they do not own any data nor even point to their data, you
need a reference to its pool instance in order to borrow the data a handle leads to.</li>
<li>Handles introduce a level of indirection that can hurt performance in places with high loads that require random
access, though this is not too significant as random access is already somewhat slow because of potential 
CPU cache misses.</li>
</ul>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<p>You'll use <code>Handle</code> <em>a lot</em> while working with Fyrox. So where are the main usages of pools and 
handles? The largest is in a <a href="fyrox/beginning/../scene/graph.html">scene graph</a>. This stores all the nodes in a pool and gives handles
to each node. Each scene node stores a handle to their parent node and a set of handles to their children nodes. A scene graph
automatically ensures that such handles are valid. In <a href="fyrox/beginning/../scripting/script.html">scripts</a>, you can also store handles
to scene nodes and assign them in the editor.</p>
<p><a href="fyrox/beginning/../animation/animation.html">Animation</a> is another place that stores handles to animated scene nodes. 
<a href="fyrox/beginning/../animation/blending.html">Animation Blending State Machine</a> stores its own state graph using a pool; it also takes
handles to animations from an animation player in a scene. </p>
<p>And the list could keep going for a long time. This is why you need to understand the basic concepts of data management, as to 
efficiently and fearlessly use Fyrox.</p>
<h2 id="borrowing"><a class="header" href="#borrowing">Borrowing</a></h2>
<p>Once an object is placed in a pool, you have to use its respective handle to get a reference to it. This can
be done with either <code>pool.borrow(handle)</code> or <code>pool.borrow_mute(handle)</code>, or by using the <code>Index</code> trait: <code>pool[handle]</code>. Note that 
these methods panic when the handle given is invalid. If you want to be safe, use the <code>try_borrow(handle)</code> or 
<code>try_borrow_mut(handle)</code> method.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::core::pool::Pool;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>let mut pool = Pool::&lt;u32&gt;::new();
let handle = pool.spawn(1);

let obj = pool.borrow_mut(handle);
*obj = 11;

let obj = pool.borrow(handle);
assert_eq!(*obj, 11);
<span class="boring">}</span></code></pre></pre>
<h2 id="freeing"><a class="header" href="#freeing">Freeing</a></h2>
<p>You can extract an object from a pool by calling <code>pool.free(handle)</code>. This will give you the object back and make all current 
handles to it invalid.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::core::pool::Pool;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>let mut pool = Pool::&lt;u32&gt;::new();
let handle = pool.spawn(1);

pool.free(handle);

let obj = pool.try_borrow(handle);
assert_eq!(obj, None);
<span class="boring">}</span></code></pre></pre>
<h2 id="take-and-reserve"><a class="header" href="#take-and-reserve">Take and Reserve</a></h2>
<p>Sometimes you may want to temporarily extract an object from a pool, do something with it, and then put it back, yet not want 
to break every handle to the object in the process. There are three methods for this:</p>
<ol>
<li><code>take_reserve</code> + <code>try_take_reserve</code> - moves an object out of the pool but leaves the entry in an occupied state. This function returns a tuple with two values <code>(Ticket&lt;T&gt;, T)</code>. The latter one being your object, and the former one being a wrapper over its index that allows you to return the object once you're done with it. This is called a ticket. Note that attempting to borrow a moved object will cause a panic! </li>
<li><code>put_back</code> - moves the object back using the given ticket. The ticket contains information about where in the pool to return the object to. </li>
<li><code>forget_ticket</code> - makes the pool entry vacant again. Useful in cases where you move an object
out of the pool, and then decide you won't return it. If this is the case, you <strong>must</strong> call
this method, otherwise, the corresponding entry will remain unusable.</li>
</ol>
<p>Reservation example:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::core::pool::Pool;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>let mut pool = Pool::&lt;u32&gt;::new();
let handle = pool.spawn(1);

let (ticket, ref mut obj) = pool.take_reserve(handle);

*obj = 123;

// Attempting to fetch while there is an existing reservation, will fail.

let attempt_obj = pool.try_borrow(handle);
assert_eq!(attempt_obj, None);

// Put the object back, allowing borrowing again.

pool.put_back(ticket, *obj);

let obj = pool.borrow(handle);

assert_eq!(obj, &amp;123);
<span class="boring">}</span></code></pre></pre>
<p>Forget example:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::core::pool::Pool;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>let mut pool = Pool::&lt;u32&gt;::new();
let handle = pool.spawn(1);

let (ticket, _obj) = pool.take_reserve(handle);

pool.forget_ticket(ticket);

let obj = pool.try_borrow(handle);

assert_eq!(obj, None);
<span class="boring">}</span></code></pre></pre>
<h2 id="iterators"><a class="header" href="#iterators">Iterators</a></h2>
<p>There are a few possible iterators, each one serving its own purpose:</p>
<ol>
<li><code>iter/iter_mut</code> - creates an iterator over occupied pool entries, returning references to each object.</li>
<li><code>pair_iter/pair_iter_mut</code> - creates an iterator over occupied pool entries, returning tuples of a handle and reference
to each object. </li>
</ol>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::core::pool::Pool;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>let mut pool = Pool::&lt;u32&gt;::new();
let _handle = pool.spawn(1);

let mut iter = pool.iter_mut();

let next_obj = iter.next().unwrap();

assert_eq!(next_obj, &amp;1);

let next_obj = iter.next();

assert_eq!(next_obj, None);
<span class="boring">}</span></code></pre></pre>
<h2 id="direct-access"><a class="header" href="#direct-access">Direct Access</a></h2>
<p>You have the ability to get an object from a pool using only an index. The methods for that are <code>at</code> and <code>at_mut</code>.</p>
<h2 id="validation"><a class="header" href="#validation">Validation</a></h2>
<p>To check if a handle is valid, you can use the <code>is_valid_handle</code> method.</p>
<h2 id="type-erased-handles"><a class="header" href="#type-erased-handles">Type-erased Handles</a></h2>
<p>The pool module also offers type-erased handles that can be of use in some situations. Still, try to avoid using these, as they may introduce hard-to-reproduce bugs. Type safety is always good :3</p>
<p>A type-erased handle is called an <code>ErasedHandle</code> and can be created either manually or from a strongly-typed handle.
Both handle types are interchangeable; you can use the <code>From</code> and <code>Into</code> traits to convert from one to the other.</p>
<h3 id="getting-a-handle-to-an-object-by-its-reference"><a class="header" href="#getting-a-handle-to-an-object-by-its-reference">Getting a Handle to an Object by its Reference</a></h3>
<p>If you need to get a handle to an object from only having a reference to it, you can use the <code>handle_of</code> method.</p>
<h3 id="iterate-over-and-filter-out-objects"><a class="header" href="#iterate-over-and-filter-out-objects">Iterate Over and Filter Out Objects</a></h3>
<p>The <code>retain</code> method allows you to filter your pool's content using a closure provided by you.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scripting"><a class="header" href="#scripting">Scripting</a></h1>
<p>A game based on Fyrox is a plugin to the engine and the editor. Plugin defines global application logic and can provide
a set of scripts, that can be used to assign custom logic to scene nodes. Every script can be attached to only one 
plugin.</p>
<p>Fyrox uses scripts to create custom game logic, scripts can be written only in Rust which ensures that your game will
be crash-free, fast and easy to refactor.</p>
<p>Next chapters will cover all parts and will help you to learn how to use plugins + scripts correctly.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="plugins-1"><a class="header" href="#plugins-1">Plugins</a></h1>
<p>A game based on Fyrox is a plugin to the engine and the editor. Plugin defines global application logic and provides
a set of scripts, that can be used to assign custom logic to scene nodes.</p>
<p>Plugin is an &quot;entry point&quot; of your game, it has a fixed set of methods that can be used for initialization, update,
OS event handling, etc. Every plugin is statically linked to the engine (and the editor), there is no support for hot-reloading
due to lack of stable ABI in Rust. However, it is possible to not recompile the editor everytime - if you don't change 
data layout in your structures the editor will be able to compile your game and run it with the currently loaded scene,
thus reducing amount of iterations. You can freely modify application logic and this won't affect the running editor.</p>
<p>The main purpose of the plugins is to hold and operate on some global application data, that can be used in scripts and
provide a set of scripts to the engine. Plugins also have much wider access to engine internals, than scripts. For example,
it is possible to change scenes, add render passes, change resolution, etc. which is not possible from scripts.</p>
<h2 id="structure"><a class="header" href="#structure">Structure</a></h2>
<p>Plugin structure is defined by <a href="https://docs.rs/fyrox/latest/fyrox/plugin/trait.Plugin.html">Plugin</a> trait. Typical
implementation can be generated by <code>fyrox-template</code> tool, and it looks something like this:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span>use fyrox::{
    core::{
        futures::executor::block_on,
        pool::Handle,
    },
    event::Event,
    event_loop::ControlFlow,
    gui::message::UiMessage,
    plugin::{Plugin, PluginConstructor, PluginContext, PluginRegistrationContext},
    scene::{Scene, SceneLoader},
};

pub struct GameConstructor;

impl PluginConstructor for GameConstructor {
    fn register(&amp;self, _context: PluginRegistrationContext) {
        // Register your scripts here.
    }

    fn create_instance(
        &amp;self,
        override_scene: Handle&lt;Scene&gt;,
        context: PluginContext,
    ) -&gt; Box&lt;dyn Plugin&gt; {
        Box::new(Game::new(override_scene, context))
    }
}

pub struct Game {
    scene: Handle&lt;Scene&gt;,
}

impl Game {
    pub fn new(override_scene: Handle&lt;Scene&gt;, context: PluginContext) -&gt; Self {
        let scene = if override_scene.is_some() {
            override_scene
        } else {
            // Load a scene from file if there is no override scene specified.
            let scene = block_on(
                block_on(SceneLoader::from_file(
                    &quot;data/scene.rgs&quot;,
                    context.serialization_context.clone(),
                    context.resource_manager.clone()
                ))
                    .unwrap()
                    .finish(),
            );

            context.scenes.add(scene)
        };

        Self { scene }
    }
}

impl Plugin for Game {
    fn on_deinit(&amp;mut self, _context: PluginContext) {
        // Do a cleanup here.
    }

    fn update(&amp;mut self, _context: &amp;mut PluginContext, _control_flow: &amp;mut ControlFlow) {
        // Add your global update code here.
    }

    fn on_os_event(
        &amp;mut self,
        _event: &amp;Event&lt;()&gt;,
        _context: PluginContext,
        _control_flow: &amp;mut ControlFlow,
    ) {
        // Do something on OS event here.
    }

    fn on_ui_message(
        &amp;mut self,
        _context: &amp;mut PluginContext,
        _message: &amp;UiMessage,
        _control_flow: &amp;mut ControlFlow,
    ) {
        // Handle UI events here.
    }
}
<span class="boring">}</span></code></pre></pre>
<p>There are two major parts - <code>GameConstructor</code> and <code>Game</code> itself. <code>GameConstructor</code> implements <code>PluginConstructor</code> and it
is responsible for script registration (<code>fn register</code>) and creating the actual game instance (<code>fn create_instance</code>).</p>
<ul>
<li><code>register</code> - called once on start allowing you to register your scripts. <strong>Important:</strong> You must register all your
scripts here, otherwise the engine (and the editor) will know nothing about them.</li>
<li><code>create_instance</code> - called once, allowing you to create actual game instance. It is guaranteed to be called once, but 
<em>where</em> it is called is implementation-defined. For example, the editor will <strong>not</strong> call this method, it does not 
create any game instance. The method has <code>override_scene</code> parameter, in short it is a handle to a scene that must be 
used by your game instead of any other scenes. It is described in <a href="fyrox/scripting/plugin.html#editor-and-plugins">Editor and Plugins</a> section down
below.</li>
</ul>
<p>The game structure (<code>struct Game</code>) implements a <code>Plugin</code> trait which can execute actual game logic in one of its methods:</p>
<ul>
<li><code>on_deinit</code> - it is called when the game is about to shut down. Can be used for any clean up, for example logging that
the game has closed.</li>
<li><code>update</code> - it is called each frame at a stable rate (usually 60 Hz) after the plugin is created and fully initialized.
It is the main place where you should put <em>object-independent</em> game logic, any other logic should be added via scripts.</li>
<li><code>on_os_event</code> - it is called when the main application window receives an event from the operating system, it can be 
any event such as keyboard, mouse, game pad events or any other events. Please note that as for <code>update</code> method, you
should put here only <em>object-independent</em> logic. Scripts can catch window events too.</li>
<li><code>on_ui_message</code> - it is called when there is a message from the user interface, it should be used to react to user
actions (like pressed buttons, etc.)</li>
</ul>
<h2 id="control-flow"><a class="header" href="#control-flow">Control Flow</a></h2>
<p>Some plugin methods provide access to <code>ControlFlow</code> variable, its main usage in the plugin is to give you ability to
stop the game by some conditions. All you need to do is to set it to <code>ControlFlow::Exit</code> and the game will be closed.
It also has other variants, but they don't have any particular usage in the plugins.</p>
<pre><pre class="playground"><code class="language-rust compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn update(&amp;mut self, _context: &amp;mut PluginContext, control_flow: &amp;mut ControlFlow) {
    if self.some_exit_condition {
        control_flow = ControlFlow::Exit;
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="plugin-context"><a class="header" href="#plugin-context">Plugin Context</a></h2>
<p>Vast majority of methods accept <code>PluginContext</code> - it provides almost full access to engine entities, it has access
to the renderer, scenes container, resource manager, user interface, main application window. Typical content of the
context is something like this:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    engine::{SerializationContext},
</span><span class="boring">    asset::manager::ResourceManager,
</span><span class="boring">    gui::UserInterface,
</span><span class="boring">    renderer::Renderer,
</span><span class="boring">    scene::SceneContainer,
</span><span class="boring">    window::Window,
</span><span class="boring">};
</span><span class="boring">use std::sync::Arc;
</span>pub struct PluginContext&lt;'a, 'b&gt; {
    pub scenes: &amp;'a mut SceneContainer,
    pub resource_manager: &amp;'a ResourceManager,
    pub user_interface: &amp;'a mut UserInterface,
    pub renderer: &amp;'a mut Renderer,
    pub dt: f32,
    pub lag: &amp;'b mut f32,
    pub serialization_context: &amp;'a Arc&lt;SerializationContext&gt;,
    pub window: &amp;'a Window,
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li><code>scenes</code> - a scene container, could be used to manage game scenes - add, remove, borrow. An example of scene loading 
is given in the previous code snippet in <code>Game::new()</code> method.</li>
<li><code>resource_manager</code> - is used to load external resources (scenes, models, textures, animations, sound buffers, etc.) from
different sources (disk, network storage on WebAssembly, etc.)</li>
<li><code>user_interface</code> - use it to create user interface for your game, the interface is scene-independent and will remain
the same even if there are multiple scenes created.</li>
<li><code>renderer</code> - can be used to add custom rendering techniques, change quality settings, etc.</li>
<li><code>dt</code> - a time passed since the last frame. The actual value is implementation-defined, but on current implementation it
is equal to 1/60 of a second and does not change event if the frame rate is changing (the engine stabilizes update rate
for the logic).</li>
<li><code>lag</code> - a reference to the time accumulator, that holds remaining amount of time that should be used to update a plugin. 
A caller splits <code>lag</code> into multiple sub-steps using <code>dt</code> and thus stabilizes update rate. The main use of this variable, 
is to be able to reset <code>lag</code> when you're doing some heavy calculations in a game loop (i.e. loading a new level) so the
engine won't try to &quot;catch up&quot; with all the time that was spent in heavy calculation.</li>
<li><code>serialization_context</code> - it can be used to register scripts and custom scene nodes constructors at runtime.</li>
<li><code>window</code> - main application window, you can use it to change title, screen resolution, etc.</li>
</ul>
<h2 id="editor-and-plugins"><a class="header" href="#editor-and-plugins">Editor and Plugins</a></h2>
<p>When you're running your game from the editor, it starts the game as a separate process and if there's a scene opened
in the editor, it tells the game instance to load it on startup. Let's look closely at <code>Game::new</code> method:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::{futures::executor::block_on, pool::Handle},
</span><span class="boring">    plugin::PluginContext,
</span><span class="boring">    scene::{Scene, SceneLoader},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">struct Foo {
</span><span class="boring">    scene: Handle&lt;Scene&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Foo {
</span>pub fn new(override_scene: Handle&lt;Scene&gt;, context: PluginContext) -&gt; Self {
    let scene = if override_scene.is_some() {
        override_scene
    } else {
        // Load a scene from file if there is no override scene specified.
        let scene = block_on(
            block_on(SceneLoader::from_file(
                &quot;data/scene.rgs&quot;,
                context.serialization_context.clone(),
                context.resource_manager.clone(),
            ))
                .unwrap()
                .finish(),
        );

        context.scenes.add(scene)
    };

    Self { scene }
}
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>The <code>override_scene</code> parameter is a handle to a scene instance that is currently opened in the editor, your game
plugin must handle this parameter and use provided scene, otherwise the run from the editor will not have the edited
scene. If the parameter is undefined (equals to <code>Handle::NONE</code>), then there is no scene loaded in the editor or the
game was run outside the editor.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="executor"><a class="header" href="#executor">Executor</a></h1>
<p>Executor is a simple wrapper that drives your game plugins, it is intended to be used for production builds of your game.
The editor runs the executor in separate process when you're entering the play mode. Basically, there is no significant 
difference between running the game from the editor, or running it as a separate application. The main difference is that
the editor passes <code>override_scene</code> parameter for the executor when entering the play mode.</p>
<h2 id="usage-1"><a class="header" href="#usage-1">Usage</a></h2>
<p>Executor is meant to be a part of your project's workspace, its typical look could something like this:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::{pool::Handle, uuid::Uuid},
</span><span class="boring">    engine::executor::Executor,
</span><span class="boring">    plugin::{Plugin, PluginConstructor, PluginContext},
</span><span class="boring">    scene::{Scene},
</span><span class="boring">};
</span><span class="boring">struct GameConstructor;
</span><span class="boring">impl PluginConstructor for GameConstructor {
</span><span class="boring">    fn create_instance(
</span><span class="boring">        &amp;self,
</span><span class="boring">        _override_scene: Handle&lt;Scene&gt;,
</span><span class="boring">        _context: PluginContext,
</span><span class="boring">    ) -&gt; Box&lt;dyn Plugin&gt; {
</span><span class="boring">        todo!()
</span><span class="boring">    }
</span><span class="boring">}
</span>fn main() {
    let mut executor = Executor::new();
    // Register your game constructor here.
    executor.add_plugin_constructor(GameConstructor);
    executor.run()
}</code></pre></pre>
<p>Executor has full access to the engine, and through it to the main application window. You can freely change desired
parts, <code>Executor</code> implements <code>Deref&lt;Target = Engine&gt; + DerefMut</code> traits, so you can use its instance as an &quot;alias&quot;
to engine instance. </p>
<p>To add a plugin to the executor, just use <code>add_plugin_constructor</code> method, it accepts any entity that implements
<code>PluginConstructor</code> traits.</p>
<h2 id="typical-use-cases"><a class="header" href="#typical-use-cases">Typical Use Cases</a></h2>
<p>This section covers typical use cases for the <code>Executor</code>.</p>
<h3 id="setting-window-title"><a class="header" href="#setting-window-title">Setting Window Title</a></h3>
<p>You can set window title when creating executor instance:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::engine::executor::Executor;
</span><span class="boring">use fyrox::window::WindowAttributes;
</span><span class="boring">use fyrox::engine::GraphicsContextParams;
</span>let executor = Executor::from_params(
    Default::default(),
    GraphicsContextParams {
        window_attributes: WindowAttributes {
            title: &quot;My Game&quot;.to_string(),
            ..Default::default()
        },
        vsync: true,
    },
);
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scripts-1"><a class="header" href="#scripts-1">Scripts</a></h1>
<p>Script - is a container for game data and logic that can be assigned to a scene node. Fyrox uses Rust for scripting, 
so scripts are as fast as native code. </p>
<h2 id="script-structure"><a class="header" href="#script-structure">Script Structure</a></h2>
<p>Typical script structure is something like this:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::{uuid::{Uuid, uuid}, visitor::prelude::*, reflect::prelude::*, TypeUuidProvider},
</span><span class="boring">    event::Event, impl_component_provider,
</span><span class="boring">    scene::{graph::map::NodeHandleMap},
</span><span class="boring">    script::{ScriptContext, ScriptDeinitContext, ScriptTrait},
</span><span class="boring">};
</span>#[derive(Visit, Reflect, Default, Debug, Clone)]
struct MyScript {
    // Add fields here.
}

impl_component_provider!(MyScript);

impl TypeUuidProvider for MyScript {
    fn type_uuid() -&gt; Uuid {
        uuid!(&quot;bf0f9804-56cb-4a2e-beba-93d75371a568&quot;)
    }
}

impl ScriptTrait for MyScript {
    fn on_init(&amp;mut self, context: &amp;mut ScriptContext) {
        // Put initialization logic here.
    }
    
    fn on_start(&amp;mut self, context: &amp;mut ScriptContext) {
        // Put start logic - it is called when every other script is already initialized.
    }

    fn on_deinit(&amp;mut self, context: &amp;mut ScriptDeinitContext) {
        // Put de-initialization logic here.
    }

    fn on_os_event(&amp;mut self, event: &amp;Event&lt;()&gt;, context: &amp;mut ScriptContext) {
        // Respond to OS events here.
    }

    fn on_update(&amp;mut self, context: &amp;mut ScriptContext) {
        // Put object logic here.
    }

    fn id(&amp;self) -&gt; Uuid {
        Self::type_uuid()
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Each script must implement following traits:</p>
<ul>
<li><code>Visit</code> implements serialization/deserialization functionality, it is used by the editor to save your object to a 
scene file.</li>
<li><code>Reflect</code> implements compile-time reflection that provides a way to iterate over script fields, set their values, 
find fields by their paths, etc.</li>
<li><code>Debug</code> - provides debugging functionality, it is mostly for the editor to let it turn the structure and its fields 
into string.</li>
<li><code>Clone</code> - makes your structure clone-able, since we can clone objects, we also want the script instance to be 
cloned.</li>
<li><code>Default</code> implementation is very important - the scripting system uses it to create your scripts in the default state.
This is necessary to set some data to it and so on. If it's a special case, you can always implement your own <code>Default</code>'s
implementation if it's necessary for your script.</li>
<li><code>TypeUuidProvider</code> is used to attach some unique id for your type, every script <strong>must</strong> have a unique ID, otherwise, 
the engine will not be able to save and load your scripts. To generate a new UUID, use 
<a href="https://www.uuidgenerator.net/">Online UUID Generator</a> or any other tool that can generate UUIDs.</li>
</ul>
<h2 id="script-template-generator"><a class="header" href="#script-template-generator">Script Template Generator</a></h2>
<p>You can use <code>fyrox-template</code> tool to generate all required boilerplate code for a new script, it makes adding new scripts
much less tedious. To generate a new script use <code>script</code> command:</p>
<pre><code class="language-shell">fyrox-template script --name MyScript
</code></pre>
<p>It will create a new file in <code>game/src</code> directory with <code>my_script.rs</code> name and fill with required code. Do not forget
to add the module with the new script to <code>lib.rs</code> like this: </p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Use your script name instead of `my_script` here.
pub mod my_script;
<span class="boring">}</span></code></pre></pre>
<p>Comments in each generated method should help you to figure out which code should be placed where and what is the purpose
of every method.</p>
<blockquote>
<p>⚠️ Keep in mind that every new script must be registered in <code>PluginConstructor::register</code>, otherwise you won't be able
to assign the script in the editor to a node. See the next section for more info. </p>
</blockquote>
<h2 id="script-registration"><a class="header" href="#script-registration">Script Registration</a></h2>
<p>Every script must be registered before use, otherwise the engine won't &quot;see&quot; your script and won't let you assign it
to an object. <code>PluginConstructor</code> trait has <code>register</code> method exactly for script registration. To register a script
you need to register it in the list of script constructors like so:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">        scene::Scene,
</span><span class="boring">        plugin::{Plugin, PluginConstructor, PluginContext, PluginRegistrationContext},
</span><span class="boring">        core::{
</span><span class="boring">            visitor::prelude::*,
</span><span class="boring">            reflect::prelude::*,
</span><span class="boring">            pool::Handle,
</span><span class="boring">            uuid::Uuid, TypeUuidProvider
</span><span class="boring">        },
</span><span class="boring">        impl_component_provider,
</span><span class="boring">        script::ScriptTrait,
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    #[derive(Reflect, Visit, Default, Copy, Clone, Debug)]
</span><span class="boring">    struct MyScript;
</span><span class="boring">
</span><span class="boring">    impl TypeUuidProvider for MyScript {
</span><span class="boring">        fn type_uuid() -&gt; Uuid {
</span><span class="boring">            todo!()
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl_component_provider!(MyScript);
</span><span class="boring">
</span><span class="boring">    impl ScriptTrait for MyScript {
</span><span class="boring">        fn id(&amp;self) -&gt; Uuid {
</span><span class="boring">            todo!()
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    struct Constructor;
</span><span class="boring">
</span><span class="boring">    impl PluginConstructor for Constructor {
</span>fn register(&amp;self, context: PluginRegistrationContext) {
    context.serialization_context.script_constructors.add::&lt;MyScript&gt;(&quot;My Script&quot;);
}
<span class="boring">
</span><span class="boring">        fn create_instance(&amp;self, _override_scene: Handle&lt;Scene&gt;, _context: PluginContext) -&gt; Box&lt;dyn Plugin&gt; {
</span><span class="boring">            todo!()
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre></pre>
<h2 id="script-attachment"><a class="header" href="#script-attachment">Script Attachment</a></h2>
<p>To assign a script and see it in action, run the editor, select an object and find <code>Script</code> property in the Inspector.
Select your script from the drop-down list. To see the script in action, click &quot;Play/Stop&quot; button. The editor will run
your game in separate process with the scene active in the editor.</p>
<p>The script can be attached to a scene node from code:</p>
<pre><pre class="playground"><code class="language-rust  no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::{reflect::prelude::*, uuid::Uuid, visitor::prelude::*, TypeUuidProvider},
</span><span class="boring">    impl_component_provider,
</span><span class="boring">    scene::node::{Node},
</span><span class="boring">    script::{Script, ScriptTrait},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">#[derive(Reflect, Visit, Default, Copy, Clone, Debug)]
</span><span class="boring">struct MyScript;
</span><span class="boring">
</span><span class="boring">impl TypeUuidProvider for MyScript {
</span><span class="boring">    fn type_uuid() -&gt; Uuid {
</span><span class="boring">        todo!()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl_component_provider!(MyScript);
</span><span class="boring">
</span><span class="boring">impl ScriptTrait for MyScript {
</span><span class="boring">    fn id(&amp;self) -&gt; Uuid {
</span><span class="boring">        todo!()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn set_script&lt;T: ScriptTrait&gt;(node: &amp;mut Node, script: T) {
    node.set_script(Some(Script::new(script)))
}
<span class="boring">}</span></code></pre></pre>
<p>Initialization as well as update of newly assigned script will happen on next update tick of the engine.</p>
<h2 id="script-context"><a class="header" href="#script-context">Script Context</a></h2>
<p>Script context provides access to the environment that can be used to modify engine and game state from scripts. Typical
content of the context is something like this:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    engine::{ScriptMessageDispatcher},
</span><span class="boring">    plugin::Plugin, asset::manager::ResourceManager,
</span><span class="boring">    scene::{node::Node, Scene},
</span><span class="boring">    script::ScriptMessageSender
</span><span class="boring">};
</span>pub struct ScriptContext&lt;'a, 'b, 'c&gt; {
    pub dt: f32,
    pub elapsed_time: f32,
    pub plugins: &amp;'a mut [Box&lt;dyn Plugin&gt;],
    pub handle: Handle&lt;Node&gt;,
    pub scene: &amp;'b mut Scene,
    pub resource_manager: &amp;'a ResourceManager,
    pub message_sender: &amp;'c ScriptMessageSender,
    pub message_dispatcher: &amp;'c mut ScriptMessageDispatcher,
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li><code>dt</code> - amount of time passed since last frame. The value of the variable is implementation-defined, usually it is
something like 1/60 (0.016) of a second.</li>
<li><code>elapsed_time</code> - amount of time that passed since start of your game (in seconds).</li>
<li><code>plugins</code> - a mutable reference to all registered plugins, it allows you to access some &quot;global&quot; game data that does 
not belong to any object. For example, a plugin could store key mapping used for player controls, you can access it 
using <code>plugins</code> field and find desired plugin. In case of a single plugin, you just need to cast the reference to a 
particular type using <code>context.plugins[0].cast::&lt;MyPlugin&gt;().unwrap()</code> call.</li>
<li><code>handle</code> - a handle of the node to which the script is assigned to (parent node). You can borrow the node using
<code>context.scene.graph[handle]</code> call. Typecasting can be used to obtain a reference to a particular node type.</li>
<li><code>scene</code> - a reference to parent scene of the script, it provides you full access to scene content, allowing you to
add/modify/remove scene nodes.</li>
<li><code>resource_manager</code> - a reference to resource manager, you can use it to load and instantiate assets. </li>
<li><code>message_sender</code> - a message sender. Every message sent via this sender will be then passed to every 
<code>ScriptTrait::on_message</code> method of every script.</li>
<li><code>message_dispatcher</code> - a message dispatcher. If you need to receive messages of a particular type, you must subscribe 
to a type explicitly.</li>
</ul>
<h2 id="execution-order"><a class="header" href="#execution-order">Execution order</a></h2>
<p>Scripts have strictly defined execution order for their methods (the order if execution is linear and <strong>do not</strong> depend 
on actual tree structure of the graph where the script is located):</p>
<ul>
<li><code>on_init</code> - called first for every script instance</li>
<li><code>on_start</code> - called after every <code>on_init</code> is called</li>
<li><code>on_update</code> - called zero or more times per one render frame. The engine stabilizes update rate of the logic, so if
your game runs at 15 FPS, the logic will still run at 60 FPS thus the <code>on_update</code> will be called 4 times per frame. The
method can also be not called at all, if the FPS is very high. For example, if your game runs at 240 FPS, then <code>on_update</code>
will be called once per 4 frames.</li>
<li><code>on_message</code> - called once per incoming message.</li>
<li><code>on_os_event</code> - called once per incoming OS event.</li>
<li><code>on_deinit</code> - called at the end of the update cycle once when the script (or parent node) is about to be deleted.</li>
</ul>
<h2 id="message-passing"><a class="header" href="#message-passing">Message passing</a></h2>
<p>Script system of Fyrox supports message passing for scripts. Message passing is a mechanism that allows you to send some 
data (message) to a node, hierarchy of nodes or the entire graph. Each script can subscribe for a specific message type. 
It is an efficient way for decoupling scripts from each other. For instance, you may want to detect and respond to some 
event in your game. In this case when the event has happened, you send a message of a type and every &quot;subscriber&quot; will 
react to it. This way subscribers will not know anything about sender(s); they'll only use message data to do some actions.</p>
<p>A simple example where the message passing can be useful is when you need to react to some event in your game. Imagine,
that you have weapons in your game, and they can have a laser sight that flashes with a different color when some target
was hit. In very naive approach you can handle all laser sights where you handle all intersection for projectiles, but
this adds a very tight coupling between laser sight and projectiles. This is totally unnecessary coupling can be made
loose by using message passing. Instead of handling laser sights directly, all you need to do is to broadcast an
<code>ActorDamaged { actor: Handle&lt;Node&gt;, attacker: Handle&lt;Node&gt; }</code> message. Laser sight in its turn can subscribe for such
message and handle all incoming messages and compare <code>attacker</code> with owner of the laser sight and if the hit was made
by <code>attacker</code> flash with some different color. In code this would like so:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::{pool::Handle, reflect::prelude::*, uuid::Uuid, visitor::prelude::*},
</span><span class="boring">    impl_component_provider,
</span><span class="boring">    scene::node::Node,
</span><span class="boring">    script::{ScriptContext, ScriptMessageContext, ScriptMessagePayload, ScriptTrait},
</span><span class="boring">    core::log::Log,
</span><span class="boring">};
</span><span class="boring">
</span>enum Message {
    Damage {
        actor: Handle&lt;Node&gt;,
        attacker: Handle&lt;Node&gt;,
    },
}

#[derive(Default, Clone, Reflect, Visit, Debug)]
struct Projectile;
<span class="boring">
</span><span class="boring">impl_component_provider!(Projectile);
</span>
impl ScriptTrait for Projectile {
    fn on_update(&amp;mut self, ctx: &amp;mut ScriptContext) {
        // Broadcast the message globally.
        ctx.message_sender.send_global(Message::Damage {
            actor: Default::default(),
            attacker: ctx.handle,
        });
    }
<span class="boring">
</span><span class="boring">    fn id(&amp;self) -&gt; Uuid {
</span><span class="boring">        todo!()
</span><span class="boring">    }
</span>}

#[derive(Default, Clone, Reflect, Visit, Debug)]
struct LaserSight;
<span class="boring">
</span><span class="boring">impl_component_provider!(LaserSight);
</span>
impl ScriptTrait for LaserSight {
    fn on_start(&amp;mut self, ctx: &amp;mut ScriptContext) {
        // Subscript to messages.
        ctx.message_dispatcher.subscribe_to::&lt;Message&gt;(ctx.handle);
    }

    fn on_message(
        &amp;mut self,
        message: &amp;mut dyn ScriptMessagePayload,
        _ctx: &amp;mut ScriptMessageContext,
    ) {
        // React to message.
        if let Some(Message::Damage { actor, attacker }) = message.downcast_ref::&lt;Message&gt;() {
            Log::info(format!(&quot;{actor} damaged {attacker}&quot;,))
        }
    }
<span class="boring">
</span><span class="boring">    fn id(&amp;self) -&gt; Uuid {
</span><span class="boring">        todo!()
</span><span class="boring">    }
</span>}
<span class="boring">}</span></code></pre></pre>
<p>There are few key parts:</p>
<ul>
<li>You should explicitly subscribe script instance to a message type, otherwise messages of the type won't be delivered
to your script. This is done using the message dispatcher: <code>ctx.message_dispatcher.subscribe_to::&lt;Message&gt;(ctx.handle);</code>.
This should be done in <code>on_start</code> method, however it is possible to subscribe/unsubscribe at runime.</li>
<li>You can react to messages only in special method <code>on_message</code> - here you just need to check for message type using
pattern matching and do something useful.</li>
</ul>
<p>Try to use message passing in all cases, loose coupling significantly improves code quality and readability, however
in simple projects it can be ignored completely.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scene"><a class="header" href="#scene">Scene</a></h1>
<p>Scene is a container for game entities. Currently, scenes in the engine manage following entities:</p>
<ol>
<li>Graph</li>
<li>Animations</li>
<li>Physics (rigid bodies, colliders, joints)</li>
<li>Sound </li>
</ol>
<p>Scene allows you to create isolated &quot;world&quot; which won't interact with other scenes, it is very useful for many
more or less complex games.</p>
<h2 id="how-to-create"><a class="header" href="#how-to-create">How to create</a></h2>
<p>A scene could be created either in FyroxEd or programmatically. You can also combine both approaches, where
you build all &quot;static&quot; content in the editor and adding rest of the entities (bots, interactive objects, etc.)
manually by instantiating respective prefabs at runtime.</p>
<h3 id="using-fyroxed"><a class="header" href="#using-fyroxed">Using FyroxEd</a></h3>
<p>There is a <a href="fyrox/scene/../../fyrox/beginning/editor_overview.html">separate chapter</a> in the book that should help you to create a 
scene. After a scene is created, you can load it as any other 3D model (or prefab) using the resource manager:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::{futures::executor::block_on, pool::Handle},
</span><span class="boring">    asset::manager::{ResourceManager}, resource::model::{Model, ModelResourceExtension},
</span><span class="boring">    scene::{node::Node, Scene},
</span><span class="boring">};
</span><span class="boring">use std::path::Path;
</span>
fn load_scene(resource_manager: ResourceManager) -&gt; Scene {
    // Create parent scene.
    let mut scene = Scene::new();

    // Request child scene and block until it loading.
    let scene_resource = block_on(
        resource_manager
            .request::&lt;Model, _&gt;(&quot;path/to/your/scene.rgs&quot;),
    )
        .unwrap();

    // Create an instance of the scene in the parent scene.
    let child_scene = scene_resource.instantiate(&amp;mut scene);

    scene
}
<span class="boring">}</span></code></pre></pre>
<p>Please note that here we're creating an empty scene and only then instantiating another scene into it. Why is this
needed? Child scene is considered as <a href="fyrox/scene/./prefab.html">prefab</a>, and it is &quot;instantiated&quot; in the parent scene. Considering 
it as prefab allows you modifying your scene separately and serialization/deserialization will be able to correctly
apply any changes in the scene.</p>
<h3 id="create-scene-manually"><a class="header" href="#create-scene-manually">Create scene manually</a></h3>
<p>A scene could also be created manually:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{core::pool::Handle, engine::Engine, scene::Scene};
</span>
fn create_scene(engine: &amp;mut Engine) -&gt; Handle&lt;Scene&gt; {
    let mut scene = Scene::new();

    // Use node builders, create sounds, add physics, etc. here to fill the scene.

    engine.scenes.add(scene)
}
<span class="boring">}</span></code></pre></pre>
<p>See respective node builders <a href="fyrox/scene/../scene/graph.html#using-node-builders">docs</a> to populate the scene.</p>
<h2 id="where-all-my-scenes-located"><a class="header" href="#where-all-my-scenes-located">Where all my scenes located?</a></h2>
<p>All scenes &quot;lives&quot; in the engine, the engine has ownership over your scene after you've added it in the engine.
You can borrow a scene at any time using its handle and do some changes.</p>
<h2 id="building-scene-asynchronously"><a class="header" href="#building-scene-asynchronously">Building scene asynchronously</a></h2>
<p>You can create your scene in separate thread and then pass it to main thread to insert it in the engine. Why this 
is needed? Remember the last time you've played a relatively large game, you've probably noticed that it have 
loading screens and loading screen has some fancy interactive stuff with progress bar. Loading screen is fully 
responsive while the game doing hard job loading the world for you. Got it already? Asynchronous scene loading is
needed to create/load large scenes with tons of resources without blocking main thread, thus leaving the game 
fully responsive. There is comprehensive example of asynchronous scene loading, it can be found 
<a href="https://github.com/FyroxEngine/Fyrox/blob/master/examples/async.rs">here</a></p>
<h2 id="managing-multiple-scenes"><a class="header" href="#managing-multiple-scenes">Managing multiple scenes</a></h2>
<p>Usually you should have only one scene active (unless you're making something very special), you should use 
<code>.enabled</code> flag of a scene to turn it off or on. Deactivated scenes won't be rendered, the physics won't be
updated, the sound will stop, and so on. In other words the scene will be frozen. This is useful for situations
when you often need to switch between scenes, leaving other scene in frozen state. One of the examples where this
can be useful is menus. In most games when you're entering the menu, game world is paused. </p>
<h2 id="ambient-lighting"><a class="header" href="#ambient-lighting">Ambient lighting</a></h2>
<p>Every scene has default ambient lighting, it is defined by a single RGB color. By default, every scene has 
some pre-defined ambient lighting, it is bright enough, so you can see your objects. In some cases you may 
need to adjust it or even make it black (for horror games for instance), this can be achieved by a single
line of code:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::scene::Scene;
</span><span class="boring">use fyrox::core::color::Color;
</span><span class="boring">let mut scene = Scene::default();
</span><span class="boring">
</span>scene.ambient_lighting_color = Color::opaque(30, 30, 30); 
<span class="boring">}</span></code></pre></pre>
<p>Please keep in mind that ambient lighting does not mean global illumination, it is a different lighting technique
which is not available in the engine yet.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="graph"><a class="header" href="#graph">Graph</a></h1>
<p>Graph is a set of objects with hierarchical relationships between each object. It is one of the most important 
entities in the engine. Graph takes care of your scene objects and does all the hard work for you.</p>
<h2 id="how-to-create-1"><a class="header" href="#how-to-create-1">How to create</a></h2>
<p>You don't need to create a graph manually, every scene has its own instance of the graph. It can be accessed pretty
easily: <code>scene_ref.graph</code></p>
<h2 id="adding-nodes"><a class="header" href="#adding-nodes">Adding nodes</a></h2>
<p>There are two ways of adding nodes to the graph, either using <em>node builders</em> or manually by calling <code>graph.add_node</code>.</p>
<h3 id="using-node-builders"><a class="header" href="#using-node-builders">Using node builders</a></h3>
<p>Every node in the engine has its respective builder which can be used to create an instance of the node. Using
builders is a preferable way to create scene nodes. There are following node builders:</p>
<ol>
<li><code>BaseBuilder</code> - creates an instance of base node. See <a href="fyrox/scene/./base_node.html">Base node</a> for more info.</li>
<li><code>PivotBuilder</code> - creates an instance of pivot node. See <a href="fyrox/scene/./base_node.html">Base node</a> for more info.</li>
<li><code>CameraBuilder</code> - creates an instance of camera node. See <a href="fyrox/scene/./camera_node.html">Camera node</a> for more info.</li>
<li><code>MeshBuilder</code> - creates an instance of mesh node. See <a href="fyrox/scene/./mesh_node.html">Mesh node</a> for more info.</li>
<li><code>LightBuilder</code> - creates an instance of light node. See <a href="fyrox/scene/./light_node.html">Light node</a> for more info.</li>
<li><code>SpriteBuilder</code> - creates an instance of sprite node. See <a href="fyrox/scene/./sprite_node.html">Sprite node</a> for more info.</li>
<li><code>ParticleSystemBuilder</code> - creates an instance of particle system node. 
See <a href="fyrox/scene/./particle_system_node.html">Particle system node</a> for more info.</li>
<li><code>TerrainBuilder</code> - creates an instance of terrain node. See <a href="fyrox/scene/./terrain_node.html">Terrain node</a> for more info.</li>
<li><code>DecalBuilder</code> - creates an instance of decal node. See <a href="fyrox/scene/./decal_node.html">Decal node</a> for more info.</li>
<li><code>RigidBody</code> - creates an instance of rigid body node. See <a href="fyrox/scene/../physics/rigid_body.html">Rigid body</a> for more info.</li>
<li><code>Collider</code> - creates an instance of collider node. See <a href="fyrox/scene/../physics/collider.html">Collider</a> for more info.</li>
<li><code>Joint</code> - creates an instance of joint node. See <a href="fyrox/scene/../physics/joint.html">Joint</a> for more info.</li>
<li><code>Rectangle</code> - creates an instance of 2D rectangle node. See <a href="fyrox/scene/./rectangle.html">Rectangle</a> for more info.</li>
</ol>
<p>Every builder, other than <code>BaseBuilder</code>, accepts <code>BaseBuilder</code> as a parameter in <code>.new(..)</code> method. Why so?
Because every node (other than Base) is &quot;derived&quot; from Base via composition and the derived
builder must know how to build Base node. While it may sound confusing, it is actually very useful and clear.
Consider this example:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::{algebra::Vector3, pool::Handle},
</span><span class="boring">    scene::{
</span><span class="boring">        base::BaseBuilder, camera::CameraBuilder, node::Node, transform::TransformBuilder,
</span><span class="boring">        Scene,
</span><span class="boring">    },
</span><span class="boring">};
</span>
fn create_camera(scene: &amp;mut Scene) -&gt; Handle&lt;Node&gt; {
    CameraBuilder::new(
        // Here we passing a base builder. Note that, since we can build Base node separately
        // we can pass any custom values to it while building.
        BaseBuilder::new().with_local_transform(
            TransformBuilder::new()
                .with_local_position(Vector3::new(2.0, 0.0, 3.0))
                .build(),
        ),
    ) 
    // Here we just setting desired Camera properties.
    .with_fov(60.0f32.to_radians())
    .build(&amp;mut scene.graph)
}
<span class="boring">}</span></code></pre></pre>
<p>As you can see, we're creating an instance of BaseBuilder and fill it with desired properties as well as filling
the CameraBuilder's instance properties. This is a very flexible mechanism, allowing you to build complex hierarchies
in a declarative manner:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::{algebra::Vector3, pool::Handle},
</span><span class="boring">    scene::{
</span><span class="boring">        base::BaseBuilder, camera::CameraBuilder, mesh::MeshBuilder, node::Node,
</span><span class="boring">        sprite::SpriteBuilder, transform::TransformBuilder, Scene,
</span><span class="boring">    },
</span><span class="boring">};
</span>
fn create_node(scene: &amp;mut Scene) -&gt; Handle&lt;Node&gt; {
    CameraBuilder::new(
        BaseBuilder::new()
            // Add some children nodes.
            .with_children(&amp;[
                // A staff...
                MeshBuilder::new(
                    BaseBuilder::new()
                        .with_name(&quot;MyFancyStaff&quot;)
                        .with_local_transform(
                            TransformBuilder::new()
                                .with_local_position(Vector3::new(0.5, 0.5, 1.0))
                                .build(),
                        ),
                )
                .build(&amp;mut scene.graph),
                // and a spell.
                SpriteBuilder::new(
                    BaseBuilder::new()
                        .with_name(&quot;MyFancyFireball&quot;)
                        .with_local_transform(
                            TransformBuilder::new()
                                .with_local_position(Vector3::new(-0.5, 0.5, 1.0))
                                .build(),
                        ),
                )
                .build(&amp;mut scene.graph),
            ])
            .with_local_transform(
                TransformBuilder::new()
                    .with_local_position(Vector3::new(2.0, 0.0, 3.0))
                    .build(),
            ),
    )
    .with_fov(60.0f32.to_radians())
    .build(&amp;mut scene.graph)
}
<span class="boring">}</span></code></pre></pre>
<p>This code snippet creates a camera for first-person role-playing game's player, it will have a staff in &quot;right-hand&quot;
and a spell in the left hand. Of course all of this is very simplified, but should give you the main idea. Note
that staff and fireball will be children nodes of camera, and when setting their transform, we're actually setting
<strong>local</strong> transform which means that the transform will be relative to camera's. The staff and the spell will move
together with the camera.</p>
<h3 id="adding-a-node-manually"><a class="header" href="#adding-a-node-manually">Adding a node manually</a></h3>
<p>For some rare cases you may also want to delay adding a node to the graph, specifically for that purpose, every node 
builder has <code>.build_node</code> method which creates an instance of <code>Node</code>  but does not add it to the graph.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    scene::{base::BaseBuilder, camera::CameraBuilder, node::Node, Scene},
</span><span class="boring">};
</span>
fn create_node(scene: &amp;mut Scene) -&gt; Handle&lt;Node&gt; {
    let node: Node = CameraBuilder::new(BaseBuilder::new()).build_node();

    // We must explicitly add the node to the graph.
    scene.graph.add_node(node)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="how-to-modify-the-hierarchy"><a class="header" href="#how-to-modify-the-hierarchy">How to modify the hierarchy</a></h2>
<p>For many cases you can't use builders to create complex hierarchy, the simplest example of such situation when 
you're creating an instance of some 3D model. If you want the instance to be a child object of some other object,
you should attach it explicitly by using <code>graph.link_nodes(..)</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::{futures::executor::block_on, pool::Handle},
</span><span class="boring">    asset::manager::ResourceManager, resource::model::{Model, ModelResourceExtension},
</span><span class="boring">    scene::{base::BaseBuilder, camera::CameraBuilder, node::Node, Scene},
</span><span class="boring">};
</span>
fn link_weapon_to_camera(
    scene: &amp;mut Scene,
    camera: Handle&lt;Node&gt;,
    resource_manager: ResourceManager,
) {
    let weapon = block_on(
        resource_manager
            .request::&lt;Model, _&gt;(&quot;path/to/weapon.fbx&quot;),
    )
    .unwrap()
    .instantiate(scene);

    // Link weapon to the camera.
    scene.graph.link_nodes(weapon, camera);
}
<span class="boring">}</span></code></pre></pre>
<p>Here we've loaded a weapon 3D model, instantiated it on scene and attached to <em>existing</em> camera. </p>
<h2 id="how-to-remove-nodes"><a class="header" href="#how-to-remove-nodes">How to remove nodes</a></h2>
<p>A node could be removed by simply calling <code>graph.remove_node(handle)</code>, this method removes the node from the 
graph <strong>with all of its children nodes</strong>. Sometimes this is unwanted behaviour, and you want to preserve children
nodes while deleting parent node. To do that, you need to explicitly detach children nodes of the node you're about
to delete:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    scene::{node::Node, Scene},
</span><span class="boring">};
</span>
fn remove_preserve_children(scene: &amp;mut Scene, node_to_remove: Handle&lt;Node&gt;) {
    for child in scene.graph[node_to_remove].children().to_vec() {
        scene.graph.unlink_node(child);
    }

    scene.graph.remove_node(node_to_remove);
}
<span class="boring">}</span></code></pre></pre>
<p>After calling this function, every child node of <code>node_to_remove</code> will be detached from it and the <code>node_to_remove</code>
will be deleted. <code>remove_node</code> has some limitations: it cannot be used to extract &quot;sub-graph&quot; from the graph, it
just drops nodes immediately. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="transformation"><a class="header" href="#transformation">Transformation</a></h1>
<p>Transformation (transform for short) - is a special entity that changes coordinate system from one to another. It is used
primarily in scene nodes to store their position/rotation/scale/pivots/etc. Fyrox has quite complex transformations, that
supports:</p>
<ol>
<li>Position (<code>T</code>)</li>
<li>Rotation (<code>R</code>)</li>
<li>Scale (<code>S</code>)</li>
<li>Pre-rotation (<code>Rpre</code>) </li>
<li>Post-rotation (<code>Rpost</code>) </li>
<li>Rotation Pivot (<code>Rp</code>)</li>
<li>Rotation Offset (<code>Roff</code>)</li>
<li>Scaling Offset (<code>Soff</code>)</li>
<li>Scaling Pivot (<code>Sp</code>)</li>
</ol>
<p>Final transformation matrix will be <code>Transform = T * Roff * Rp * Rpre * R * Rpost * Rp⁻¹ * Soff * Sp * S * Sp⁻¹</code>. In 99.9%
cases first three are enough for pretty much every task. Other six components used for specific stuff (mainly for nodes
that imported from FBX file format).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="prefabs"><a class="header" href="#prefabs">Prefabs</a></h1>
<p>A prefab is a separate scene that can be instantiated in some other scene, while preserving links between properties
of its instances and of its parent prefab. Prefabs allow you to create a part of a scene and have multiple instances of
it in other scenes.</p>
<p>Let's quickly check what that means on practice. The engine has a prefab system which allows you to build 
hierarchical scenes which can include any number of other scenes as child scenes. Child scenes can have their own child
scenes and so on. This is very efficient decoupling mechanism that allows you to put pieces of the scene in separate 
scenes (prefabs) and modify them independently. The changes in child scenes will be automatically reflected to all parent
scenes. Here is the very simple example of why this is important: imagine you need to populate a town with 3D models of
cars. Each kind of car has its own 3D model and for example, a collision body that won't allow the player to walk through
cars. How would you do this? The simplest (and dumbest) solution is to copy dozens of car models in the scene, and
you're done. Imagine that now you need to change something in your car, for example, add a trunk that can be opened.
What will you do? Of course, you should &quot;iterate&quot; over each car model and do the required changes, you simply don't have
any other option. This will eat huge amount of time and in general it is very non-productive.</p>
<p>This is where prefabs will save you hours of work. All you need to do is to create a car prefab and instantiate it
multiple times in your scene. When you'll need to change something in the car, you simply go to the prefab and change
it. After that every prefab instance will have your changes!</p>
<p>Prefabs can be used to create self-contained entities in your game, examples of this includes: visual effects, 
any scripted game entities (bots, turrets, player, doors, etc.). Such prefabs can be either directly instantiated in
a scene in the editor, or instantiated at runtime when needed.</p>
<h2 id="how-to-create-and-use-a-prefab"><a class="header" href="#how-to-create-and-use-a-prefab">How to create and use a prefab</a></h2>
<p>All you need to do is to make a scene in the editor with all required objects and save it! After that, you can use the
scene in other scenes and just do its instantiation, as in usual 3D models. You can either instantiate it from the
editor by drag'n'drop a prefab to scene previewer, or do standard <a href="fyrox/scene/../resources/model.html#instantiation">model resource instantiation</a></p>
<h2 id="property-inheritance"><a class="header" href="#property-inheritance">Property inheritance</a></h2>
<p>As already mentioned in the intro section, instances inherit properties from their parent prefabs. For example, you
can change position of an object in prefab and every instance will reflect that change - the object's instances will
also move. This works until there's no manual change to a property in instance, if you do so, your change is 
considered with higher priority. See <a href="fyrox/scene/./inheritance.html">this chapter</a> for more info.</p>
<h2 id="hierarchical-prefabs"><a class="header" href="#hierarchical-prefabs">Hierarchical Prefabs</a></h2>
<p>Prefabs can have other prefab instances inside it. This means that you can, for example, create a room populated with
instances of other prefabs (bookshelves, chairs, tables, etc.) and then use the room prefab to build a bigger scene.
The changes in the base prefabs will be reflected in their instances, regardless of how deep the hierarchy is.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="property-inheritance-1"><a class="header" href="#property-inheritance-1">Property Inheritance</a></h1>
<p>Property inheritance is used to propagate changes of unmodified properties from a prefab to its instances. For example,
you can change scale of a node in a prefab and its instances will have the same scale too, unless the scale is
set explicitly in an instance. Such feature allows you to tweak instances, add some unique details to them, but take
general properties from parent prefabs.</p>
<p>Property inheritance works for prefab hierarchies of any depth, this means that you can create something like this:
a room prefab can have multiple instances of various furniture prefabs in it, while the furniture prefabs can also be
constructed from other prefabs and so on. In this case if you modify a property in one of the prefabs in the chain, 
all instance will immediately sync their unmodified properties. </p>
<h2 id="how-to-create-inheritable-properties"><a class="header" href="#how-to-create-inheritable-properties">How To Create Inheritable Properties</a></h2>
<p>It is possible to use property inheritance for script variables. To make a property of your script inheritable, all you
need is to wrap its value using <code>InheritableVariable</code> wrapper.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::core::variable::InheritableVariable;
</span><span class="boring">use fyrox::core::visitor::prelude::*;
</span><span class="boring">use fyrox::core::reflect::prelude::*;
</span>#[derive(Reflect, Visit, Default, Clone, Debug)]
struct MyScript {
    foo: InheritableVariable&lt;f32&gt;
}
<span class="boring">}</span></code></pre></pre>
<p>The engine will automatically resolve the correct value for the property when a scene with the script is loaded. If your
property was modified, then its value will remain the same, it won't be overwritten by parent's value. Keep in mind,
that the type of the inheritable variable must be cloneable and support reflection.</p>
<p><code>InheritableVariable</code> implements the <code>Deref&lt;Target = T&gt; + DerefMut</code> traits, this means that any access via the <code>DerefMut</code> trait
will mark the property as modified. This could be undesired in some cases so <code>InheritableVariable</code> supports special <code>xxx_silent</code> 
methods that don't touch the internal modifiers and allows you to substitute the value with some other &quot;silently&quot; -
without marking the variable as modified.</p>
<h2 id="which-fields-should-be-inheritable"><a class="header" href="#which-fields-should-be-inheritable">Which Fields Should Be Inheritable?</a></h2>
<p>Inheritable variables intended to be &quot;atomic&quot; - it means that the variable stores some simple variable (<code>f32</code>, <code>String</code>,
<code>Handle&lt;Node&gt;</code>, etc.). While it is possible to store &quot;compound&quot; variables (<code>InheritableVariable&lt;YourStruct&gt;</code>), it is
not advised because of inheritance mechanism. When the engine sees inheritable variable, it searches the same variable
in a parent entity and copies its value to the child, thus completely replacing its content. In this case, even if you
have inheritable variables inside compound field, they won't be inherited correctly. Let's demonstrate this in the
following code snippet:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::core::reflect::prelude::*;
</span><span class="boring">use fyrox::core::variable::InheritableVariable;
</span><span class="boring">
</span>#[derive(Reflect, Clone, PartialEq, Eq, Debug)]
struct SomeComplexData {
    foo: InheritableVariable&lt;u32&gt;,
    bar: InheritableVariable&lt;String&gt;,
}

#[derive(Reflect, Debug)]
struct MyEntity {
    some_field: InheritableVariable&lt;f32&gt;,

    // This field won't be inherited correctly - at first it will take parent's value and then
    // will try to inherit inner fields, but its is useless step, because inner data is already
    // a full copy of parent's field value.
    incorrectly_inheritable_data: InheritableVariable&lt;SomeComplexData&gt;,

    // Subfields of this field will be correctly inherited, because the field itself is not inheritable.
    inheritable_data: SomeComplexData,
}
<span class="boring">}</span></code></pre></pre>
<p>This code snippet should clarify, that inheritable fields should contain some &quot;simple&quot; data, and almost never - complex
structs.</p>
<h2 id="editor"><a class="header" href="#editor">Editor</a></h2>
<p>The editor wraps all inheritable properties in a special widget that supports property reversion. Reversion allows you
to drop current changes and take the parent's property value. This is useful if you want a property to inherit its parent's 
value. In the Inspector it looks like this:</p>
<p><img src="fyrox/scene/./revert.png" alt="revert" /></p>
<p>Clicking on the <code>&lt;</code> button will take the value from the parent prefab and the property won't be marked as modified anymore. In case
there is no parent prefab, the button will just drop <code>modified</code> flag.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="base-node"><a class="header" href="#base-node">Base node</a></h1>
<p>Base node is a scene node that stores hierarchical information (a handle to the parent node and a set of handles
to children nodes), local and global transform, name, tag, lifetime, etc. It has self-describing name - it
is used as a base node for every other scene node (via composition).</p>
<p>It has no graphical information, so it is invisible all the time, but it is useful as a &quot;container&quot; for children
nodes.</p>
<h2 id="how-to-create-2"><a class="header" href="#how-to-create-2">How to create</a></h2>
<p>Use the <code>PivotBuilder</code> to create an instance of the Pivot node (remember <code>Base</code> node itself is used only to build other
node types):</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::scene::{base::BaseBuilder, pivot::PivotBuilder, Scene};
</span><span class="boring">fn build_node(scene: &amp;mut Scene) {
</span>let handle = PivotBuilder::new(BaseBuilder::new()).build(&amp;mut scene.graph);
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<h2 id="building-a-complex-hierarchy"><a class="header" href="#building-a-complex-hierarchy">Building a complex hierarchy</a></h2>
<p>To build a complex hierarchy of some nodes, use <code>.with_children()</code> method of the <code>BaseBuilder</code>, it allows you
to build a hierarchy of any complexity:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::scene::{base::BaseBuilder, pivot::PivotBuilder, camera::CameraBuilder, Scene};
</span><span class="boring">
</span><span class="boring">fn build_node(scene: &amp;mut Scene) {
</span>let handle = PivotBuilder::new(BaseBuilder::new()
    .with_children(&amp;[
        CameraBuilder::new(BaseBuilder::new()).build(&amp;mut scene.graph),
        PivotBuilder::new(BaseBuilder::new()
            .with_children(&amp;[PivotBuilder::new(BaseBuilder::new()).build(&amp;mut scene.graph)]))
            .build(&amp;mut scene.graph),
    ]))
    .build(&amp;mut scene.graph);
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>Note that when we're building a <code>Camera</code> instance, we're passing a new instance of <code>BaseBuilder</code> to it, this
instance can also be used to set some properties and a set of children nodes.</p>
<p>The &quot;fluent syntax&quot; is not mandatory to use, the above code snipped could be rewritten like this:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::scene::{base::BaseBuilder, pivot::PivotBuilder, camera::CameraBuilder, Scene};
</span><span class="boring">
</span><span class="boring">fn build_node(scene: &amp;mut Scene) {
</span>let camera = CameraBuilder::new(BaseBuilder::new()).build(&amp;mut scene.graph);

let child_base = PivotBuilder::new(BaseBuilder::new()).build(&amp;mut scene.graph);

let base = PivotBuilder::new(BaseBuilder::new()
    .with_children(&amp;[child_base]))
    .build(&amp;mut scene.graph);

let handle = PivotBuilder::new(BaseBuilder::new()
    .with_children(&amp;[camera, base]))
    .build(&amp;mut scene.graph);
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>However, it looks less informative, because it loses the hierarchical view and it is harder to tell the relations
between objects.</p>
<h2 id="transform"><a class="header" href="#transform">Transform</a></h2>
<p>Base node has a local transform that allows you to translate/scale/rotate/etc. your node as you want to. For example,
to move a node at specific location you could use this:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">   core::{algebra::Vector3, pool::Handle},
</span><span class="boring">   scene::{node::Node, Scene},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn translate_node(scene: &amp;mut Scene, node_handle: Handle&lt;Node&gt;) {
</span>scene.graph[node_handle]
    .local_transform_mut()
    .set_position(Vector3::new(1.0, 0.0, 2.0));
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>You could also chain multiple <code>set_x</code> calls, like so:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">   core::{algebra::Vector3, pool::Handle},
</span><span class="boring">   scene::{node::Node, Scene},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn transform_node(scene: &amp;mut Scene, node_handle: Handle&lt;Node&gt;) {
</span>scene.graph[node_handle]
    .local_transform_mut()
    .set_position(Vector3::new(1.0, 0.0, 2.0))
    .set_scale(Vector3::new(2.0, 2.0, 2.0))
    .set_rotation_offset(Vector3::new(1.0, 1.0, 0.0));
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>See more info about transformations <a href="fyrox/scene/./transform.html">here</a>.</p>
<h2 id="visibility"><a class="header" href="#visibility">Visibility</a></h2>
<p><code>Base</code> node stores all info about local visibility and global visibility (with parent's chain visibility included).
Changing node's visibility could be useful if you want to improve performance by hiding distant objects (however it 
strongly advised to use level-of-detail for this) or to hide some objects in your scene. There are three main methods
to set or fetch visibility:</p>
<ul>
<li><code>set_visibility</code> - sets local visibility for a node.</li>
<li><code>visibility</code> - returns current local visibility of a node.</li>
<li><code>global_visibility</code> - returns combined visibility of a node. It includes visibility of every parent node in the 
hierarchy, so if you have a parent node with some children nodes and set parent's visibility to <code>false</code>, global visibility
of children nodes will be <code>false</code> too, even if local visibility is <code>true</code>. This is useful technique for hiding complex
objects with lots of children nodes.</li>
</ul>
<h2 id="enablingdisabling-scene-nodes"><a class="header" href="#enablingdisabling-scene-nodes">Enabling/disabling scene nodes</a></h2>
<p>A scene node could be enabled or disabled. Disabled nodes are excluded from a game loop and has almost zero CPU consumption
(their global transform/visibility/enabled state is still updated due to limitations of the engine). Disabling a node
could be useful if you need to completely freeze some hierarchy and do keep it in this state until it is enabled again.
It could be useful to disable parts of a scene with which a player cannot interact to improve performance. Keep in mind,
that enabled state is hierarchical like visibility. When you're disabling a parent node with some children nodes, the
children nodes will be disabled too.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mesh-node"><a class="header" href="#mesh-node">Mesh node</a></h1>
<p>Mesh is a scene node that represents a 3D model. This one of the most commonly used nodes in almost every game.
Meshes could be easily created either programmatically or be made in some 3D modelling software (like Blender)
and loaded in your scene.</p>
<h2 id="surfaces"><a class="header" href="#surfaces">Surfaces</a></h2>
<p>Surface is a set of triangles that uses the same <a href="fyrox/scene/../rendering/materials.html">material</a>. Mesh node could contain zero of 
more surfaces; each surface contains a set of vertices and indices that binds vertices with triangles. Mesh nodes split 
into surfaces to be rendered effectively by modern GPUs.</p>
<h2 id="how-to-create-3"><a class="header" href="#how-to-create-3">How to create</a></h2>
<p>There are basically two ways, how to pick one depends on your needs. In general, using a 3D modelling software is
the way to go, especially with tons and tons of free 3D models available online.</p>
<blockquote>
<p>⚠️ The engine supports <em>only</em> FBX file format for 3D models!</p>
</blockquote>
<h3 id="using-a-3d-modelling-software"><a class="header" href="#using-a-3d-modelling-software">Using a 3D modelling software</a></h3>
<p>To create a 3D model, you could use <a href="https://www.blender.org/">Blender</a> and then export it to <code>FBX</code> file format.
To load your 3D model in the game, you should do few simple steps (loading a 3D model does not differ from a prefab 
instantiation):</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span>
use fyrox::{
    core::{futures::executor::block_on, pool::Handle},
    asset::manager::{ResourceManager}, resource::model::{Model, ModelResourceExtension},
    scene::{node::Node, Scene},
};
use std::path::Path;

fn load_model_to_scene(
    scene: &amp;mut Scene,
    path: &amp;Path,
    resource_manager: ResourceManager,
) -&gt; Handle&lt;Node&gt; {
    // Request model resource and block until it loading. 
    let model_resource =
        block_on(resource_manager.request::&lt;Model, _&gt;(path))
            .unwrap();

    // Create an instance of the resource in the scene. 
    model_resource.instantiate(scene)
}
<span class="boring">}</span></code></pre></pre>
<p>This code snippet intentionally omits proper <code>async/await</code> usage (instead it just blocks current thread until
model is loading) and error handling. In the real game you should carefully handle all errors and use <code>async/await</code>
properly.</p>
<h3 id="creating-a-procedural-mesh"><a class="header" href="#creating-a-procedural-mesh">Creating a procedural mesh</a></h3>
<p>A mesh instance could be created from code, such meshes are called &quot;procedural&quot;. They're suitable for cases when you
cannot create a mesh in 3D modelling software.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span>
use fyrox::{
    core::{
        algebra::{Matrix4, Vector3},
        parking_lot::Mutex,
        pool::Handle,
        sstorage::ImmutableString,
    },
    asset::manager::ResourceManager, resource::model::{Model, ModelResourceExtension},
    resource::texture::Texture,
    material::{shader::SamplerFallback, Material, PropertyValue, SharedMaterial},
    scene::{
        base::BaseBuilder,
        mesh::{
            surface::{SurfaceBuilder, SurfaceData, SurfaceSharedData},
            MeshBuilder,
        },
        node::Node,
        transform::TransformBuilder,
        Scene,
    },
};
use std::sync::Arc;

fn create_procedural_mesh(
    scene: &amp;mut Scene,
    resource_manager: ResourceManager,
) -&gt; Handle&lt;Node&gt; {
    let mut material = Material::standard();

    // Material is completely optional, but here we'll demonstrate that it is possible to
    // create procedural meshes with any material you want.
    material
        .set_property(
            &amp;ImmutableString::new(&quot;diffuseTexture&quot;),
            PropertyValue::Sampler {
                value: Some(resource_manager.request::&lt;Texture, _&gt;(&quot;some_texture.jpg&quot;)),
                fallback: SamplerFallback::White,
            },
        )
        .unwrap();

    // Notice the MeshBuilder.
    MeshBuilder::new(
        BaseBuilder::new().with_local_transform(
            TransformBuilder::new()
                .with_local_position(Vector3::new(0.0, -0.25, 0.0))
                .build(),
        ),
    )
    .with_surfaces(vec![SurfaceBuilder::new(SurfaceSharedData::new(
        // Our procedural mesh will have a form of squashed cube.
        // A mesh can have unlimited amount of surfaces.
        SurfaceData::make_cube(Matrix4::new_nonuniform_scaling(&amp;Vector3::new(
            25.0, 0.25, 25.0,
        ))),
    ))
        .with_material(SharedMaterial::new(material))
        .build()])
    .build(&amp;mut scene.graph)
}
<span class="boring">}</span></code></pre></pre>
<p>As you can see, creating a mesh procedurally requires lots of manual work and not so easy.</p>
<h2 id="animation"><a class="header" href="#animation">Animation</a></h2>
<p>Mesh node supports bone-based animation (skinning). See <a href="fyrox/scene/./../animation/animation.html">Animation chapter</a> for more info.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="light-node"><a class="header" href="#light-node">Light node</a></h1>
<p>The engine offers complex lighting system with various types of light sources. </p>
<h2 id="light-types"><a class="header" href="#light-types">Light types</a></h2>
<p>There are three main types of light sources: directional, point, and spot lights.</p>
<h3 id="directional-light"><a class="header" href="#directional-light">Directional light</a></h3>
<p>Directional light does not have a position, its rays are always parallel, and it has a particular direction in space.
An example of directional light in real-life could be our Sun. Even if it is a point light, it is so far away from
the Earth, so we can assume that its rays are always parallel. Directional light sources are suitable for outdoor 
scenes.</p>
<p>A directional light source could be created like this:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    scene::{
</span><span class="boring">        base::BaseBuilder,
</span><span class="boring">        light::{directional::DirectionalLightBuilder, BaseLightBuilder},
</span><span class="boring">        node::Node,
</span><span class="boring">        Scene,
</span><span class="boring">    },
</span><span class="boring">};
</span>
fn create_directional_light(scene: &amp;mut Scene) -&gt; Handle&lt;Node&gt; {
    DirectionalLightBuilder::new(BaseLightBuilder::new(BaseBuilder::new()))
        .build(&amp;mut scene.graph)
}
<span class="boring">}</span></code></pre></pre>
<p>By default, the light source will be oriented to lit &quot;the ground&quot;. In other words its direction will be faced towards
<code>(0.0, -1.0, 0.0)</code> vector. You can rotate it as you want by setting local transform of it while building. Something
like this:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::{
</span><span class="boring">        algebra::{UnitQuaternion, Vector3},
</span><span class="boring">        pool::Handle,
</span><span class="boring">    },
</span><span class="boring">    scene::{
</span><span class="boring">        base::BaseBuilder,
</span><span class="boring">        light::{directional::DirectionalLightBuilder, BaseLightBuilder},
</span><span class="boring">        node::Node,
</span><span class="boring">        transform::TransformBuilder,
</span><span class="boring">        Scene,
</span><span class="boring">    },
</span><span class="boring">};
</span>
fn create_directional_light(scene: &amp;mut Scene) -&gt; Handle&lt;Node&gt; {
    DirectionalLightBuilder::new(BaseLightBuilder::new(
        BaseBuilder::new().with_local_transform(
            TransformBuilder::new()
                .with_local_rotation(UnitQuaternion::from_axis_angle(
                    &amp;Vector3::x_axis(),
                    -45.0f32.to_radians(),
                ))
                .build(),
        ),
    ))
    .build(&amp;mut scene.graph)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="point-light"><a class="header" href="#point-light">Point light</a></h3>
<p>Point light is a light source that emits lights in all directions, it has a position, but does not have an orientation.
An example of a point light source: light bulb. </p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    scene::{
</span><span class="boring">        base::BaseBuilder,
</span><span class="boring">        light::{point::PointLightBuilder, BaseLightBuilder},
</span><span class="boring">        node::Node,
</span><span class="boring">        Scene,
</span><span class="boring">    },
</span><span class="boring">};
</span>
fn create_point_light(scene: &amp;mut Scene) -&gt; Handle&lt;Node&gt; {
    PointLightBuilder::new(BaseLightBuilder::new(BaseBuilder::new()))
        .with_radius(5.0)
        .build(&amp;mut scene.graph)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="spotlight"><a class="header" href="#spotlight">Spotlight</a></h3>
<p>Spotlight is a light source that emits lights in cone shape, it has a position and orientation. An example of 
a spotlight source: flashlight.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    scene::{
</span><span class="boring">        base::BaseBuilder,
</span><span class="boring">        light::{spot::SpotLightBuilder, BaseLightBuilder},
</span><span class="boring">        node::Node,
</span><span class="boring">        Scene,
</span><span class="boring">    },
</span><span class="boring">};
</span>
fn create_spot_light(scene: &amp;mut Scene) -&gt; Handle&lt;Node&gt; {
    SpotLightBuilder::new(BaseLightBuilder::new(BaseBuilder::new()))
        .with_distance(5.0)
        .with_hotspot_cone_angle(50.0f32.to_radians())
        .with_falloff_angle_delta(10.0f32.to_radians())
        .build(&amp;mut scene.graph)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="light-scattering"><a class="header" href="#light-scattering">Light scattering</a></h2>
<p><img src="fyrox/scene/scattering.png" alt="scattering" /></p>
<p>Spot and point lights support light scattering effect. Imagine you're walking with a flashlight in a foggy weather,
the fog will scatter the light from your flashlight making it, so you'll see the &quot;light volume&quot;. Light scattering is
<strong>enabled by default</strong>, so you don't have to do anything to enable it. However, in some cases you might want to disable 
it, you can do this either while building a light source or change light scattering options on existing light source.
Here is the small example of how to do that.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    scene::{node::Node, light::BaseLight, Scene},
</span><span class="boring">};
</span>
fn disable_light_scatter(scene: &amp;mut Scene, light_handle: Handle&lt;Node&gt;) {
    scene.graph[light_handle]
        .query_component_mut::&lt;BaseLight&gt;()
        .unwrap()
        .enable_scatter(false);
}
<span class="boring">}</span></code></pre></pre>
<p>You could also change the amount of scattering per each color channel, using this you could imitate the 
<a href="https://en.wikipedia.org/wiki/Rayleigh_scattering">Rayleigh scattering</a>:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::{algebra::Vector3, pool::Handle},
</span><span class="boring">    scene::{node::Node, light::BaseLight, Scene},
</span><span class="boring">};
</span>
fn use_rayleigh_scattering(scene: &amp;mut Scene, light_handle: Handle&lt;Node&gt;) {
    scene.graph[light_handle]
        .query_component_mut::&lt;BaseLight&gt;()
        .unwrap()
        .set_scatter(Vector3::new(0.03, 0.035, 0.055));
}
<span class="boring">}</span></code></pre></pre>
<h2 id="shadows"><a class="header" href="#shadows">Shadows</a></h2>
<p>By default, light sources cast shadows. You can change this by using <code>set_cast_shadows</code> method of a light source. You
should carefully manage shadows: shadows giving the most significant performance impact, you should keep the amount of 
light sources that can cast shadows at lowest possible amount to keep performance at good levels. You can also turn 
on/off shadows when you need:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    scene::{node::Node, light::BaseLight, Scene},
</span><span class="boring">};
</span>
fn switch_shadows(scene: &amp;mut Scene, light_handle: Handle&lt;Node&gt;, cast_shadows: bool) {
    scene.graph[light_handle]
        .query_component_mut::&lt;BaseLight&gt;()
        .unwrap()
        .set_cast_shadows(cast_shadows);
}
<span class="boring">}</span></code></pre></pre>
<p>Not every light should cast shadows, for example a small light that a player can see only in a distance can have
shadows disabled. You should set the appropriate values depending on your scene, just remember: the fewer the shadows
the better the performance. The most expensive shadows are from point lights, the less, from spotlights and directional
lights. </p>
<h2 id="performance-1"><a class="header" href="#performance-1">Performance</a></h2>
<p>Lights are not cheap, every light source has some performance impact. As a general rule, try to keep the amount
of light sources at reasonable levels and especially try to avoid creating tons of light sources in a small area.
Keep in mind that the less area the light needs to &quot;cover&quot;, the higher the performance. This means that you can have
tons of small light sources for free.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sprite"><a class="header" href="#sprite">Sprite</a></h1>
<p>Sprite is just a quad mesh that is always facing camera. It has size, color, rotation around &quot;look&quot; axis and a texture.
Sprites are useful mostly for projectiles, like glowing plasma, and for things that should always face a camera.</p>
<blockquote>
<p>⚠️ It should be noted that <strong>sprites are not meant to be used for 2D games</strong>, they're only for 3D. 
Use <a href="fyrox/scene/./rectangle.html">Rectangle node</a> if you need 2D sprites, they have optimized renderer which can handle tons
of sprites at once (sprite batching).</p>
</blockquote>
<h2 id="how-to-create-4"><a class="header" href="#how-to-create-4">How to create</a></h2>
<p>A sprite instance could be created using <code>SpriteBuilder</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::{color::Color, pool::Handle}, resource::texture::Texture,
</span><span class="boring">    scene::{base::BaseBuilder, node::Node, sprite::SpriteBuilder, Scene},
</span><span class="boring">};
</span>
fn create_sprite(scene: &amp;mut Scene) -&gt; Handle&lt;Node&gt; {
    SpriteBuilder::new(BaseBuilder::new())
        .with_size(2.0)
        .with_rotation(45.0f32.to_radians())
        .with_color(Color::RED)
        .build(&amp;mut scene.graph)
}
<span class="boring">}</span></code></pre></pre>
<p>A sprite with a texture could be created by using <code>.with_texture</code> method of the builder:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span>use fyrox::{
    core::pool::Handle,
    asset::manager::ResourceManager, resource::texture::Texture,
    scene::{base::BaseBuilder, node::Node, sprite::SpriteBuilder, Scene},
};

fn create_sprite(scene: &amp;mut Scene, resource_manager: ResourceManager) -&gt; Handle&lt;Node&gt; {
    SpriteBuilder::new(BaseBuilder::new())
        .with_texture(resource_manager.request::&lt;Texture, _&gt;(&quot;path/to/your/texture.png&quot;))
        .build(&amp;mut scene.graph)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="general-rules"><a class="header" href="#general-rules">General rules</a></h2>
<p>Sprites <strong>must not</strong> be used to create any visual effects that involve many particles. You should use 
<a href="fyrox/scene/particle_system_node.html">particle systems</a> for that. Why so? Particles systems are very well optimized for managing
huge amounts of particles at the same time, but sprites are not. Each sprite is quite heavy to be used as a particle in 
particle systems, it has a lot of &quot;useless&quot; info that will eat a lot of memory.</p>
<blockquote>
<p>⚠️ Currently, the renderer will render each sprite in a separate draw call, which is very inefficient. So you should 
avoid creating lots of sprites.</p>
</blockquote>
<h2 id="limitations"><a class="header" href="#limitations">Limitations</a></h2>
<p>Sprites are not supporting any sort of lighting, if you need lighted sprites, you need to create your own render
pass and use <code>Mesh</code> node with custom shader that will orient all faces towards camera and will do lighting 
calculations. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="particle-system"><a class="header" href="#particle-system">Particle system</a></h1>
<p>Particle system is a scene node that is used to create complex visual effects (VFX). It operates on huge amount
of particles at once allowing you to do complex simulation that involves large amount of particles. Typically,
particle systems are used to create following visual effects: smoke, sparks, blood splatters, steam, etc. </p>
<p><img src="fyrox/scene/./particle_system_example.png" alt="smoke" /></p>
<h2 id="basic-concepts-1"><a class="header" href="#basic-concepts-1">Basic Concepts</a></h2>
<p>Particle system uses <em>single</em> texture for every particle in the system, only Red channel is used. Red channel interpreted
as an alpha for all particles.</p>
<p>Every particle is affected by <code>Acceleration</code> parameters of the particle system. It defines acceleration 
(in m/s<sup>2</sup>) that will affect velocities of every particle. It is used to simulate gravity.</p>
<h3 id="particle"><a class="header" href="#particle">Particle</a></h3>
<p>Particle is a square (not quadrilateral, this is important) with a texture which is always facing towards camera. It
has the following properties:</p>
<ul>
<li><code>Position</code> - defines a position in <em>local</em> coordinates of particle system (this means that if you rotate a particle
system, all particles will be rotated too).</li>
<li><code>Velocity</code> - defines a speed vector (in local coordinates) that will be used to modify local position of the particle 
each frame.</li>
<li><code>Size</code> - size (in meters) of the square shape of the particle.</li>
<li><code>Size Modifier</code> - a numeric value (in meters per second), that will be added to the Size at each frame, it is used 
to modify size of the particles.</li>
<li><code>Lifetime</code> - amount of time (in seconds) that the particle can be active for.</li>
<li><code>Rotation</code> - angle (in radians) that defines rotation around particle-to-camera axis (clockwise).</li>
<li><code>Rotation Speed</code> - speed (in radians per second, rad/s) of rotation of the particle.</li>
<li><code>Color</code> - RGBA color of the particle.</li>
</ul>
<h3 id="emitters"><a class="header" href="#emitters">Emitters</a></h3>
<p>Particle system uses <em>emitters</em> to define a set of zones where particles will be spawned, it also defines initial ranges of 
parameters of particles. Particle system must have at least one emitter to generate particles. </p>
<p>Emitter can be one of the following types:</p>
<ul>
<li><code>Cuboid</code> - emits particles uniformly in a cuboid shape, the shape cannot be rotated, only translated.</li>
<li><code>Sphere</code> - emits particles uniformly in a sphere shape.</li>
<li><code>Cylinder</code> - emits particle uniformly in a cylinder shape, the shape cannot be rotated, only translated.</li>
</ul>
<p>Each emitter have fixed set of parameters that affects <em>initial</em> values for every spawned particle:</p>
<ul>
<li><code>Position</code> - emitter have its own <em>local</em> position (position relative to parent particle system node), this helps you
to create complex particle systems that may spawn particles from multiple zones in space at once.</li>
<li><code>Max Particles</code> - maximum amount of particles available for spawn. By default, it is <code>None</code>, which says that there is 
no limit.</li>
<li><code>Spawn Rate</code> - rate (in units per second) defines how fast the emitter will spawn particles.</li>
<li><code>Lifetime Range</code> - numeric range (in seconds) for particle lifetime values. The lower the beginning of the range
the less spawned particles will live, and vice versa.</li>
<li><code>Size Range</code> - numeric range (in meters) for particle size.</li>
<li><code>Size Modifier Range</code> - numeric range (in meters per second, m/s) for particle size modifier parameter.</li>
<li><code>X/Y/Z Velocity Range</code> - a numeric range (in meters per second, m/s) for a respective velocity axis (X, Y, Z) 
that defines initial speed along the axis.</li>
<li><code>Rotation Range</code> - a numeric range (in radians) for initial rotation of a new particle.</li>
<li><code>Rotation Speed Range</code> - a numeric range (in radians per second, rad/s) for rotation speed of a new particle.</li>
</ul>
<p><strong>Important:</strong> Every range (like Lifetime Range, Size Range, etc.) parameter generates <em>random</em> value for respective 
parameter of a particle. You can tweak the seed of current random number generator (<code>fyrox::core::thread_rng()</code>) to
ensure that generated values will be different each time.</p>
<h2 id="how-to-create-5"><a class="header" href="#how-to-create-5">How to create</a></h2>
<p>There are multiple ways of creating a particle system, pick one that best suits your current needs.</p>
<h3 id="using-the-editor"><a class="header" href="#using-the-editor">Using the editor</a></h3>
<p>The best way to create a particle system is to configure it in the editor, creating from code is possible too (see below),
but way harder and may be not intuitive, because of the large amount of parameters. The editor allows you see the result 
and tweak it very fast. Create a particle system by <code>Create -&gt; Particle System</code> and then you can start editing its 
properties. By default, new particle system has one Sphere particle emitter, you can add new emitters by clicking <code>+</code> 
button at the right of <code>Emitters</code> property in the Inspector (or remove by clicking <code>-</code>). Here's a simple example:</p>
<p><img src="fyrox/scene/./particle_system.png" alt="particle system" /></p>
<p>Now start tweaking desired parameters, it is hard to give any recommendations of how to achieve a particular effect,
only practice matters here.</p>
<h3 id="using-the-code"><a class="header" href="#using-the-code">Using the code</a></h3>
<p>You can also create particle systems from code (in case if you need some procedurally-generated effects):</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::scene::particle_system::{
</span><span class="boring">    emitter::sphere::SphereEmitter, ParticleSystemBuilder, emitter::Emitter,
</span><span class="boring">    emitter::base::BaseEmitterBuilder, emitter::sphere::SphereEmitterBuilder
</span><span class="boring">};
</span><span class="boring">use fyrox::asset::manager::ResourceManager;
</span><span class="boring">use fyrox::core::algebra::Vector3;
</span><span class="boring">use fyrox::scene::graph::Graph;
</span><span class="boring">use fyrox::scene::node::Node;
</span><span class="boring">use fyrox::scene::transform::TransformBuilder;
</span><span class="boring">use fyrox::core::color_gradient::{GradientPoint, ColorGradient};
</span><span class="boring">use fyrox::scene::base::BaseBuilder;
</span><span class="boring">use fyrox::core::color::Color;
</span><span class="boring">use fyrox::resource::texture::Texture;
</span><span class="boring">use std::path::Path;
</span><span class="boring">use fyrox::resource::texture::TexturePixelKind;
</span>fn create_smoke(graph: &amp;mut Graph, resource_manager: &amp;mut ResourceManager, pos: Vector3&lt;f32&gt;) {
     ParticleSystemBuilder::new(BaseBuilder::new()
        .with_lifetime(5.0)
        .with_local_transform(TransformBuilder::new()
            .with_local_position(pos)
            .build()))
        .with_acceleration(Vector3::new(0.0, 0.0, 0.0))
        .with_color_over_lifetime_gradient({
            let mut gradient = ColorGradient::new();
            gradient.add_point(GradientPoint::new(0.00, Color::from_rgba(150, 150, 150, 0)));
            gradient.add_point(GradientPoint::new(0.05, Color::from_rgba(150, 150, 150, 220)));
            gradient.add_point(GradientPoint::new(0.85, Color::from_rgba(255, 255, 255, 180)));
            gradient.add_point(GradientPoint::new(1.00, Color::from_rgba(255, 255, 255, 0)));
            gradient
        })
        .with_emitters(vec![
            SphereEmitterBuilder::new(BaseEmitterBuilder::new()
                .with_max_particles(100)
                .with_spawn_rate(50)
                .with_x_velocity_range(-0.01..0.01)
                .with_y_velocity_range(0.02..0.03)
                .with_z_velocity_range(-0.01..0.01))
                .with_radius(0.01)
                .build()
        ])
        .with_texture(resource_manager.request::&lt;Texture, _&gt;(Path::new(&quot;data/particles/smoke_04.tga&quot;)))
        .build(graph);
}
<span class="boring">}</span></code></pre></pre>
<p>This code creates smoke effect with smooth dissolving (by using color-over-lifetime gradient). Please refer to
<a href="https://docs.rs/fyrox/latest/fyrox/scene/particle_system/index.html">API docs</a> for particle system for more information. </p>
<h3 id="using-prefabs"><a class="header" href="#using-prefabs">Using prefabs</a></h3>
<p>If you need to create particle systems made in the editor, you can always use prefabs. Create a scene with desired
particle system and then <a href="fyrox/scene/../resources/model.html#instantiation">instantiate</a> it to your scene.</p>
<h2 id="soft-particles"><a class="header" href="#soft-particles">Soft particles</a></h2>
<p>Fyrox used special technique, called soft particles, that smooths sharp transitions between particles and scene geometry: </p>
<p><img src="fyrox/scene/./soft_particles.png" alt="soft particles" /></p>
<p>This technique especially useful for effects such as smoke, fog, etc. where you don't want to see the &quot;edge&quot; between 
particles and scene geometry. You can tweak this effect using <code>Soft Boundary Sharpness Factor</code>, the larger the value
the more &quot;sharp&quot; the edge will be and vice versa.</p>
<h2 id="restarting-emission"><a class="header" href="#restarting-emission">Restarting emission</a></h2>
<p>You can &quot;rewind&quot; particle systems in the &quot;initial&quot; state by calling <code>particle_system.clear_particles()</code> method, it 
will remove all generated particles and emission will start over.</p>
<h2 id="enabling-or-disabling-particle-systems"><a class="header" href="#enabling-or-disabling-particle-systems">Enabling or disabling particle systems</a></h2>
<p>By default, every particle system is enabled. Sometimes there is a need to create a particle system, but not enable
it (for example for some delayed effect). You can achieve this by calling <code>particle_system.set_enabled(true/false)</code> 
method. Disabled particle systems will still be drawn, but emission and animation will be stopped. To hide particle
system completely, use <code>particle_system.set_visibility(false)</code> method.</p>
<h2 id="performance-2"><a class="header" href="#performance-2">Performance</a></h2>
<p>Particle systems using special renderer that optimized to draw millions of particles with very low overhead, however
particles simulated on CPU side and may significantly impact overall performance when there are many particle systems
with lots of particles in each.</p>
<h2 id="limitations-1"><a class="header" href="#limitations-1">Limitations</a></h2>
<p>Current particle system implementation is <strong>not deterministic</strong>, this means that the state of the
particles will be different at each run of your game. Also you <strong>cannot</strong> rewind the particle system, nor set
a particular position in time. This fact limits potential usages of the particle system, however it is still useful
for any effects that does not have to be deterministic, like sparks, smoke, steam, etc. This is a known issue, and
it will eventually be fixed by adding a new kind of particle systems. Tracking issue could be found 
<a href="https://github.com/FyroxEngine/Fyrox/issues/120">here</a>.</p>
<p>Particle systems does not interact with lighting, this means that particles will not be lit by light sources in the scene.</p>
<p>The editor still (in 0.27) does not have an ability to edit color-over-lifetime curve, you should set it manually
from code after particle system instantiation using 
<a href="https://docs.rs/fyrox/latest/fyrox/scene/particle_system/struct.ParticleSystem.html#method.set_color_over_lifetime_gradient">respective method</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="terrain"><a class="header" href="#terrain">Terrain</a></h1>
<p>Terrain is a scene node that represents uniform grid of cells where each cell can have different height. Other, commonly
known name for terrain is heightmap. Terrains used to create maps for open-world games, it be used to create hills,
mountains, plateau, roads, etc.</p>
<p><img src="fyrox/scene/./terrain.png" alt="terrain" /></p>
<h2 id="basic-concepts-2"><a class="header" href="#basic-concepts-2">Basic concepts</a></h2>
<p>There are few basic concepts that you should understand before trying to use terrains. This will help you to understand
design decisions and potential use cases.</p>
<h3 id="heightmap"><a class="header" href="#heightmap">Heightmap</a></h3>
<p>As it was already mentioned, terrain is a uniform grid where X and Z coordinates of cells have fixed values, while Y
can change. In this case we can store only width, height and resolution numerical parameters to calculate X and Z coordinates,
while Y is stored in a separate array which is then used to modify heights of cells. Such array is called <em>heightmap</em>.</p>
<p><img src="fyrox/scene/./terrain_mesh.png" alt="terrain mesh" /></p>
<h3 id="layers"><a class="header" href="#layers">Layers</a></h3>
<p>Layer is a material + mask applied to terrain's mesh. Mask is a separate, greyscale texture that defines in which parts
of the terrain the material should be visible or not. White pixels in the mask makes the material to be visible, black -
completely transparent, everything between helps you to create smooth transitions between layers. Here's a simple 
example of multiple layers:</p>
<p><img src="fyrox/scene/./terrain_layers_layout.png" alt="terrain layers layout" /></p>
<p>There are 3 layers: 1 - dirt, 2 - grass, 3 - rocks and grass. As you can see, there are smooth transitions between each
layer, it is achieved by layer's mask.</p>
<p>Each layer uses separate material, which can be edited from respective property editor in the Inspector:</p>
<p><img src="fyrox/scene/./terrain_layer_material.png" alt="terrain layer material" /></p>
<h2 id="creating-terrain-in-the-editor"><a class="header" href="#creating-terrain-in-the-editor">Creating terrain in the editor</a></h2>
<p>You can create a terrain node by clicking <code>Create -&gt; Terrain</code>. It will create a terrain with fixed width, height, 
and resolution (see <a href="fyrox/scene/./terrain_node.html#limitations-and-known-issues">limitations</a>). Once the terrain is created, select
it in the World Viewer and click on Hill icon on the toolbar. This will enable terrain editing, brush options panel 
should also appear. See the picture below with all the steps:</p>
<p><img src="fyrox/scene/./terrain_editing.png" alt="terrain editing" /></p>
<p>The green rectangle on the terrain under the cursor represents current brush. You can edit brush options in the 
<code>Brush Options</code> window:</p>
<p><img src="fyrox/scene/./brush_options.png" alt="brush options" /></p>
<p>You can select a shape (either circle or rectangle with configurable size) and a mode (either modify the height map, or
draw on mask of specific layer).</p>
<p>When editing terrain's height, left mouse button raises height map, but if <code>Shift</code> key is pressed it lowers it instead.
Something similar is applied to the mask editing - left mouse button draws, but if hold <code>Shift</code> - it will erase mask
content.</p>
<h2 id="creating-terrain-from-code"><a class="header" href="#creating-terrain-from-code">Creating terrain from code</a></h2>
<p>Terrain can always be created from code, here's comprehensive example of how to create and modify terrain from code:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::{
</span><span class="boring">        algebra::Vector2, algebra::Vector3, parking_lot::Mutex, pool::Handle,
</span><span class="boring">        sstorage::ImmutableString,
</span><span class="boring">    },
</span><span class="boring">    asset::manager::ResourceManager, resource::texture::Texture,
</span><span class="boring">    material::{shader::SamplerFallback, Material, PropertyValue, SharedMaterial},
</span><span class="boring">    rand::{thread_rng, Rng},
</span><span class="boring">    scene::{
</span><span class="boring">        base::BaseBuilder,
</span><span class="boring">        graph::Graph,
</span><span class="boring">        node::Node,
</span><span class="boring">        terrain::{Brush, BrushMode, BrushShape, Layer, TerrainBuilder},
</span><span class="boring">    },
</span><span class="boring">};
</span><span class="boring">use std::sync::Arc;
</span><span class="boring">
</span>fn setup_layer_material(
    material: &amp;mut Material,
    resource_manager: ResourceManager,
    diffuse_texture: &amp;str,
    normal_texture: &amp;str,
) {
    material
        .set_property(
            &amp;ImmutableString::new(&quot;diffuseTexture&quot;),
            PropertyValue::Sampler {
                value: Some(resource_manager.request::&lt;Texture, _&gt;(diffuse_texture)),
                fallback: SamplerFallback::White,
            },
        )
        .unwrap();
    material
        .set_property(
            &amp;ImmutableString::new(&quot;normalTexture&quot;),
            PropertyValue::Sampler {
                value: Some(resource_manager.request::&lt;Texture, _&gt;(normal_texture)),
                fallback: SamplerFallback::Normal,
            },
        )
        .unwrap();
    material
        .set_property(
            &amp;ImmutableString::new(&quot;texCoordScale&quot;),
            PropertyValue::Vector2(Vector2::new(10.0, 10.0)),
        )
        .unwrap();
}

fn create_random_two_layer_terrain(graph: &amp;mut Graph, resource_manager: &amp;ResourceManager) -&gt; Handle&lt;Node&gt; {
    let terrain = TerrainBuilder::new(BaseBuilder::new())
        .with_layers(vec![
            Layer {
                material: {
                    let mut material = Material::standard_terrain();
                    setup_layer_material(
                        &amp;mut material,
                        resource_manager.clone(),
                        &quot;examples/data/Grass_DiffuseColor.jpg&quot;,
                        &quot;examples/data/Grass_NormalColor.jpg&quot;,
                    );
                    SharedMaterial::new(material)
                },
                .. Default::default()
            },
            Layer {
                material: {
                    let mut material = Material::standard_terrain();
                    setup_layer_material(
                        &amp;mut material,
                        resource_manager.clone(),
                        &quot;examples/data/Rock_DiffuseColor.jpg&quot;,
                        &quot;examples/data/Rock_Normal.jpg&quot;,
                    );
                    SharedMaterial::new(material)
                },
                .. Default::default()
            },
        ])
        .build(graph);

    let terrain_ref = graph[terrain].as_terrain_mut();

    // Draw something on the terrain.
    for _ in 0..60 {
        let x = thread_rng().gen_range(4.0..60.00);
        let z = thread_rng().gen_range(4.0..60.00);
        let radius = thread_rng().gen_range(2.0..4.0);
        let height = thread_rng().gen_range(1.0..3.0);

        // Pull terrain.
        terrain_ref.draw(&amp;Brush {
            center: Vector3::new(x, 0.0, z),
            shape: BrushShape::Circle { radius },
            mode: BrushMode::ModifyHeightMap { amount: height },
        });

        // Draw rock texture on top.
        terrain_ref.draw(&amp;Brush {
            center: Vector3::new(x, 0.0, z),
            shape: BrushShape::Circle { radius },
            mode: BrushMode::DrawOnMask {
                layer: 1,
                alpha: 1.0,
            },
        });
    }

    terrain
}
<span class="boring">}</span></code></pre></pre>
<p>As you can see there is quite a lot of code, ideally you should use editor all the times, because handling everything
from code could be very tedious. The result of its execution (if all textures are set correctly) could be something 
like this (keep in mind that terrain will be random everytime you run the code):</p>
<p><img src="fyrox/scene/./terrain_random.png" alt="terrain from code" /></p>
<h2 id="physics"><a class="header" href="#physics">Physics</a></h2>
<p>By default, terrains does not have respective physical body and shape, it should be added manually. Create a static 
rigid body node with a collider with Heightmap shape (<a href="fyrox/scene/../physics/collider.html">learn more about colliders</a>). Then attach
the terrain to the rigid body. Keep in mind that terrain's origin differs from Heightmap rigid body, so you need to offset 
the terrain to match its physical representation. Enable physics visualization in editor settings to see physical shapes 
and move terrain. Now to move the terrain you should move the body, instead of the terrain (because of parent-child 
<a href="fyrox/scene/../beginning/scene_and_scene_graph.html#local-and-global-coordinates">relations</a>).</p>
<h2 id="performance-3"><a class="header" href="#performance-3">Performance</a></h2>
<p>Terrain rendering complexity have linear dependency with the amount of layers terrain have. Each layer forces the engine
to re-render terrain's geometry with different textures and mask. Typical amount of layers is from 4 to 8. For example,
a terrain could have the following layers: dirt, grass, rock, snow. This is a relatively lightweight scheme. In any case,
you should measure frame time to understand how each new layer affects performance in your case.</p>
<h2 id="limitations-and-known-issues"><a class="header" href="#limitations-and-known-issues">Limitations and known issues</a></h2>
<p>There is no way to cut holes in the terrain yet, it makes impossible to create caves. There is also no way to create 
ledges, use separate meshes to imitate this. See <a href="https://github.com/FyroxEngine/Fyrox/issues/351">tracking issue</a> for
more info.</p>
<p>For now, it is not possible to change width, height, and resolution of terrain, default values may be either too
small or too high, depending on your game. See <a href="https://github.com/FyroxEngine/Fyrox/issues/352">tracking issue</a> for 
more info.</p>
<p>There is no way to flatten terrain slopes in the editor. See <a href="https://github.com/FyroxEngine/Fyrox/issues/353">tracking issue</a>
for more info.</p>
<p>There is no level-of-detail for terrain chunks, so distant pieces of terrain will be renderer with the same quality as
close ones. This may hurt performance in case of large terrains. See <a href="https://github.com/FyroxEngine/Fyrox/issues/127">tracking issue</a>
for more info.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="camera-node"><a class="header" href="#camera-node">Camera node</a></h1>
<p>Camera is a special scene node that allows you to &quot;look&quot; at your scene from any point and with any orientation.
Currently, the engine supports only <em>perspective</em> cameras, which could be represented as a frustum volume. Everything
that &quot;intersects&quot; with the frustum will be rendered. </p>
<p><img src="fyrox/scene/./frustum.svg" alt="Frustum" /></p>
<h2 id="how-to-create-6"><a class="header" href="#how-to-create-6">How to create</a></h2>
<p>An instance of camera node could be created using <code>CameraBuilder</code>: </p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    scene::{base::BaseBuilder, camera::CameraBuilder, node::Node, Scene},
</span><span class="boring">};
</span>
fn create_camera(scene: &amp;mut Scene) -&gt; Handle&lt;Node&gt; {
    CameraBuilder::new(BaseBuilder::new())
        // Set some properties.
        .with_fov(80.0f32.to_radians())
        .with_z_far(256.0)
        .build(&amp;mut scene.graph)
}
<span class="boring">}</span></code></pre></pre>
<p>Orientation and position should be set in <code>BaseBuilder</code> as usual.</p>
<h2 id="projection-modes"><a class="header" href="#projection-modes">Projection modes</a></h2>
<p>Projection mode defines how your scene will look like after rendering, there are two projection modes available.</p>
<h3 id="perspective"><a class="header" href="#perspective">Perspective</a></h3>
<p>Perspective projection makes distant objects smaller and parallel lines converging when using it, it is the most 
common projection type for 3D games. By default, each camera uses perspective projection. It's defined by three 
parameters that describes frustum volume:</p>
<ul>
<li>Field of view angle</li>
<li>Near clipping plane location</li>
<li>Far clipping plane location</li>
</ul>
<p>Here is a simple example of how to create a camera with perspective projection:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    scene::{
</span><span class="boring">        base::BaseBuilder,
</span><span class="boring">        camera::{CameraBuilder, PerspectiveProjection, Projection},
</span><span class="boring">        graph::Graph,
</span><span class="boring">        node::Node,
</span><span class="boring">    },
</span><span class="boring">};
</span>fn create_perspective_camera(graph: &amp;mut Graph) -&gt; Handle&lt;Node&gt; {
    CameraBuilder::new(BaseBuilder::new())
        .with_projection(Projection::Perspective(PerspectiveProjection {
            // Keep in mind that field of view expressed in radians!
            fov: 60.0f32.to_radians(),
            z_near: 0.025,
            z_far: 1024.0,
        }))
        .build(graph)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="orthographic"><a class="header" href="#orthographic">Orthographic</a></h3>
<p>Orthographic projection prevents parallel lines from converging, it does not affect object size with distance.
If you're making 2D games or isometric 3D games, this is the projection mode you're looking for. Orthographic
projection defined by three parameters:</p>
<ul>
<li>Vertical Size</li>
<li>Near Clipping Plane</li>
<li>Far Clipping Plane</li>
</ul>
<p>Vertical size defines how large the &quot;box&quot; will be in vertical axis, horizontal size is derived from vertical
size by multiplying vertical size with aspect ratio.</p>
<p>Here is a simple example of how to create a camera with orthographic projection:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    scene::{
</span><span class="boring">        base::BaseBuilder,
</span><span class="boring">        camera::{CameraBuilder, OrthographicProjection, Projection},
</span><span class="boring">        graph::Graph,
</span><span class="boring">        node::Node,
</span><span class="boring">    },
</span><span class="boring">};
</span>fn create_perspective_camera(graph: &amp;mut Graph) -&gt; Handle&lt;Node&gt; {
    CameraBuilder::new(BaseBuilder::new())
        .with_projection(Projection::Orthographic(OrthographicProjection {
            vertical_size: 5.0,
            z_near: 0.025,
            z_far: 1024.0,
        }))
        .build(graph)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="performance-4"><a class="header" href="#performance-4">Performance</a></h2>
<p>Each camera forces engine to re-render scene one more time, which can be very resource-intensive (both CPU and GPU)
operation. </p>
<p>To reduce GPU load, try to keep the Far Clipping Plane at lowest possible values. For example, if you're making a game
with closed environment (lots of corridors, small rooms, etc.) set the Far clipping Plane to max possible distance that 
can be &quot;seen&quot; in your game - if the largest thing is a corridor, then set the Far clipping Plane to slightly exceed the 
length. This will force the engine to clip everything that is out of bounds and do not draw such objects.</p>
<h2 id="skybox"><a class="header" href="#skybox">Skybox</a></h2>
<p>Outdoor scenes usually have distant objects that can't be reached, these can be mountains, sky, distant forest, etc.
such objects can be pre-rendered and then applied to a huge cube around camera, it always will be rendered first and will
be the background of your scene. To create a Skybox and set it to a camera, you can use the following code:</p>
<pre><pre class="playground"><code class="language-rust no_run edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::{futures::executor::block_on, pool::Handle},
</span><span class="boring">    asset::manager::ResourceManager,
</span><span class="boring">    resource::texture::{Texture, TextureWrapMode},
</span><span class="boring">    scene::{
</span><span class="boring">        base::BaseBuilder,
</span><span class="boring">        camera::{CameraBuilder, SkyBox, SkyBoxBuilder},
</span><span class="boring">        node::Node,
</span><span class="boring">        Scene,
</span><span class="boring">    },
</span><span class="boring">};
</span>
async fn create_skybox(resource_manager: ResourceManager) -&gt; SkyBox {
    // Load skybox textures in parallel.
    let (front, back, left, right, top, bottom) = fyrox::core::futures::join!(
        resource_manager.request::&lt;Texture, _&gt;(&quot;path/to/front.jpg&quot;),
        resource_manager.request::&lt;Texture, _&gt;(&quot;path/to/back.jpg&quot;),
        resource_manager.request::&lt;Texture, _&gt;(&quot;path/to/left.jpg&quot;),
        resource_manager.request::&lt;Texture, _&gt;(&quot;path/to/right.jpg&quot;),
        resource_manager.request::&lt;Texture, _&gt;(&quot;path/to/up.jpg&quot;),
        resource_manager.request::&lt;Texture, _&gt;(&quot;path/to/down.jpg&quot;)
    );

    // Unwrap everything.
    let skybox = SkyBoxBuilder {
        front: Some(front.unwrap()),
        back: Some(back.unwrap()),
        left: Some(left.unwrap()),
        right: Some(right.unwrap()),
        top: Some(top.unwrap()),
        bottom: Some(bottom.unwrap()),
    }
    .build()
    .unwrap();

    // Set S and T coordinate wrap mode, ClampToEdge will remove any possible seams on edges
    // of the skybox.
    let skybox_texture = skybox.cubemap().unwrap();
    let mut data = skybox_texture.data_ref();
    data.set_s_wrap_mode(TextureWrapMode::ClampToEdge);
    data.set_t_wrap_mode(TextureWrapMode::ClampToEdge);

    skybox
}

fn create_camera(scene: &amp;mut Scene, resource_manager: ResourceManager) -&gt; Handle&lt;Node&gt; {
    CameraBuilder::new(BaseBuilder::new())
        .with_skybox(block_on(create_skybox(resource_manager)))
        .build(&amp;mut scene.graph)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="color-grading-look-up-tables"><a class="header" href="#color-grading-look-up-tables">Color grading look-up tables</a></h2>
<p>Color grading Look-Up Tables (LUT) allows you to transform color space of your frame. Probably everyone saw the
famous &quot;mexican&quot; movie effect when everything becomes yellow-ish when action takes place in Mexico, this is done
via color grading LUT effect. When used wisely, it can significantly improve perception of your scene.</p>
<p>Here is the same scene having no color correction along with another case that has &quot;mexico&quot; color correction:</p>
<div class="table-wrapper"><table><thead><tr><th>Scene</th><th>Look-up-table</th></tr></thead><tbody>
<tr><td><img src="fyrox/scene/./no_color_correction.PNG" alt="No Color Correction" /></td><td><img src="fyrox/scene/./lut_neutral.jpg" alt="Neutral LUT" /></td></tr>
<tr><td><img src="fyrox/scene/./with_color_correction.PNG" alt="With Color Correction" /></td><td><img src="fyrox/scene/./lut_mexico.jpg" alt="Neutral LUT" /></td></tr>
</tbody></table>
</div>
<p>To use color grading LUT you could do something like this:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::{futures::executor::block_on, pool::Handle},
</span><span class="boring">    asset::manager::ResourceManager, resource::texture::Texture,
</span><span class="boring">    scene::{
</span><span class="boring">        base::BaseBuilder,
</span><span class="boring">        camera::{CameraBuilder, ColorGradingLut},
</span><span class="boring">        node::Node,
</span><span class="boring">        Scene,
</span><span class="boring">    },
</span><span class="boring">};
</span>
fn create_camera_with_lut(
    scene: &amp;mut Scene,
    resource_manager: ResourceManager,
) -&gt; Handle&lt;Node&gt; {
    CameraBuilder::new(BaseBuilder::new())
        .with_color_grading_enabled(true)
        .with_color_grading_lut(
            block_on(ColorGradingLut::new(
                resource_manager.request::&lt;Texture, _&gt;(&quot;path/to/lut.jpg&quot;),
            ))
            .unwrap(),
        )
        .build(&amp;mut scene.graph)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="picking"><a class="header" href="#picking">Picking</a></h2>
<p>In some games you may need to do mouse picking of objects in your scene. To do that, at first you need to somehow convert
a point on the screen to ray in the world. <code>Camera</code> has <code>make_ray</code> method exactly for that purpose:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::{algebra::Vector2, math::ray::Ray},
</span><span class="boring">    renderer::Renderer,
</span><span class="boring">    scene::camera::Camera,
</span><span class="boring">};
</span><span class="boring">
</span>fn make_picking_ray(camera: &amp;Camera, point: Vector2&lt;f32&gt;, renderer: &amp;Renderer) -&gt; Ray {
    camera.make_ray(point, renderer.get_frame_bounds())
}
<span class="boring">}</span></code></pre></pre>
<p>The ray then can be used to <a href="fyrox/scene/../physics/ray.html">perform a ray cast over physics entities</a>. This is the simplest way
of camera picking, and you should prefer it most of the time.</p>
<h3 id="advanced-picking"><a class="header" href="#advanced-picking">Advanced picking</a></h3>
<p><strong>Important</strong>: The following picking method is for advanced engine users only, if you don't know the math you should not
use it.</p>
<p>If you know the math and don't want to create physical entities, you can use this ray to perform manual 
ray intersection check:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::{
</span><span class="boring">        algebra::Vector3,
</span><span class="boring">        algebra::{Matrix4, Point3},
</span><span class="boring">        math::TriangleDefinition,
</span><span class="boring">        math::{ray::Ray, Vector3Ext},
</span><span class="boring">    },
</span><span class="boring">    scene::node::Node,
</span><span class="boring">    scene::mesh::{
</span><span class="boring">        buffer::{VertexAttributeUsage, VertexReadTrait},
</span><span class="boring">        surface::SurfaceData,
</span><span class="boring">        Mesh,
</span><span class="boring">    },
</span><span class="boring">};
</span><span class="boring">
</span>fn read_vertex_position(data: &amp;SurfaceData, i: u32) -&gt; Option&lt;Vector3&lt;f32&gt;&gt; {
    data.vertex_buffer
        .get(i as usize)
        .and_then(|v| v.read_3_f32(VertexAttributeUsage::Position).ok())
}

fn transform_vertex(vertex: Vector3&lt;f32&gt;, transform: &amp;Matrix4&lt;f32&gt;) -&gt; Vector3&lt;f32&gt; {
    transform.transform_point(&amp;Point3::from(vertex)).coords
}

fn read_triangle(
    data: &amp;SurfaceData,
    triangle: &amp;TriangleDefinition,
    transform: &amp;Matrix4&lt;f32&gt;,
) -&gt; Option&lt;[Vector3&lt;f32&gt;; 3]&gt; {
    let a = transform_vertex(read_vertex_position(data, triangle[0])?, transform);
    let b = transform_vertex(read_vertex_position(data, triangle[1])?, transform);
    let c = transform_vertex(read_vertex_position(data, triangle[2])?, transform);
    Some([a, b, c])
}

pub fn precise_ray_test(
    node: &amp;Node,
    ray: &amp;Ray,
    ignore_back_faces: bool,
) -&gt; Option&lt;(f32, Vector3&lt;f32&gt;)&gt; {
    let mut closest_distance = f32::MAX;
    let mut closest_point = None;

    if let Some(mesh) = node.query_component_ref::&lt;Mesh&gt;() {
        let transform = mesh.global_transform();

        for surface in mesh.surfaces().iter() {
            let data = surface.data();
            let data = data.lock();

            for triangle in data
                .geometry_buffer
                .iter()
                .filter_map(|t| read_triangle(&amp;data, t, &amp;transform))
            {
                if ignore_back_faces {
                    // If normal of the triangle is facing in the same direction as ray's direction,
                    // then we skip such triangle.
                    let normal =
                        (triangle[1] - triangle[0]).cross(&amp;(triangle[2] - triangle[0]));
                    if normal.dot(&amp;ray.dir) &gt;= 0.0 {
                        continue;
                    }
                }

                if let Some(pt) = ray.triangle_intersection_point(&amp;triangle) {
                    let distance = ray.origin.sqr_distance(&amp;pt);

                    if distance &lt; closest_distance {
                        closest_distance = distance;
                        closest_point = Some(pt);
                    }
                }
            }
        }
    }

    closest_point.map(|pt| (closest_distance, pt))
}
<span class="boring">}</span></code></pre></pre>
<p><code>precise_ray_test</code> is what you need, it performs precise intersection check with geometry of a mesh node. It returns a
tuple of the closest distance and the closest intersection point. </p>
<h2 id="exposure-and-hdr"><a class="header" href="#exposure-and-hdr">Exposure and HDR</a></h2>
<p>(WIP)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="decal-node"><a class="header" href="#decal-node">Decal node</a></h1>
<p>Decal nodes allow you to &quot;project&quot; a texture onto your scene within some specific bounds. It is widely used for
bullet holes, blood splatter, dirt, cracks and so on. Here is the example of the decal applied to the scene:</p>
<p><img src="fyrox/scene/./decal.PNG" alt="Decal" /></p>
<p>The rust marks are applied on existing geometry of the scene by projecting a rust texture in specific direction.</p>
<h2 id="how-to-create-7"><a class="header" href="#how-to-create-7">How to create</a></h2>
<p>A decal instance can be created using DecalBuilder:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    asset::manager::ResourceManager, resource::texture::Texture,
</span><span class="boring">    scene::{base::BaseBuilder, decal::DecalBuilder, node::Node, Scene},
</span><span class="boring">};
</span>
fn create_decal(scene: &amp;mut Scene, resource_manager: ResourceManager) -&gt; Handle&lt;Node&gt; {
    DecalBuilder::new(BaseBuilder::new())
        .with_diffuse_texture(resource_manager.request::&lt;Texture, _&gt;(&quot;path/to/your/decal.png&quot;))
        .build(&amp;mut scene.graph)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="textures"><a class="header" href="#textures">Textures</a></h2>
<p>You can specify which textures the decal will be projecting, currently there is only diffuse and normal maps
supported.</p>
<h2 id="rendering"><a class="header" href="#rendering">Rendering</a></h2>
<p>Currently, the engine supports only <em>deferred decals</em>, which means that decals modify the information stored in
G-Buffer. This fact means that decals will be lit correctly with other geometry in the scene. However, if you 
have some objects in your scene that uses forward rendering path, your decals won't be applied to them.</p>
<h2 id="bounds"><a class="header" href="#bounds">Bounds</a></h2>
<p>Decal uses Object-Oriented Bounding Box (OOB) to determine pixels on which decal's textures will be projected,
everything that got into OOB will be covered. Exact bounds can be set by tweaking local transform of a decal.
If you want your decal to be larger, set its scale to some large value. To position a decal - use local position,
to rotate - local rotation.</p>
<p>A decal defines a cube that projects a texture on every pixel of a scene that got into the cube. Exact cube size 
is defined by decal's local scale. For example, if you have a decal with scale of (1.0, 2.0, 0.1) then the size of 
the cube (in local coordinates) will be width = 1.0, height = 2.0 and depth = 0.1. The decal can be rotated as any 
other scene node. Its final size and orientation are defined by the chain of transformations of parent nodes.</p>
<h2 id="layers-1"><a class="header" href="#layers-1">Layers</a></h2>
<p>There are situations when you want to prevent some geometry from being covered with a decal, to do that the engine
offers a concept of layers. A decal will be applied to a geometry if and only if they have matching layer index. This 
allows you to create environment damage decals and they won't affect dynamic objects since they're located on 
different layers.</p>
<h2 id="performance-5"><a class="header" href="#performance-5">Performance</a></h2>
<p>Current implementation of decals is relatively cheap, this allows you to create many decals on scene. However, you
should keep the amount of decals at a reasonable level. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rectangle-node"><a class="header" href="#rectangle-node">Rectangle node</a></h1>
<p>Rectangle is the simplest &quot;2D&quot; node, it can be used to create &quot;2D&quot; graphics. 2D is in quotes here because the node
is actually a 3D node, like everything else in the engine. Here is an example scene made with the rectangle nodes and 
an orthographic camera:</p>
<p><img src="fyrox/scene/2d_scene.PNG" alt="2d scene" /></p>
<p>As you can see it is a good basis for 2D games.</p>
<h2 id="how-to-create-8"><a class="header" href="#how-to-create-8">How to create</a></h2>
<p>Use the RectangleBuilder to create Rectangle nodes:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::{algebra::Vector3, color::Color, pool::Handle},
</span><span class="boring">    asset::manager::ResourceManager, resource::texture::Texture,
</span><span class="boring">    scene::{
</span><span class="boring">        base::BaseBuilder, dim2::rectangle::RectangleBuilder, graph::Graph, node::Node,
</span><span class="boring">        transform::TransformBuilder,
</span><span class="boring">    },
</span><span class="boring">};
</span>fn create_rect(graph: &amp;mut Graph, resource_manager: ResourceManager) -&gt; Handle&lt;Node&gt; {
    RectangleBuilder::new(
        BaseBuilder::new().with_local_transform(
            TransformBuilder::new()
                // Size of the rectangle is defined only by scale.
                .with_local_scale(Vector3::new(0.4, 0.2, 1.0))
                .build(),
        ),
    )
    .with_color(Color::RED)
    .with_texture(resource_manager.request::&lt;Texture, _&gt;(&quot;path/to/your_texture.jpg&quot;))
    .build(graph)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="specifying-image-portion-for-rendering"><a class="header" href="#specifying-image-portion-for-rendering">Specifying image portion for rendering</a></h2>
<p>By default, Rectangle node uses entire image for rendering, but for some applications it is not enough. For example,
you may want to use sprite sheets to animate your 2D entities. In this case you need to be able to use only portion
of an image. It is possible to do by using <code>set_uv_rect</code> method of the Rectangle node. Here's an example of setting
right-top quarter of an image to be used by a Rectangle node:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{core::math::Rect, scene::dim2::rectangle::Rectangle};
</span><span class="boring">
</span>fn set_2nd_quarter_image_portion(rectangle: &amp;mut Rectangle) {
    rectangle.set_uv_rect(Rect::new(
        0.5, // Offset by 50% to the right
        0.0, // No need to offset to bottom.
        0.5, // Use half (50%) of width and height
        0.5,
    ));
}
<span class="boring">}</span></code></pre></pre>
<p>Keep in mind that every part of uv rectangle is proportional. For example 0.5 means 50%, 1.5 = 150% and so on. If width
or height is exceeding 1.0 and the texture being used is set to Wrapping mode at respective axis, the image will tile
across axes.</p>
<h2 id="performance-6"><a class="header" href="#performance-6">Performance</a></h2>
<p>Rectangles use specialized renderer that is heavily optimized to render tons of rectangles at once, so you can use 
rectangles almost for everything in 2D games. </p>
<h2 id="limitations-2"><a class="header" href="#limitations-2">Limitations</a></h2>
<p>Rectangle nodes does not support custom materials - it is a simplified version of a Mesh node that allows you draw a
rectangle with a texture and a color. Its main purpose is to be able to start making games as quick as possible without
diving too deep into details (shaders, render passes, etc.). You can still create a &quot;rectangle&quot; with custom material, use
Mesh node with single rectangle surface:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::{
</span><span class="boring">        algebra::{Matrix4, Vector3},
</span><span class="boring">        parking_lot::Mutex,
</span><span class="boring">        pool::Handle,
</span><span class="boring">    },
</span><span class="boring">    material::{Material, SharedMaterial},
</span><span class="boring">    scene::{
</span><span class="boring">        base::BaseBuilder,
</span><span class="boring">        graph::Graph,
</span><span class="boring">        mesh::{
</span><span class="boring">            surface::{SurfaceBuilder, SurfaceData, SurfaceSharedData},
</span><span class="boring">            MeshBuilder, RenderPath,
</span><span class="boring">        },
</span><span class="boring">        node::Node,
</span><span class="boring">        transform::TransformBuilder,
</span><span class="boring">    },
</span><span class="boring">};
</span><span class="boring">use std::sync::Arc;
</span>
fn create_rect_with_custom_material(
    graph: &amp;mut Graph,
    material: SharedMaterial,
) -&gt; Handle&lt;Node&gt; {
    MeshBuilder::new(
        BaseBuilder::new().with_local_transform(
            TransformBuilder::new()
                .with_local_scale(Vector3::new(0.4, 0.2, 1.0))
                .build(),
        ),
    )
    .with_surfaces(vec![SurfaceBuilder::new(SurfaceSharedData::new(
        SurfaceData::make_quad(&amp;Matrix4::identity()),
    ))
    .with_material(material)
    .build()])
    .with_render_path(RenderPath::Forward)
    .build(graph)
}
<span class="boring">}</span></code></pre></pre>
<p>This will effectively &quot;mimic&quot; the Rectangle node, but will allow you to use the full power of custom shaders. Keep in
mind that Mesh nodes will be rendered via Deferred Renderer, while Rectangle nodes rendered with specialized renderer,
that might result in some graphical artifacts.</p>
<p>Rectangle nodes has limited lighting support, it means that they still will be lit by standard scene lights, but it will
be a very simple diffuse lighting without any &quot;physically correct&quot; lighting. This is perfectly ok for 95% of 2D games,
if you want to add custom lighting then you should use custom shader.</p>
<p>Rectangle nodes works well with 2D physics nodes, check 2D physics section of the book for more info.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-scene-node"><a class="header" href="#custom-scene-node">Custom Scene Node</a></h1>
<p>Sometimes there is a need to have custom scene nodes, it is possible to do, but it requires quite a lot of boilerplate
code.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span>use fyrox::{
    core::{
        reflect::prelude::*,
        math::aabb::AxisAlignedBoundingBox,
        pool::Handle,
        uuid::{uuid, Uuid},
        variable::InheritError,
        visitor::prelude::*,
    },
    asset::manager::ResourceManager,
    scene::{
        base::Base,
        node::{Node, NodeTrait},
    },
};
use std::ops::{Deref, DerefMut};

#[derive(Clone, Reflect, Visit, Debug)]
pub struct CustomNode {
    base: Base,
}

impl Deref for CustomNode {
    type Target = Base;

    fn deref(&amp;self) -&gt; &amp;Self::Target {
        &amp;self.base
    }
}

impl DerefMut for CustomNode {
    fn deref_mut(&amp;mut self) -&gt; &amp;mut Self::Target {
        &amp;mut self.base
    }
}

impl NodeTrait for CustomNode {
    fyrox::impl_query_component!();

    fn local_bounding_box(&amp;self) -&gt; AxisAlignedBoundingBox {
        self.base.local_bounding_box()
    }

    fn world_bounding_box(&amp;self) -&gt; AxisAlignedBoundingBox {
        self.base.world_bounding_box()
    }

    fn id(&amp;self) -&gt; Uuid {
        // Provide unique id for serialization needs. It must be unique, use https://www.uuidgenerator.net/
        // to generate one.
        uuid!(&quot;f592e7f7-5e34-4043-9226-407c7457bb48&quot;)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Once the node is defined, you can create is as usual and put in the graph:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    scene::{camera::Camera, graph::Graph, node::Node},
</span><span class="boring">};
</span><span class="boring">type CustomNode = Camera;
</span><span class="boring">
</span>fn add_custom_node(graph: &amp;mut Graph) -&gt; Handle&lt;Node&gt; {
    graph.add_node(Node::new(CustomNode::default()))
}
<span class="boring">}</span></code></pre></pre>
<h2 id="limitations-3"><a class="header" href="#limitations-3">Limitations</a></h2>
<p>Scene nodes have no access to outer context, this means that you cannot reference any data that is located outside 
graph easily. You still can define a global variable that <strong>will</strong> be accessible, but it is considered as a hack and
should be avoided. If you want to add custom logic to scene nodes, then you should use scripts instead. Custom nodes
are intended for very specific use cases, such as adding &quot;data sources&quot; for renderer, etc.</p>
<h2 id="editor-support"><a class="header" href="#editor-support">Editor support</a></h2>
<p>For now, you cannot create custom nodes from the editor. This will be available in future versions of the engine; when 
editor plugins will be supported.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="physics-1"><a class="header" href="#physics-1">Physics</a></h1>
<p>The engine have full-featured physics engine under the hood (Rapier), it helps you to simulate physics in your games.
There is first-class support for both 2D and 3D physics. There are three main physics entities in the engine:</p>
<ul>
<li>Rigid Body - responsible for rigid body dynamics simulation, must have at least one collider to be able to interact with
other rigid bodies in the world.</li>
<li>Collider - responsible for collision detection.</li>
<li>Joint - responsible for motion restriction between two rigid bodies.</li>
</ul>
<p>All these entities are ordinary scene nodes, so they can be arranged into any hierarchy in the scene. However there some
rules that have to be followed to make physics simulation work as intended:</p>
<ul>
<li>Rigid body node must have at least one <em>direct child</em> Collider node, otherwise rigid body won't interact with other
rigid bodies in the world.</li>
<li>Joint node must have two <em>direct child</em> rigid bodies, otherwise joint will have no effect.</li>
</ul>
<h2 id="differences-between-3d-and-2d"><a class="header" href="#differences-between-3d-and-2d">Differences between 3D and 2D</a></h2>
<p>There is a very few differences between 3D and 2D physics, the most obvious is that 2D physics does simulation only in 
oXY plane (the plane of the screen). 2D physics has less collider shapes available since some 3D shapes degenerate in
2D, for example cylinder 3D shape in 2D is just a rectangle. There is also lesser amount of joints available in 2D, 
there is no revolute joint for example. Unlike 3D physics entities, 2D physics entities exist in the separate
<code>scene::dim2</code> module.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rigid-body-node"><a class="header" href="#rigid-body-node">Rigid body node</a></h1>
<p>Rigid body node is the one of main physical entities in the engine. Rigid body nodes can be affected by gravity, 
external forces and other rigid bodies. Use rigid body node everywhere you need natural physical behaviour for
your objects.</p>
<h2 id="how-to-create-9"><a class="header" href="#how-to-create-9">How to create</a></h2>
<p>Use RigidBodyBuilder to create a rigid body instance:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::{algebra::Vector3, pool::Handle},
</span><span class="boring">    scene::{
</span><span class="boring">        base::BaseBuilder,
</span><span class="boring">        collider::{ColliderBuilder, ColliderShape},
</span><span class="boring">        graph::Graph,
</span><span class="boring">        node::Node,
</span><span class="boring">        rigidbody::RigidBodyBuilder,
</span><span class="boring">    },
</span><span class="boring">};
</span>fn create_cube_rigid_body(graph: &amp;mut Graph) -&gt; Handle&lt;Node&gt; {
    RigidBodyBuilder::new(BaseBuilder::new().with_children(&amp;[
            // Rigid body must have at least one collider
            ColliderBuilder::new(BaseBuilder::new())
                .with_shape(ColliderShape::cuboid(0.5, 0.5, 0.5))
                .build(graph),
        ]))
    .with_mass(2.0)
    .with_lin_vel(Vector3::new(0.0, 3.0, 1.0))
    .build(graph)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="colliders"><a class="header" href="#colliders">Colliders</a></h2>
<p>Rigid body must have at least one collider to participate in simulation properly, multiple colliders can be used to
create complex shapes from simple shapes, you can create concave objects this way. Every collider <strong>must</strong> be a direct
child node of a rigid body. In the editor it could look like this:</p>
<p><img src="fyrox/physics/./colliders.png" alt="colliders" /></p>
<p>Note that, <code>Box</code> node here is an instance of <code>Rigid Body 2D</code>, and it has <code>Collider 2D</code> as a child and some sprite. This 
structure (when a rigid body has a collider as a child) is mandatory for physics engine to work correctly! Collider
won't work (participate in physical simulation) without a rigid body and a rigid body won't work without a collider.
This applied to both 2D and 3D.</p>
<p>Keep in mind, that your graphical representation of an object (some node like <code>Mesh</code>, <code>Sprite</code>, etc.) must be attached
to a rigid body. Otherwise, the rigid body will move, but the graphical representation won't. You can also arrange
it other way around: a graphical node can have rigid body with a collider, but that requires the rigid body to be 
kinematic. This is used to create <a href="fyrox/physics/./collider.html#using-colliders-for-hit-boxes">hit boxes</a>, or any other things 
that should have physical representation, but move together with graphical node.</p>
<h2 id="force-and-torque"><a class="header" href="#force-and-torque">Force and torque</a></h2>
<p>You can apply forces and torque to any rigid body, but only dynamic bodies will be affected. There is two ways of
applying force to a rigid body: at center of mass or at particular point at the body:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{core::algebra::Vector3, scene::rigidbody::RigidBody};
</span>fn apply_force_and_torque(rigid_body: &amp;mut RigidBody) {
    // Push rigid body forward at the center of mass.
    rigid_body.apply_force(Vector3::new(0.0, 0.0, 1.0));

    // Kick rigid body at the side (this will also make it rotate)
    rigid_body.apply_force_at_point(Vector3::new(0.0, 0.0, 1.0), Vector3::new(1.0, 0.0, 0.0));

    // Turn rigid body around center of mass.
    rigid_body.apply_torque(Vector3::new(0.0, 3.0, 0.0));
}
<span class="boring">}</span></code></pre></pre>
<h2 id="kinematic-rigid-bodies"><a class="header" href="#kinematic-rigid-bodies">Kinematic rigid bodies</a></h2>
<p>Sometimes you may want to have direct control over position/rotation of a rigid body and tell the physics engine to not
do simulation for the body. This can be achieved by making the rigid body <em>kinematic</em>:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::{algebra::Vector3, pool::Handle},
</span><span class="boring">    scene::{
</span><span class="boring">        base::BaseBuilder,
</span><span class="boring">        collider::{ColliderBuilder, ColliderShape},
</span><span class="boring">        graph::Graph,
</span><span class="boring">        node::Node,
</span><span class="boring">        rigidbody::{RigidBodyBuilder, RigidBodyType},
</span><span class="boring">    },
</span><span class="boring">};
</span>
fn create_kinematic_rigid_body(graph: &amp;mut Graph) -&gt; Handle&lt;Node&gt; {
    RigidBodyBuilder::new(BaseBuilder::new().with_children(&amp;[
            // Rigid body must have at least one collider
            ColliderBuilder::new(BaseBuilder::new())
                .with_shape(ColliderShape::cuboid(0.5, 0.5, 0.5))
                .build(graph),
        ]))
    .with_body_type(RigidBodyType::KinematicPositionBased)
    .build(graph)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="continuous-collision-detection"><a class="header" href="#continuous-collision-detection">Continuous collision detection</a></h2>
<p>Fast-moving rigid bodies can &quot;fly through&quot; other objects (for example a bullet can completely ignore walls if it is 
moving too fast), this happens because of discrete calculation. This can be fixed by using continuous collision detection,
to enable it use either <code>.with_ccd_enabled(state)</code> of <code>RigidBodyBuilder</code> or <code>.set_ccd_enabled(state)</code> of <code>RigidBody</code>.</p>
<h2 id="dominance"><a class="header" href="#dominance">Dominance</a></h2>
<p>Dominance allows you to set a priority of forces applied to rigid bodies. It defines which rigid body can affect what rigid
body, for example you can set the highest dominance for actors and leave dominance of  everything else at zero, this way
actors will be able to push any other dynamic bodies, but dynamic bodies won't affect actors. This is useful when you don't
want your actors be pushed by surrounding objects (like if someone throws a box at an actor, it will stay still if it has
higher dominance)</p>
<h2 id="2d-rigid-bodies"><a class="header" href="#2d-rigid-bodies">2D rigid bodies</a></h2>
<p>2D rigid bodies have no difference with 3D, except the simulation happens in oXY plane and Z coordinate is ignored.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="collider-node"><a class="header" href="#collider-node">Collider node</a></h1>
<p>Collider is a geometrical shape that is used for collision detection, contact manifold generation, etc. Colliders are used
in pair with rigid bodies, they make rigid body participate in collisions.</p>
<p><strong>Important:</strong> Colliders only works in pair with rigid bodies! Colliders won't be used by the engine, unless they're
direct children of a rigid body. Read <a href="fyrox/physics/./rigid_body.html#colliders">this chapter</a> for more info. </p>
<h2 id="shapes"><a class="header" href="#shapes">Shapes</a></h2>
<p>Collider can have almost any shape, the engine offers the following shapes for 3D:</p>
<ul>
<li>Ball - dynamic sphere shape.</li>
<li>Cylinder - dynamic cylinder shape.</li>
<li>Cone - dynamic cone shape.</li>
<li>Cuboid - dynamic box shape.</li>
<li>Capsule - dynamic capsule shape.</li>
<li>Segment - dynamic segment (&quot;line&quot;) shape</li>
<li>Triangle - simple dynamic triangle shape</li>
<li>Triangle mesh - static concave shape, can be used together with any static level geometry (wall, floors, ceilings,
anything else)</li>
<li>Height field - static height field shape, can be used together with terrains.</li>
<li>Polyhedron - dynamic concave shape.</li>
</ul>
<p>Also, there is a similar, but smaller set for 2D (because some shapes degenerate in 2D):</p>
<ul>
<li>Ball - dynamic circle shape.</li>
<li>Cuboid - dynamic rectangle shape.</li>
<li>Capsule - dynamic capsule shape.</li>
<li>Segment - dynamic segment (&quot;line&quot;) shape.</li>
<li>Triangle - dynamic triangle shape.</li>
<li>Trimesh - static triangle mesh shape.</li>
<li>Heightfield - static height field shape.</li>
</ul>
<p><em>Dynamic</em> in both lists means that such shapes can be used together with <em>dynamic</em> rigid bodies, they'll correctly handle
all collisions and simulation will look as it should. <em>Static</em> means that such shape should be used only with <em>static</em>
rigid bodies.</p>
<h2 id="how-to-create-10"><a class="header" href="#how-to-create-10">How to create</a></h2>
<p>Use ColliderBuilder to create an instance of collider from code with any shape you want.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    scene::{
</span><span class="boring">        base::BaseBuilder,
</span><span class="boring">        collider::{ColliderBuilder, ColliderShape},
</span><span class="boring">        graph::Graph,
</span><span class="boring">        node::Node,
</span><span class="boring">    },
</span><span class="boring">};
</span>fn create_capsule_collider(graph: &amp;mut Graph) -&gt; Handle&lt;Node&gt; {
    ColliderBuilder::new(BaseBuilder::new())
        .with_shape(ColliderShape::capsule_y(0.5, 0.2))
        .with_friction(1.0)
        .build(graph)
}
<span class="boring">}</span></code></pre></pre>
<p>In the editor you can use <code>MainMenu -&gt; Create -&gt; Physics -&gt; Collider</code>, or right-click on a node in <code>World Viewer</code> and
select <code>Add Child -&gt; Physics -&gt; Collider</code>. Collider must be direct child of a rigid body, colliders do nothing on
their own!</p>
<h2 id="collision-filtering"><a class="header" href="#collision-filtering">Collision filtering</a></h2>
<p>Sometimes there's a need to prevent collision between various groups of colliders. Fyrox supports bit-wise collision 
filtering exactly for this purpose. For instance, you may have two groups of colliders: actors and powerups, and you
want the actors to completely ignore collisions with powerups (and vice versa). In this case you can set collision
groups for actors like so:</p>
<p><img src="fyrox/physics/./collision_groups_a.png" alt="actors collision groups" /></p>
<p>And set the collision groups for powerups like so:</p>
<p><img src="fyrox/physics/./collision_groups_b.png" alt="powerups collision groups" /></p>
<p>As you can see, actors and powerups now have separate <code>memberships</code> (read - groups) and filters. This way, the actors
will collide with everything, but powerups and vice versa.</p>
<h2 id="using-colliders-for-hit-boxes"><a class="header" href="#using-colliders-for-hit-boxes">Using colliders for hit boxes</a></h2>
<p>You can use colliders to simulate hit boxes for your game characters. It can be done by creating a rigid body with
<code>KinematicPositionBased</code> type and an appropriate collider as a child node. As the last step you need to attach the body
to a bone in your character's model. Here's a quick example from the editor:</p>
<p><img src="fyrox/physics/./hitbox.png" alt="hitbox" /></p>
<p>As you can see, the rigid body has a capsule collider as a child and the body is attached to the neck bone. The body
has <code>KinematicPositionBased</code> type, which will ensure that the body won't be simulated, instead its position will be 
synchronized with the position of the parent bone.</p>
<p>To actually use the hit boxes in your game, you can either use a ray-casting to perform a hit scan or you can use 
contacts information to fetch the stuff with which a hit box was contacted. See <a href="fyrox/physics/./ray.html">Ray casting</a> chapter of the
section.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="joint"><a class="header" href="#joint">Joint</a></h1>
<p>Joint is a configurable link between two rigid bodies, it restricts relative motion of two bodies. Fyrox provides a 
fixed set of joints that are suitable for various applications.</p>
<ul>
<li>Fixed Joint - hard link between two bodies, it is the same is if two rigid bodies were &quot;welded&quot; to each other with 
a metal rod.</li>
<li>Revolute Joint - restricts all translational movement and any rotations around Y and Z axes, but leaves rotation
around local X axis free. An example of the joint from real world is a door hinge, it allows the door to rotate around 
single axis, but not move.</li>
<li>Prismatic Joint - restricts all rotations, movement is allowed along single axis (local X of the joint). An example
of the joint from real world could be a slider that supports drawers on a table.</li>
<li>Ball Joint - restricts all movement, but leaves rotations unrestricted. An example of a ball joint from real world 
could be human shoulder.</li>
</ul>
<p>2D joints does not have revolute joints, because it degenerates into ball joint.</p>
<h2 id="bodies-binding"><a class="header" href="#bodies-binding">Bodies Binding</a></h2>
<p>When the joint is created and all bodies are set to it, it uses self global transform and bodies global transforms to
calculate local frames for bodies. This process is called <em>binding</em>, it happens once when the joint is created, but
can be initiated by moving the joint to some other position by changing local transform of the joint.</p>
<h2 id="how-to-create-11"><a class="header" href="#how-to-create-11">How to create</a></h2>
<p>To create a joint from code use <code>JointBuilder</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    scene::{
</span><span class="boring">        base::BaseBuilder,
</span><span class="boring">        graph::Graph,
</span><span class="boring">        joint::{BallJoint, JointBuilder, JointParams},
</span><span class="boring">        node::Node,
</span><span class="boring">    },
</span><span class="boring">};
</span>fn create_joint(graph: &amp;mut Graph, body1: Handle&lt;Node&gt;, body2: Handle&lt;Node&gt;) -&gt; Handle&lt;Node&gt; {
    JointBuilder::new(BaseBuilder::new())
        .with_body1(body1)
        .with_body2(body2)
        .with_params(JointParams::BallJoint(BallJoint {
            x_limits_enabled: false,
            x_limits_angles: Default::default(),
            y_limits_enabled: false,
            y_limits_angles: Default::default(),
            z_limits_enabled: false,
            z_limits_angles: Default::default(),
        }))
        .build(graph)
}
<span class="boring">}</span></code></pre></pre>
<p>Once the joint is created, it will bind given bodies, using the process describe in the above section.</p>
<p>To create a joint from editor, use  <code>MainMenu -&gt; Create -&gt; Physics -&gt; Joint</code>, select the new joint and find <code>Body1</code> and
<code>Body2</code> properties. Assign the fields by holding <code>Alt</code> key and drag'n'drop a rigid body to a field. Move the joint to 
correct position to ensure the binding will happen as intended.</p>
<h2 id="limits"><a class="header" href="#limits">Limits</a></h2>
<p>You can restrict motion on primary joint axis (rotational and translational) by setting a limit to desired axis. </p>
<ul>
<li>Ball Joint have three angular limits, one per rotation around an axis. The angle range is given in radians.</li>
<li>Prismatic Joint have only one limit it is maximum linear distance between two bodies along primary joint axis.</li>
<li>Revolute Joint have a single angular limit around primary axis. The angle range is given in radians.</li>
<li>Fixed Joint does not have any limit setting, because it locks all degrees of freedom.</li>
</ul>
<h2 id="usage-2"><a class="header" href="#usage-2">Usage</a></h2>
<p>Joints can be used to create many game entities, such as doors, chains and rag dolls. The most interesting here is 
rag doll. It is used to create realistic behaviour for humans and creatures in games. In general, it is a set of 
rigid bodies, colliders and joints. Where each joint configured to match joints of a creature, for example ball joint
could be used for shoulders, revolute joints for knees and elbows.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ray-casting"><a class="header" href="#ray-casting">Ray Casting</a></h1>
<p>Ray casting allows you to query intersections of a ray with rigid bodies in a scene. Typical usage for ray casting is
hit-scan weapons (weapons that shoots high-speed projectiles), AI collision avoidance, etc. To query intersections,
use physics world instance of a scene graph:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::algebra::{Point3, Vector3},
</span><span class="boring">    scene::graph::{
</span><span class="boring">        physics::{Intersection, RayCastOptions},
</span><span class="boring">        Graph,
</span><span class="boring">    },
</span><span class="boring">};
</span><span class="boring">
</span>fn do_ray_cast(graph: &amp;mut Graph, begin: Vector3&lt;f32&gt;, end: Vector3&lt;f32&gt;) -&gt; Vec&lt;Intersection&gt; {
    let mut buffer = Vec::new();

    let ray_direction = end - begin;

    graph.physics.cast_ray(
        RayCastOptions {
            ray_origin: Point3::from(begin),
            ray_direction,
            max_len: ray_direction.norm(),
            groups: Default::default(),
            sort_results: true,
        },
        &amp;mut buffer,
    );

    buffer
}
<span class="boring">}</span></code></pre></pre>
<p>The function above will return a collection of intersections that are sorted by intersection distance (a distance from
beginning of the ray to an intersection point). Each intersection is represented by the following structure:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::{
</span><span class="boring">        algebra::{Point3, Vector3},
</span><span class="boring">        pool::Handle,
</span><span class="boring">    },
</span><span class="boring">    scene::{graph::physics::FeatureId, node::Node},
</span><span class="boring">};
</span>pub struct Intersection {
    pub collider: Handle&lt;Node&gt;,
    pub normal: Vector3&lt;f32&gt;,
    pub position: Point3&lt;f32&gt;,
    pub feature: FeatureId,
    pub toi: f32,
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li><code>collider</code> - a handle of the collider with which intersection was detected. To obtain a handle to rigid body, borrow
the <code>collider</code> and fetch its <code>parent</code> field: <code>graph[collider].parent()</code>.</li>
<li><code>normal</code> - a normal at the intersection position in world coordinates.</li>
<li><code>position</code> - a position of the intersection in world coordinates.</li>
<li><code>feature</code> - additional data that contains a kind of the feature with which intersection was detected as well as its
index. FeatureId::Face might have index that is greater than amount of triangles in a triangle mesh, this means that 
intersection was detected from &quot;back&quot; side of a face. To &quot;fix&quot; that index, simply subtract amount of triangles of a 
triangle mesh from the value.</li>
<li><code>toi</code> - (<code>time of impact</code>) a distance from ray's origin to <code>position</code>.</li>
</ul>
<h2 id="avoiding-unnecessary-allocations"><a class="header" href="#avoiding-unnecessary-allocations">Avoiding unnecessary allocations</a></h2>
<p>As you might've noticed, the function above return <code>Vec&lt;Intersection&gt;</code> which allocates intersections on heap. This is
relatively slow and could be sped up a lot by using static array on stack:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::{
</span><span class="boring">        algebra::{Point3, Vector3},
</span><span class="boring">        arrayvec::ArrayVec,
</span><span class="boring">    },
</span><span class="boring">    scene::graph::{
</span><span class="boring">        physics::{Intersection, RayCastOptions},
</span><span class="boring">        Graph,
</span><span class="boring">    },
</span><span class="boring">};
</span><span class="boring">
</span>fn do_static_ray_cast&lt;const N: usize&gt;(
    graph: &amp;mut Graph,
    begin: Vector3&lt;f32&gt;,
    end: Vector3&lt;f32&gt;,
) -&gt; ArrayVec&lt;Intersection, N&gt; {
    let mut buffer = ArrayVec::&lt;Intersection, N&gt;::new();

    let ray_direction = end - begin;

    graph.physics.cast_ray(
        RayCastOptions {
            ray_origin: Point3::from(begin),
            ray_direction,
            max_len: ray_direction.norm(),
            groups: Default::default(),
            sort_results: true,
        },
        &amp;mut buffer,
    );

    buffer
}

fn usage_example(graph: &amp;mut Graph, begin: Vector3&lt;f32&gt;, end: Vector3&lt;f32&gt;) {
    // Fetch first 32 intersections.
    dbg!(do_static_ray_cast::&lt;32&gt;(graph, begin, end));
}
<span class="boring">}</span></code></pre></pre>
<p><code>usage_example</code> shows how to use the <code>do_static_ray_cast</code> function - all you need to do is to specify maximum amount of
intersections you're interested in as a generic parameter.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sound-system"><a class="header" href="#sound-system">Sound System</a></h1>
<p>Fyrox has quite powerful and flexible audio system which will be covered in this chapter. Basic &quot;building blocks&quot; are
sound sources, sound buffers, audio processing buses with various sound effects, sound context. Read the next chapters 
to learn more.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="audio-bus"><a class="header" href="#audio-bus">Audio Bus</a></h1>
<p>Audio bus is an audio processing unit that takes audio samples from any number of sound sources and passes them through
a chain of effects (zero or more). Processed samples then can be either sent to an audio playback device (speakers, 
headphones, etc.) or to some other audio bus. There's always one audio bus (primary) that sends its data to an audio playback 
device, every other audio buses are considered secondary.</p>
<h2 id="graph-1"><a class="header" href="#graph-1">Graph</a></h2>
<p>As stated above, any audio bus (except primary), can output its audio samples to some other audio bus (primary or secondary).
Such relationship forms an audio bus graph:</p>
<p><img src="fyrox/sound/data_flow_diagram.png" alt="data flow diagram" /></p>
<p>As you can see, there can be any number of sound sources which attached to the respective audio buses. Each audio bus
can have any number of effects (such as lowpass, highpass, etc. filtering; reverb effect and more). Finally, each audio
bus is connected to some other audio bus.</p>
<p>Such complex audio processing structure allows you to create pretty much any sound environment. For example, you can
create an audio bus with a reverb effect, that will represent a huge hangar with lots of echoes. Then you attach all
sound sources located in this &quot;hangar&quot; to the audio bus and your sound sources will sound more naturally, according
to environment. </p>
<h2 id="effects"><a class="header" href="#effects">Effects</a></h2>
<p>Audio bus can have zero or more audio processing effects. The effects applied one after another (see the arrows on the
picture above). You can set any of the following effects:</p>
<ul>
<li><strong>Attenuation</strong> - changes &quot;volume&quot; of input sound samples.</li>
<li><strong>Reverb</strong> - adds echoes, early and late reflections. Could be used to simulate environment with high reflectivity (hangars,
parking lots, etc.)</li>
<li><strong>Low Pass Filter</strong> - passes all frequencies below the specified cut-off frequency.</li>
<li><strong>High Pass Filter</strong> - passes all frequencies above the specified cut-off frequency.</li>
<li><strong>Band Pass Filter</strong> - passes all frequencies in a given range around the specified cut-off frequency.</li>
<li><strong>All Pass Filter</strong> - shifts phase of the signal by 90 degrees at the specified cut-off frequency. </li>
<li><strong>Low Shelf Filter</strong> - reduces amplitude of frequencies in a shape like this ̅ _ at the cutoff frequency.</li>
<li><strong>High Shelf Filter</strong> - reduces amplitude of frequencies in a shape like this _/̅  at the cutoff frequency.</li>
</ul>
<h2 id="editor-1"><a class="header" href="#editor-1">Editor</a></h2>
<p>In the editor, audio bus graph is located in the Audio Context panel:</p>
<p><img src="fyrox/sound/audio_context.png" alt="audio context" /></p>
<p>Primary audio bus is located at the left of the panel, every other audio bus is located to the right. Each audio bus
(except primary) has a dropdown list (at the bottom), that specifies output audio bus. The list of effect is located 
in the center; it can be edited in the Inspector (right side of the image).</p>
<p>To attach a sound source to an audio bus, select in the scene and find <code>Audio Bus</code> property in the Inspector and set it
to the name of desired audio bus.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sound"><a class="header" href="#sound">Sound</a></h1>
<p>In Fyrox, sounds are nodes of type <code>Sound</code>, with all the consequent properties and workflows.</p>
<h2 id="how-to-create-12"><a class="header" href="#how-to-create-12">How to create</a></h2>
<p>Audio files are loaded using the resource manager:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{engine::Engine, scene::Scene, scene::sound::SoundBuffer};
</span><span class="boring">fn build_node(engine: Engine, scene: &amp;mut Scene) {
</span>let sound = engine
    .resource_manager
    .request::&lt;SoundBuffer, _&gt;(&quot;/path/to/resource.ogg&quot;);
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>Then, the node is built using the standard builder pattern:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    engine::Engine,
</span><span class="boring">    scene::{
</span><span class="boring">        base::BaseBuilder,
</span><span class="boring">        sound::{SoundBuilder, Status, SoundBuffer},
</span><span class="boring">        Scene,
</span><span class="boring">    },
</span><span class="boring">};
</span><span class="boring">fn build_node(engine: Engine, scene: &amp;mut Scene) {
</span><span class="boring">let sound = engine
</span><span class="boring">    .resource_manager
</span><span class="boring">    .request::&lt;SoundBuffer, _&gt;(&quot;/path/to/resource.ogg&quot;);
</span><span class="boring">
</span>let sound_handle = SoundBuilder::new(BaseBuilder::new())
    .with_buffer(Some(sound))
    .with_status(Status::Playing)
    .with_play_once(true)
    .build(&amp;mut scene.graph);
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>There are a few notable things in the example above.</p>
<p>The first is that sounds don't play automatically; in order to do so, we need to invoke <code>.with_status(Status::Playing)</code>.</p>
<p>The second is that sound nodes are not dropped automatically after playback; dropping it can be performed in two ways. 
One way is to use the convenient builder API <code>.with_play_once(true)</code>; another is to use the graph APIs:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    engine::Engine,
</span><span class="boring">    scene::{
</span><span class="boring">        base::BaseBuilder,
</span><span class="boring">        sound::{SoundBuilder, Status},
</span><span class="boring">        Scene,
</span><span class="boring">    },
</span><span class="boring">};
</span><span class="boring">fn build_node(engine: Engine, scene: &amp;mut Scene) {
</span>let sound_handle = SoundBuilder::new(BaseBuilder::new()).build(&amp;mut scene.graph);

let sound = scene.graph[sound_handle].as_sound();

if sound.status() == Status::Stopped {
    scene.graph.remove_node(sound_handle);
}
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>If we want to play background music (or anyway a repeated sound), we just set the <code>looping</code> property when building the node:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    engine::Engine,
</span><span class="boring">    scene::{base::BaseBuilder, sound::SoundBuilder, Scene},
</span><span class="boring">};
</span><span class="boring">fn build_node(engine: Engine, scene: &amp;mut Scene) {
</span>SoundBuilder::new(BaseBuilder::new())
    .with_looping(true)
    // etc.
    .build(&amp;mut scene.graph);
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>In order to stream large audio files, instead of loading them entirely in memory, the simplest strategy is to create a 
corresponding <code>.options</code> file, with the following content:</p>
<pre><code class="language-ron">(
  stream: true
)
</code></pre>
<p>If the audio file is called, for example, <code>/path/to/background.ogg</code>, call this <code>/path/to/background.ogg.options</code>.</p>
<h2 id="audio-bus-1"><a class="header" href="#audio-bus-1">Audio bus</a></h2>
<p>It is possible to specify target audio bus to which the sound will output its audio samples. Audio bus is responsible
for various audio processing, such as filtering, reverb, etc. To specify output audio bus, just use the <code>set_audio_bus</code>
method and set the name of an audio bus.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="head-related-transfer-function"><a class="header" href="#head-related-transfer-function">Head Related Transfer Function</a></h1>
<p>Head Related Transfer Function (HRTF for short) is special audio processing technique that improves audio spatialization.
By default, sound spatialization is very simple - volume of each audio channel (left and right) changes accordingly to
orientation of the listener. While this simple and fast, it does not provide good audio spatialization - sometimes
it is hard to tell from which direction the actual sound is coming from. To solve this issue, we can use head-related
transfer function. Despite its scary, mathematical name, it is easy to understand what it's doing. Instead of uniformly
changing volume of all frequencies of the signal (as the naive spatialization does), it changes them separately for 
each channel. The exact &quot;gains&quot; of each frequency of each channel is depends on the contents of head-related transfer
function. This is done for each azimuth and elevation angles, which gives full picture of how audio signal from each
direction travels to each ear.</p>
<p>HRTF is usually recorded using a head model with ears with a microphone inside each ear. To capture head-related impulse
response (time domain) at a fixed distance and angle pair (azimuth and elevation), a very short impulse of sound is produced. 
Microphones inside each ear records the signal, and then HRIR (time domain) can be converted in HRTF (frequency domain).</p>
<h2 id="hrtf-on-practice"><a class="header" href="#hrtf-on-practice">HRTF on practice</a></h2>
<p>The theory above could be boring, however it is very simple to use HRTF on practice. Pick a HRIR sphere from the 
<a href="https://github.com/mrDIMAS/hrir_sphere_builder/tree/master/hrtf_base/IRCAM">database</a> (any of *.bin files) and load
it in the Audio Context panel:</p>
<p><img src="fyrox/sound/hrtf.png" alt="hrtf" /></p>
<p>Once it is loaded, all sounds in the scene will use the HRTF for rendering. The same can be achieved by code:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::scene::{
</span><span class="boring">    graph::Graph,
</span><span class="boring">    sound::{self, HrirSphere, HrtfRenderer, Renderer},
</span><span class="boring">};
</span><span class="boring">
</span>fn use_hrtf(graph: &amp;mut Graph) {
    let hrir_sphere = HrirSphere::from_file(&quot;path/to/hrir.bin&quot;, sound::SAMPLE_RATE).unwrap();
    graph
        .sound_context
        .state()
        .set_renderer(Renderer::HrtfRenderer(HrtfRenderer::new(hrir_sphere)));
}
<span class="boring">}</span></code></pre></pre>
<h2 id="performance-7"><a class="header" href="#performance-7">Performance</a></h2>
<p>HRTF is heavy. It is 5-6 times slower than the simple spatialization, so use it only on middle-end or high-end hardware.
HRTF performance is linearly dependent on the amount of sound sources: the more sound sources use HRTF, the worse performance
will be and vice versa.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="animation-1"><a class="header" href="#animation-1">Animation</a></h1>
<p>Animation allows you to change properties of scene nodes at runtime using a set of key frames. Animation
consists of multiple tracks, where each track is bound to a property of a scene node. A track can animate
any numeric properties, starting from numbers (including <code>bool</code>) end ending by 2/3/4 dimensional vectors.
Each component (number, x/y/z/w vector components) is stored in a <em>parametric curve</em> (see
[<code>crate::core::curve::Curve</code>] docs for more info). Every parametric curve contains zero or more <em>key frames</em>.
Graphically this could be represented like so:</p>
<pre><code class="language-text">                                         Timeline
                                            v
  Time   &gt; |---------------|------------------------------------&gt;
           |               |
  Track1 &gt; | node.position |                                     
           |   X curve     |..1..........5...........10..........
           |   Y curve     |..2.........-2..................1....  &lt; Curve key frames
           |   Z curve     |..1..........9......................4
           |_______________|  
  Track2   | node.property |                                  
           | ............  |.....................................
           | ............  |.....................................
           | ............  |.....................................
</code></pre>
<p>Each key frame is just a real number with interpolation mode. Interpolation mode tells the engine how to
calculate intermediate values between key frames. There are three kinds of interpolation used in animations
(you can skip &quot;boring math&quot; if you want):</p>
<ul>
<li><strong>Constant</strong> - intermediate value will be calculated using leftmost value of two. Constant &quot;interpolation&quot; is
usually used to create step-like behaviour, the most common case is to &quot;interpolate&quot; two boolean values.</li>
<li><strong>Linear</strong> - intermediate value will be calculated using linear interpolation <code>i = left + (right - left) / t</code>,
where <code>t = (time_position - left) / (right - left)</code>. <code>t</code> is always in <code>0..1</code> range. Linear interpolation is usually
used to create &quot;straight&quot; transitions between two values.</li>
<li><strong>Cubic</strong> - intermediate value will be calculated using Hermite cubic spline:
<code>i = (2t^3 - 3t^2 + 1) * left + (t^3 - 2t^2 + t) * left_tangent + (-2t^3 + 3t^2) * right + (t^3 - t^2) * right_tangent</code>,
where <code>t = (time_position - left) / (right - left)</code> (<code>t</code> is always in <code>0..1</code> range), <code>left_tangent</code> and <code>right_tangent</code>
is usually a <code>tan(angle)</code>. Cubic interpolation is usually used to create &quot;smooth&quot; transitions between two values.</li>
</ul>
<h2 id="track-binding"><a class="header" href="#track-binding">Track binding</a></h2>
<p>Each track is always bound to a property in a node, either by its name or by a special binding. The name is used to fetch the
property using reflection, the special binding is a faster way of fetching built-in properties. It is usually used to animate
position, scale and rotation (these are the most common properties available in every scene node).</p>
<h2 id="time-slice-and-looping"><a class="header" href="#time-slice-and-looping">Time slice and looping</a></h2>
<p>While key frames on the curves can be located at arbitrary position in time, animations usually plays a specific time slice.
By default, each animation will play on a given time slice infinitely - it is called <em>animation looping</em>, it works in both
playback directions.</p>
<h2 id="speed"><a class="header" href="#speed">Speed</a></h2>
<p>You can vary playback speed in wide range, by default every animation has playback speed multiplier set to 1.0. The multiplier
tells how faster (&gt;1) or slower (&lt;1) the animation needs to be played. Negative speed multiplier values will reverse playback.</p>
<h2 id="enabling-or-disabling-animations"><a class="header" href="#enabling-or-disabling-animations">Enabling or disabling animations</a></h2>
<p>Sometimes there's a need to disable/enable an animation or check if it is enabled or not, you can do this by using the pair
of respective methods - [<code>Animation::set_enabled</code>] and [<code>Animation::is_enabled</code>].</p>
<h2 id="signals"><a class="header" href="#signals">Signals</a></h2>
<p>Signal is a named marker on specific time position on the animation timeline. Signal will emit an event if the animation playback
time passes signal's position from left-to-right (or vice versa depending on playback direction). Signals are usually used to
attach some specific actions to a position in time. For example, you can have a walking animation and you want to emit sounds
when character's feet touch ground. In this case you need to add a few signals at times when each foot touches the ground.
After that all you need to do is to fetch animation events one-by-one and emit respective sounds. See [<code>AnimationSignal</code>] docs
for more info and examples.</p>
<h2 id="creating-from-code"><a class="header" href="#creating-from-code">Creating From Code</a></h2>
<p>Usually, animations are created from the editor or some external tool and then imported in the engine. Before trying the example
below, please read the docs for [<code>crate::scene::animation::AnimationPlayer</code>] node, it is much more convenient way of animating
other nodes. The node can be created from the editor and you don't even need to write any code.
Use the following example code as a guide <strong>only</strong> if you need to create procedural animations:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    animation::{
</span><span class="boring">        container::{TrackDataContainer, TrackValueKind},
</span><span class="boring">        track::Track,
</span><span class="boring">        value::ValueBinding,
</span><span class="boring">        Animation,
</span><span class="boring">    },
</span><span class="boring">    core::{
</span><span class="boring">        curve::{Curve, CurveKey, CurveKeyKind},
</span><span class="boring">        pool::Handle,
</span><span class="boring">    },
</span><span class="boring">    scene::{
</span><span class="boring">        node::Node,
</span><span class="boring">        base::BaseBuilder,
</span><span class="boring">        graph::Graph,
</span><span class="boring">        pivot::PivotBuilder
</span><span class="boring">    }
</span><span class="boring">};
</span>fn create_animation(node: Handle&lt;Node&gt;) -&gt; Animation {
    let mut frames_container = TrackDataContainer::new(TrackValueKind::Vector3);
    // We'll animate only X coordinate (at index 0).
    frames_container.curves_mut()[0] = Curve::from(vec![
        CurveKey::new(0.5, 2.0, CurveKeyKind::Linear),
        CurveKey::new(0.75, 1.0, CurveKeyKind::Linear),
        CurveKey::new(1.0, 3.0, CurveKeyKind::Linear),
    ]);
    // Create a track that will animated the node using the curve above.
    let mut track = Track::new(frames_container, ValueBinding::Position);
    track.set_target(node);
    // Finally create an animation and set its time slice and turn it on.
    let mut animation = Animation::default();
    animation.add_track(track);
    animation.set_time_slice(0.0..1.0);
    animation.set_enabled(true);
    animation
}
// Create a graph with a node.
let mut graph = Graph::new();
let some_node = PivotBuilder::new(BaseBuilder::new()).build(&amp;mut graph);
// Create the animation.
let mut animation = create_animation(some_node);
// Emulate some ticks (like it was updated from the main loop of your game).
for _ in 0..10 {
    animation.tick(1.0 / 60.0);
    animation.pose().apply(&amp;mut graph);
}
<span class="boring">}</span></code></pre></pre>
<p>The code above creates a simple animation that moves a node along X axis in various ways. The usage of the animation
is only for the sake of completeness of the example. In the real games you need to add the animation to an animation
player scene node and it will do the job for you.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="animation-editor"><a class="header" href="#animation-editor">Animation Editor</a></h1>
<p><img src="fyrox/animation/./anim_editor.png" alt="anim editor" /></p>
<p>Animation Editor is a tool that helps you to create and preview animations. This is a powerful tool that can be used
to animated pretty much any numeric property. It has three main parts:</p>
<ol>
<li><code>Toolbar</code> - contains a set of tools that changes a particular part of an animation (name, length, speed, etc.)</li>
<li><code>Track List</code> - contains a list of tracks of nodes that will be animated.</li>
<li><code>Curve Editor</code> - curve editor allows you to edit behaviour of a numeric parameter over the time. </li>
</ol>
<p>The editor can be opened in two ways - using <code>Utils -&gt; Animation Editor</code> or by selecting an animation player node and
clicking <code>Open Animation Editor</code> button in the inspector.</p>
<p><img src="fyrox/animation/./ae_open1.png" alt="open1" /></p>
<p><img src="fyrox/animation/./ae_open2.png" alt="open2" /></p>
<p>In both ways you still need to select an animation player for editing.</p>
<h2 id="toolbar"><a class="header" href="#toolbar">Toolbar</a></h2>
<p>The toolbar contains a set of tools that changes a particular part of an animation (name, length, speed, etc.). It looks
like this:</p>
<p><img src="fyrox/animation/./ae_toolbar.png" alt="toolbar" /></p>
<ol>
<li><code>Animation Name</code> - name of a currently selected animation.</li>
<li><code>Add Animation</code> - adds a new empty animation with the name from the text box at the left to the animation player. </li>
<li><code>Import Animation</code> - starts animation importing process. See <a href="fyrox/animation/anim_editor.html#animation-importing">Animation Importing</a> section
for more info.</li>
<li><code>Rename Animation</code> - renames a currently selected animation using the name from the text box at the left.</li>
<li><code>Animation Selector</code> - allows you to switch currently edited animation.</li>
<li><code>Delete Animation</code> - deletes a currently selected animation, tries to select last animation from the list if possible.</li>
<li><code>Duplicate Animation</code> - clones a currently selected animation.</li>
<li><code>Loop Animation</code> - enables or disables looping of a currently selected animation.</li>
<li><code>Enable Animation</code> - enables or disables a currently selected animation.</li>
<li><code>Animation Speed</code> - sets a new playback speed of a currently selected animation.</li>
<li><code>Time Slice</code> - a time range (in seconds) which defines start and end time of a currently selected animation.</li>
<li><code>Preview Switch</code> - enables or disables animation preview. See <a href="fyrox/animation/anim_editor.html#preview-mode"><code>Preview Mode</code></a> section for more info.</li>
<li><code>Play/Pause</code> - plays or pauses a currently selected animation (allowed only in the preview mode).</li>
<li><code>Stop</code> - stops a currently selected animation (allowed only in the preview mode).</li>
</ol>
<h2 id="track-list"><a class="header" href="#track-list">Track List</a></h2>
<p>The track list contains a list of tracks of nodes that will be animated. It looks like this:</p>
<p><img src="fyrox/animation/./ae_track_list.png" alt="track list" /></p>
<ol>
<li><code>Filter Bar</code> - filters the track list by finding tracks whose names matching the filter. You can use this to find
tracks that belong to a particular scene node.</li>
<li><code>Clear Filter</code> - clears the filter, the track list will show all the tracks after this.</li>
<li><code>Collapse All</code> - collapses all the tracks in the list.</li>
<li><code>Expand All</code> - expands all the tracks in the list.</li>
<li><code>Track</code> - a track with some number of children parametric curves.</li>
<li><code>Track Component Curve</code> - parametric curve that serves a data source for the animation for a particular track.</li>
<li><code>Track Switch</code> - enables or disables a track; disabled tracks won't &quot;touch&quot; their properties.</li>
<li><code>Add Track</code> - starts property binding process, see <a href="fyrox/animation/anim_editor.html#property-binding">Property Binding</a> section for more info.</li>
</ol>
<h3 id="track-context-menu"><a class="header" href="#track-context-menu">Track Context Menu</a></h3>
<p><img src="fyrox/animation/./ae_track_context_menu.png" alt="context menu" /></p>
<ul>
<li><code>Remove Selected Tracks</code> - removes selected tracks; you can remove multiple tracks at a time by selecting them while
holding <code>Ctrl</code>.</li>
</ul>
<h2 id="curve-editor"><a class="header" href="#curve-editor">Curve Editor</a></h2>
<p>Curve editor allows you to edit parametric curves (one at a time). A curve consists of zero or more key frames with 
various transition rules between current and the next. The editor looks like this:</p>
<p><img src="fyrox/animation/./ae_curve_editor.png" alt="curve editor" /></p>
<ol>
<li><code>Time Ruler</code> - shows time values and every signal of a currently selected animation. A click on the time ruler will
move the playback cursor at the click position. You can move it by clicking at the cursor and moving the mouse while 
holding the left mouse button. Animation signals can be moved in the same fashion.</li>
<li><code>Parametric Curve</code> - a curve that defines how a value changes over time.</li>
<li><code>Time Thumb</code> - animation playback cursor, useful only for preview.</li>
<li><code>Animation Signal</code> - some animation signal that will produce animation events when the playback cursor passes it. </li>
</ol>
<h3 id="time-ruler-context-menu"><a class="header" href="#time-ruler-context-menu">Time Ruler Context Menu</a></h3>
<p><img src="fyrox/animation/./ae_time_ruler_context_menu.png" alt="time ruler context menu" /></p>
<ul>
<li><code>Remove Signal</code> - removes an animation signal under the mouse cursor.</li>
<li><code>Add Signal</code> - adds a new animation signal at the mouse cursor position.</li>
</ul>
<h3 id="key-frame-context-menu"><a class="header" href="#key-frame-context-menu">Key Frame Context Menu</a></h3>
<p><img src="fyrox/animation/./ae_key_frame_context_menu.png" alt="key frame context menu" /></p>
<ul>
<li><code>Location</code> - shows a key location and allows you to change it. Useful for setting precise values. </li>
<li><code>Value</code> - shows a key value and allows you to change it. Useful for setting precise values.</li>
<li><code>Add Key</code> - adds a new key to the curve.</li>
<li><code>Remove</code> - removes all selected keys. You can select multiple keys either by box selection (click and drag the mouse
to active box selection) or by clicking on separate keys while holding <code>Ctrl</code>.</li>
<li><code>Key...</code> - allows you to change the interpolation type of key. It could be one of the following values: Constant, Linear,
Cubic.</li>
<li><code>Zoom To Fit</code> - tries to find zooming values (for both axes) and the view position with which the entire curve fits in
the viewport.</li>
</ul>
<h2 id="property-binding"><a class="header" href="#property-binding">Property Binding</a></h2>
<p>To animate a property all you need to do is to click on <code>Add Track...</code> button at the bottom of the track list, select
a node to animate and then select a property that will be animated. There are two windows that will be shown one after
another:</p>
<p><img src="fyrox/animation/./ae_add_track_select_node.png" alt="step1" /></p>
<p><img src="fyrox/animation/./ae_add_track_select_property.png" alt="step2" /></p>
<p>You can cancel property binding at any time by clicking <code>Cancel</code> in any of the windows. Keep in mind that you can animate
only numeric properties, so not every property is shown in the window.</p>
<h2 id="animation-importing"><a class="header" href="#animation-importing">Animation Importing</a></h2>
<p>Animations can be stored in separate files, but the engine requires all of them to be in a single Animation Player. To
put an animation from an external resource (an FBX, for instance) in the animation player you can use animation 
importing. To do that, click on animation import icon and then select a root node of the hierarchy that is animated in
the external animation file, then select the animation file and click <code>Ok</code>. The engine will try to import the animation
and map it to the given hierarchy, mapping is done using node names, so animated node names must match in both your 
scene and your external animation file. </p>
<p><img src="fyrox/animation/./ae_import_select_target_node.png" alt="step1" /></p>
<p><img src="fyrox/animation/./ae_import_select_animation.png" alt="step2" /></p>
<h2 id="preview-mode"><a class="header" href="#preview-mode">Preview Mode</a></h2>
<p>Preview mode helps you to see and debug your animation. After activating the mode, you need to play the animation by
clicking the <code>Play/Pause</code> button:</p>
<p><img src="fyrox/animation/./anim_editor.gif" alt="anim editor" /></p>
<p>Any significant change made in the scene will automatically deactivate the preview mode reverting all the changes made
by playing animation.</p>
<h2 id="limitations-4"><a class="header" href="#limitations-4">Limitations</a></h2>
<p>For now there's no dopesheet mode in the editor, you can edit only one numeric parameter at a time. Also, there's no 
capture mode - this is a special mode in which the editor automatically adds your changes in the scene to the animation.
These limitations will be removed in the future versions.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="animation-blending"><a class="header" href="#animation-blending">Animation Blending</a></h1>
<p>Animation blending is a powerful feature that allows you to mix multiple animations into one. Each animation
is mixed with a various weights which in sum gives 1.0 (100%). By having opposite coefficients (k1 = 0 -&gt; 1, k2 = 1 -&gt; 0)
changing in time it is possible to create transition effect. </p>
<p>Handling transitions with all the coefficients is a routine job, the engine can handle it for you giving you some nice
features:</p>
<ul>
<li>Multiple states with smooth transitions between them</li>
<li>Ability to blend multiple animations in one and use it as pose source for blending</li>
<li>Ability to specify a set of variables that will be used as blending coefficients and transition rules.</li>
</ul>
<p>All these features consolidated in so-called animation blending state machine (ABSM). Machine is used to blend multiple 
animation as well as perform automatic &quot;smooth&quot; transition between states. Let's have a quick look at a simple machine
graph:</p>
<pre><code class="language-text">                                                 +-------------+
                                                 |  Idle Anim  |
                                                 +------+------+
                                                        |
          Walk Weight                                   |
+-----------+      +-------+           Walk-&gt;Idle Rule  |
| Walk Anim +------+       |                            |
+-----------+      |       |      +-------+         +---+---+
                   | Blend |      |       +--------&gt;+       |
                   |       +------+ Walk  |         |  Idle |
+-----------+      |       |      |       +&lt;--------+       |
| Aim Anim  +------+       |      +--+----+         +---+---+
+-----------+      +-------+         |                  ^
          Aim Weight                 | Idle-&gt;Walk Rule  |
                                     |                  |
                      Walk-&gt;Run Rule |    +---------+   | Run-&gt;Idle Rule
                                     |    |         |   |
                                     +---&gt;+   Run   +---+
                                          |         |
                                          +----+----+
                                               |
                                               |
                                        +------+------+
                                        |  Run Anim   |
                                        +-------------+
</code></pre>
<p>Here we have Walk, Idle and Run states which use different sources of poses:</p>
<ul>
<li>Walk - is the most complicated here - it uses result of blending between <code>Aim</code> and <code>Walk</code> animations with different 
weights. This is useful if your character can only walk or can walk <em>and</em> aim at the same time. Desired pose determined
by Walk Weight and Aim Weight parameters combination.</li>
<li>Run and idle both directly use animation as pose source.</li>
</ul>
<p>There are four transitions between three states each with its own rule. Rule is just a boolean parameter that indicates 
that transition should be activated. Let's look at the code example of the above state graph:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span>use fyrox::{
  animation::machine::{
      Machine, State, Transition, PoseNode, node::blend::BlendPose,
      Parameter, PlayAnimation, PoseWeight, node::blend::BlendAnimations
  },
  core::pool::Handle
};

// Assume that these are correct handles.
let idle_animation = Handle::default();
let walk_animation = Handle::default();
let aim_animation = Handle::default();

let mut machine = Machine::new();

let root_layer = machine.layers_mut().first_mut().unwrap();

let aim = root_layer.add_node(PoseNode::PlayAnimation(PlayAnimation::new(aim_animation)));
let walk = root_layer.add_node(PoseNode::PlayAnimation(PlayAnimation::new(walk_animation)));

// Blend two animations together
let blend_aim_walk = root_layer.add_node(PoseNode::BlendAnimations(
  BlendAnimations::new(vec![
      BlendPose::new(PoseWeight::Constant(0.75), aim),
      BlendPose::new(PoseWeight::Constant(0.25), walk)
  ])
));

let walk_state = root_layer.add_state(State::new(&quot;Walk&quot;, blend_aim_walk));

let idle = root_layer.add_node(PoseNode::PlayAnimation(PlayAnimation::new(idle_animation)));
let idle_state = root_layer.add_state(State::new(&quot;Idle&quot;, idle));

root_layer.add_transition(Transition::new(&quot;Walk-&gt;Idle&quot;, walk_state, idle_state, 1.0, &quot;WalkToIdle&quot;));
root_layer.add_transition(Transition::new(&quot;Idle-&gt;Walk&quot;, idle_state, walk_state, 1.0, &quot;IdleToWalk&quot;));
<span class="boring">}</span></code></pre></pre>
<p>As you can see, everything is quite straightforward. Even such simple state machine requires quite a lot of code, which
can be removed by using ABSM editor. Read the next chapter to learn about it.</p>
<h2 id="multiple-absm-per-model"><a class="header" href="#multiple-absm-per-model">Multiple ABSM per model</a></h2>
<p>You can use multiple machines to animate single model - for example one machine can be used for locomotion and other for 
combat. This means that locomotion machine will take control over lower body and combat machine will control upper body.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="animation-blending-state-machine-absm-editor"><a class="header" href="#animation-blending-state-machine-absm-editor">Animation Blending State Machine (ABSM) Editor</a></h1>
<p>While it is possible to create and manage animation blending and state manually from code, it quickly becomes too 
annoying and hardly manageable. To help you create and manage blending machines in easy way, the engine offers 
an ABSM Editor tool. This chapter is an overview of the editor, it is quite complex, but the guide should help you
to figure out which part is made for what. Next chapter will help you to create your first animation blending state
machine.</p>
<p><img src="fyrox/animation/./absm.png" alt="absm editor" /></p>
<p>The editor has four main parts (panels):</p>
<ol>
<li><code>Toolbar</code> - contains a set of tools to edit animation layers and enable/disable preview mode. See <a href="fyrox/animation/absm_editor.html#toolbar">Toolbar</a>
section for more info.</li>
<li><code>Parameters</code> - allows you to edit various variables that are responsible for transitions, weight parameters for 
blending, etc. See <a href="fyrox/animation/./absm_parameters.png">Parameters</a> section for more info.</li>
<li><code>State Graph</code> - allows you to create, delete, edit states and transition between them. See <a href="fyrox/animation/absm_editor.html#state-graph">State Graph</a>
section for more info.</li>
<li><code>State Viewer</code> - allows you to edit pose source for a state. Pose source can be represented either by a single 
node that plays an animation, or a series of play animation nodes connected to blending nodes (which can be connected
to other blending nodes, etc.). See <a href="fyrox/animation/absm_editor.html#state-viewer">State Viewer</a> section for more info.</li>
</ol>
<p>The editor can be opened in two ways - using <code>Utils -&gt; ABSM Editor</code> or by selecting an animation blending state machine
node and clicking <code>Open ABSM Editor...</code> button:</p>
<p><img src="fyrox/animation/./absm_open1.png" alt="open1" /></p>
<p><img src="fyrox/animation/./absm_open2.png" alt="open1" /></p>
<p>In both ways you still need to select an an animation blending state machine node for editing.</p>
<h2 id="toolbar-1"><a class="header" href="#toolbar-1">Toolbar</a></h2>
<p><img src="fyrox/animation/./absm_toolbar.png" alt="toolbar" /></p>
<ol>
<li><code>Preview Switch</code> - enables or disables preview mode for the ABSM. See <a href="fyrox/animation/absm_editor.html#preview-mode">Preview Mode</a> section for more
info.</li>
<li><code>Layer Name</code> - name of the selected layer. Type a new name here to rename currently selected layer (hit enter or just
click elsewhere to rename).</li>
<li><code>Add Layer</code> - adds a new layer with the name in the <code>Layer Name</code> text box to the ABSM. ABSM can have multiple layers
with the same name, but it strongly advised to set unique names here.</li>
<li><code>Remove Current Layer</code> - removes currently selected layer. You can delete all layers, but in this case your ABSM won't
have any effect.</li>
<li><code>Layer Selector</code> - allows you to select a layer for editing, default selection is none.</li>
<li><code>Layer Mask</code> - opens a <code>Layer Mask Editor</code> and helps you to edit the layer mask of the current layer. See 
<a href="fyrox/animation/absm_editor.html#layer-mask">Layer Mask</a> section for more info.</li>
</ol>
<h2 id="parameters"><a class="header" href="#parameters">Parameters</a></h2>
<p>Parameter is a named and typed variable that provides the animation system with some data required for it to work. There
are only three type of parameters:</p>
<ul>
<li><code>Rule</code> - boolean value that used as a trigger for transitions. When transition is using some rule, it checks the value
of the parameter and if it is <code>true</code> transition starts.</li>
<li><code>Weight</code> - real number (<code>f32</code>) that is used a weight when you're blending multiple animations into one.</li>
<li><code>Index</code> - natural number (<code>i32</code>) that is used as an animation selector.</li>
</ul>
<p><img src="fyrox/animation/./absm_parameters.png" alt="parameters" /></p>
<ol>
<li><code>Add Parameters</code> - adds a new parameter to the parameters' container.</li>
<li><code>Remove a Parameter</code> - removes selected parameter from the parameters' container.</li>
<li><code>Parameter Name</code> - allows you to set a parameter name.</li>
<li><code>Parameter Type</code> - allows you to select the type of the parameter.</li>
<li><code>Parameter Value</code> - allows you to set parameter value.</li>
</ol>
<h2 id="state-graph"><a class="header" href="#state-graph">State Graph</a></h2>
<p>State Graph allows you to create states and transitions between them. </p>
<p><img src="fyrox/animation/./absm_state_graph.png" alt="state graph" /></p>
<ol>
<li><code>State</code> - state is final animation for a set of scene nodes, only one state can be active at a time.</li>
<li><code>Transition</code> - is an <em>ordered</em> connection between two states, it defines how much time it needed to perform 
blending of two states.</li>
<li><code>Root State</code> - is an entry state of the current layer.</li>
</ol>
<h3 id="state-context-menu"><a class="header" href="#state-context-menu">State Context Menu</a></h3>
<p><img src="fyrox/animation/./absm_state_context_menu.png" alt="state context menu" /></p>
<ul>
<li><code>Create Transition</code> - starts transition creation from the current state to some other.</li>
<li><code>Remove</code> - removes the state.</li>
<li><code>Set As Entry State</code> - marks the state as an entry state (this state will be active at beginning).</li>
</ul>
<h3 id="transition-context-menu"><a class="header" href="#transition-context-menu">Transition Context Menu</a></h3>
<p><img src="fyrox/animation/./absm_transition_context_menu.png" alt="transition context menu" /></p>
<ul>
<li><code>Remove Transition</code> - removes selected transition.</li>
</ul>
<h3 id="state-properties"><a class="header" href="#state-properties">State Properties</a></h3>
<p>Select a <code>State</code> node to edit the following properties:</p>
<p><img src="fyrox/animation/./absm_state_properties.png" alt="state properties" /></p>
<ul>
<li><code>Position</code> - is a location of the state on the canvas.</li>
<li><code>Name</code> - name of the state.</li>
<li><code>Root</code> - handle of the backing animation node inside the state.</li>
</ul>
<h3 id="transition-properties"><a class="header" href="#transition-properties">Transition Properties</a></h3>
<p>Select a <code>Transition</code> node to edit the following properties:</p>
<p><img src="fyrox/animation/./absm_transition_properties.png" alt="transition properties" /></p>
<ul>
<li><code>Name</code> - name of the state.</li>
<li><code>Transition Time</code> - amount of time for blending between two states (in seconds).</li>
<li><code>Elapsed Time</code> - starting amount of blending time.</li>
<li><code>Source</code> - handle of a source state.</li>
<li><code>Desc</code> - handle of a destination state.</li>
<li><code>Rule</code> - a name of <code>Rule</code> type parameter that defines whether the transition can be activated or not.</li>
<li><code>Invert Rule</code> - defines whether to invert the value of <code>Rule</code> or not.</li>
<li><code>Blend Factor</code> - defines a percentage (in <code>0..1</code> range) of how much transition was active. </li>
</ul>
<h2 id="state-viewer"><a class="header" href="#state-viewer">State Viewer</a></h2>
<p>State Viewer allows you to edit contents of states. You can create animation blending chains of any complexity, the
simplest content of a state is just a single <code>Play Animation</code> node. Currently, the engine supports just three animation
blending nodes:</p>
<ul>
<li><code>Play Animation</code> - takes animation pose directly from specified animation, does nothing to it.</li>
<li><code>Blend Animations</code> - takes multiple animation poses from respective animations and blends them together with 
respective blend weights.</li>
<li><code>Blend Animations By Index</code> - takes multiple animation poses from respective animations and switches between them 
with &quot;smooth&quot; transition using an index parameter.</li>
</ul>
<p><img src="fyrox/animation/./absm_state_viewer.png" alt="state viewer" /></p>
<ol>
<li><code>Node</code> - is a source of animation for blending.</li>
<li><code>Connection</code> - defines how nodes are connected to each other. To create a new connection, click on a small dot on a
node, hold the button and start dragging to a dot on some other node. </li>
<li><code>Root Node</code> - root node is marked green; root node is a final source of animation for the parent state. </li>
</ol>
<h3 id="play-animation-properties"><a class="header" href="#play-animation-properties"><code>Play Animation</code> Properties</a></h3>
<p>Select a <code>Play Animation</code> node to edit the following properties:</p>
<p><img src="fyrox/animation/./absm_play_animation_properties.png" alt="play animation properties" /></p>
<ul>
<li><code>Position</code> - is a location of the node on the canvas.</li>
<li><code>Animation</code> - an animation to fetch the pose from.</li>
</ul>
<h3 id="blend-animations-properties"><a class="header" href="#blend-animations-properties"><code>Blend Animations</code> Properties</a></h3>
<p>Select a <code>Blend Animations</code> node to edit the following properties:</p>
<p><img src="fyrox/animation/./absm_blend_animations_properties.png" alt="blend animations properties" /></p>
<ul>
<li><code>Position</code> - is a location of the node on the canvas.</li>
<li><code>Pose Sources</code> - a set of input poses. To add a pose either click on <code>+</code> or <code>+Input</code> on the node itself. Don't forget
to connect some nodes to the new input poses.
<ul>
<li><code>Weight</code> - a weight of the pose; could be either a constant value or some parameter.</li>
</ul>
</li>
</ul>
<h3 id="blend-animations-by-index-properties"><a class="header" href="#blend-animations-by-index-properties"><code>Blend Animations By Index</code> Properties</a></h3>
<p>Select a <code>Blend Animations By Index</code> node to edit the following properties:</p>
<p><img src="fyrox/animation/./absm_blend_animations_by_index_properties.png" alt="blend animations by index properties" /> </p>
<ul>
<li><code>Position</code> - is a location of the node on the canvas.</li>
<li><code>Index Parameter</code> - a name of an indexing parameter (must be <code>Index</code> type).</li>
<li><code>Inputs</code> - a set of input poses. To add a pose either click on <code>+</code> or <code>+Input</code> on the node itself. Don't forget to
connect some nodes to the new input poses.
<ul>
<li><code>Blend Time</code> - defines how much time is needed to transition to the pose.</li>
</ul>
</li>
</ul>
<h3 id="connection-context-menu"><a class="header" href="#connection-context-menu">Connection Context Menu</a></h3>
<p>Every connection has a context menu that can be shown by a right-click on a connection.</p>
<p><img src="fyrox/animation/./absm_connection_context_menu.png" alt="connection context menu" /></p>
<ul>
<li><code>Remove Connection</code> - removes the connection between parent nodes.</li>
</ul>
<h3 id="node-context-menu"><a class="header" href="#node-context-menu">Node Context Menu</a></h3>
<p>Every node has a context menu that can be shown by a right-click on a connection.</p>
<p><img src="fyrox/animation/./absm_node_context_menu.png" alt="node context menu" /></p>
<ul>
<li><code>Set As Root</code> - sets the node as the final pose source of the parent state. </li>
<li><code>Remove</code> - removes the node from the state.</li>
</ul>
<h2 id="layer-mask"><a class="header" href="#layer-mask">Layer Mask</a></h2>
<p><img src="fyrox/animation/./absm_layer_mask.png" alt="layer mask" /></p>
<p>Layer mask editor allows you to select which nodes <strong>won't</strong> be animated by the current animation layer. Selected nodes
are marked with dark color. To select multiple nodes at once, hold <code>Ctrl</code> and click on items. The text box at the top
of the window allows you to search for a particular scene node. To save edited layer mask click <code>OK</code>.</p>
<h2 id="preview-mode-1"><a class="header" href="#preview-mode-1">Preview Mode</a></h2>
<p>Preview mode turns on the animation blending state machine and its animation player and allows you to see the result
of the work of the machine. Any significant changes in the scene automatically disables the preview mode and any
changes done by the machine is discarded. While the preview mode is active, you can freely change the values of the 
parameters to see how the machine will react to this. This helps you to debug your state machine, it is especially 
useful for complex state machines with lots of layers. Here's how the preview mode works:</p>
<p><img src="fyrox/animation/./absm.gif" alt="absm" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="artificial-intelligence-wip"><a class="header" href="#artificial-intelligence-wip">Artificial Intelligence (WIP)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="behaviour-trees-wip"><a class="header" href="#behaviour-trees-wip">Behaviour Trees (WIP)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="path-finding"><a class="header" href="#path-finding">Path Finding</a></h1>
<p>Fyrox has built-in <a href="https://en.wikipedia.org/wiki/A*_search_algorithm">A* (A-star)</a> algorithm for pathfinding. It can be
used to find a path on arbitrary graph without cycles. It could be a simple grid where each point knows about its 
&quot;neighbours&quot;, <a href="fyrox/ai/./navmesh.html">navigational mesh</a>, or some other graph.</p>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<p>The simplest examples could be a search of path on uniform grid. This could be useful for games with open worlds, 
strategies, and any other types of games that uses uniform grid for pathfinding.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span>use fyrox::{
    core::algebra::Vector3,
    utils::astar::{PathFinder, PathVertex},
};

fn astar_on_uniform_grid() {
    // Create vertices.
    let size = 40;
    let mut vertices = Vec::new();
    for y in 0..size {
        for x in 0..size {
            vertices.push(PathVertex::new(Vector3::new(x as f32, y as f32, 0.0)));
        }
    }
    let mut pathfinder = PathFinder::new();
    pathfinder.set_vertices(vertices);

    // Link vertices to form a uniform grid.
    for y in 0..(size - 1) {
        for x in 0..(size - 1) {
            pathfinder.link_bidirect(y * size + x, y * size + x + 1);
            pathfinder.link_bidirect(y * size + x, (y + 1) * size + x);
        }
    }

    // Build a path from vertex 0 to vertex 100.
    let mut path = Vec::new();
    assert!(pathfinder.build(0, 100, &amp;mut path).is_ok());
}
<span class="boring">}</span></code></pre></pre>
<p>Keep in mind, that the returned path is always reversed (its first point corresponds to an <code>end</code> point). You need either
to reverse the path, or (which is much faster) just iterate in reverse over its points. </p>
<h2 id="what-to-use"><a class="header" href="#what-to-use">What to use</a></h2>
<p>A* is very simple, yet powerful algorithm. However, it is not always suitable, because it searches only on graph vertices
and cannot build paths that are lying on a surface of arbitrary meshes. Simple path finding on a uniform grid is ok
for some games (strategies for instance), but in FPS games it will look awful. In this case you should use 
<a href="fyrox/ai/./navmesh.html">navigational meshes</a> which can build path on a surface of arbitrary meshes.</p>
<h2 id="performance-8"><a class="header" href="#performance-8">Performance</a></h2>
<p>Current A* implementation is not ideal and may hurt performance if you need to calculate a lot of paths on large 
graphs. It will be optimized in the future (see <a href="https://github.com/FyroxEngine/Fyrox/issues/442">tracking issue</a> for 
info).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="navigational-meshes"><a class="header" href="#navigational-meshes">Navigational Meshes</a></h1>
<p>Navigational mesh (navmesh for short) is a surface which can be used for path finding. Unlike 
<a href="fyrox/ai/./pathfinding.html">A* Pathfinder</a>, it can build arbitrary paths on a surface of large polygons, making a path from 
point A to point B linear (standard pathfinder builds path only from vertex to vertex). Navmeshes should be used when
you have an arbitrary &quot;walkable&quot; surface, for example, a game level with rooms, hallways, multiple floors and so on. 
A* pathfinder should be used for strategies or any other types of games with uniform pathfinding grid.</p>
<h2 id="editor-2"><a class="header" href="#editor-2">Editor</a></h2>
<p>Navigational meshes can be created and edited in the FyroxEd. At first, create a &quot;Navigational Mesh&quot; node, select it and
switch to &quot;navmesh&quot; interaction mode:</p>
<p><img src="fyrox/ai/./navmesh.png" alt="navmesh" /></p>
<p>Now you can edit the navmesh. For now, editing capabilities are quite limited and the only way to edit the navmesh is
to Shift+Drag one if its edges:</p>
<p><img src="fyrox/ai/./navmesh_edit.gif" alt="navmesh edit" /></p>
<p>You can also delete edges and vertices: select a vertex or an edge and press <code>Delete</code> key. If you need to create closed
loops, use &quot;Connect Edges&quot; button in the &quot;Navmesh&quot; floating panel:</p>
<p><img src="fyrox/ai/./navmesh_connect.png" alt="navmesh connect" /></p>
<h2 id="automatic-generation"><a class="header" href="#automatic-generation">Automatic generation</a></h2>
<p>Fyrox does not support automatic navigational mesh generation yet. You can help by adding such feature.</p>
<h2 id="agents"><a class="header" href="#agents">Agents</a></h2>
<p>Navigational mesh agent helps you to build paths along the surface of a navigational mesh and follow it. Agents can be 
used to drive the motion of your game characters. Every agent knows about its target and automatically rebuilds the path
if the target has moved. Navmesh agents are able to move along the path, providing you with their current position, so you
can use it to perform an actual motion of your game characters. Agents work together with navigational meshes, you need
to update their state every frame, so they can recalculate path if needed. A simple example could something like this:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::utils::navmesh::NavmeshAgent;
</span><span class="boring">struct Foo { 
</span>// Add this to your script
agent: NavmeshAgent
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>After that, you need to update the agent every frame to make sure it will follow the target:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">   core::algebra::Vector3, scene::navmesh::NavigationalMesh, utils::navmesh::NavmeshAgent,
</span><span class="boring">};
</span>fn update_agent(
    agent: &amp;mut NavmeshAgent,
    target: Vector3&lt;f32&gt;,
    dt: f32,
    navmesh: &amp;mut NavigationalMesh,
) {
    // Set the target to follow and the speed.
    agent.set_target(target);
    agent.set_speed(1.0);

    // Update the agent.
    agent.update(dt, navmesh.navmesh_mut()).unwrap();

    // Print its position - you can use this position as target point of your game character.
    println!(&quot;{}&quot;, agent.position());
}
<span class="boring">}</span></code></pre></pre>
<p>This method should be called in <code>on_update</code> of your script. It accepts four parameters: a reference to the agent, a 
target which it will follow, a time step (<code>context.dt</code>), and a reference to navigational mesh node. You can fetch 
navigational mesh from the scene graph by its name:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::scene::{navmesh::NavigationalMesh, Scene};
</span>fn find_navmesh&lt;'a&gt;(scene: &amp;'a mut Scene, name: &amp;str) -&gt; &amp;'a mut NavigationalMesh {
    let handle = scene.graph.find_by_name_from_root(name).unwrap().0;
    scene.graph[handle].as_navigational_mesh_mut()
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rendering-wip"><a class="header" href="#rendering-wip">Rendering (WIP)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="shaders"><a class="header" href="#shaders">Shaders</a></h1>
<p>Shader is a set of programs that run directly on graphics adapter. Each program from the set is called
<em>sub-shader</em>. Sub-shaders linked with render pass, each render pass defines &quot;where&quot; to draw an object.
&quot;where&quot; means that you can set up your own render pass and the renderer will use the sub-shader with 
your render pass. For the ease of use there are a number of <a href="fyrox/rendering/shaders.html#predefined-render-passes">predefined render passes</a>.</p>
<p>Shaders have properties of various types that can be used together with materials to draw an object. </p>
<h2 id="shaders-language"><a class="header" href="#shaders-language">Shaders language</a></h2>
<p>The engine uses GLSL shading language for every sub-shader. There are numerous GLSL guides over the 
internet, so there is no need to &quot;re-post&quot; the well documented info again.</p>
<p>There are very few differences:</p>
<ol>
<li>No need to define a version of the shader. Every shader source will be pre-processed, and it will 
get correct version automatically. Preprocessing is needed because the same shader could run on OpenGL
and WebGL (OpenGL ES) which have some differences.</li>
<li>There is a &quot;standard&quot; library of useful methods which is automatically included in every shader source
at preprocessing stage. The library source could be found
<a href="https://github.com/FyroxEngine/Fyrox/blob/master/src/renderer/framework/shaders/shared.glsl">here</a>. It 
is well documented, and you may find some functions useful for you job.</li>
</ol>
<h2 id="structure-1"><a class="header" href="#structure-1">Structure</a></h2>
<p>Shader has rigid structure that could be described in this code snippet:</p>
<pre><code class="language-ron">(
    // A set of properties, there could be any amount of properties.
    properties: [
        (
            // Each property must have a name. This name must match with respective
            // uniforms! That's is the whole point of having properties.
            name: &quot;diffuseTexture&quot;,
            // Value has limited set of possible variants.
            value: Sampler(default: None, fallback: White)
        )
    ],
    // A set of render passes (see next section for more info)
    passes: [
        (
            // Name must match with the name of either standard render pass (see below) or
            // one of your passes.
            name: &quot;Forward&quot;,
            // A set of parameters that regulate renderer pipeline state.
            // This is mandatory field of each render pass.
            draw_parameters: DrawParameters(
                // A face to cull. Either Front or Back.
                cull_face: Some(Back),
                // Color mask. Defines which colors should be written to render target.
                color_write: ColorMask(
                    red: true,
                    green: true,
                    blue: true,
                    alpha: true,
                ),
                // Whether to modify depth buffer or not.
                depth_write: true,
                // Whether to use stencil test or not.
                stencil_test: None,
                // Whether to perform depth test when drawing.
                depth_test: true,
                // Blending options.
                blend: Some(BlendFunc(
                    sfactor: SrcAlpha,
                    dfactor: OneMinusSrcAlpha,
                )),
                // Stencil options.
                stencil_op: StencilOp(
                    fail: Keep,
                    zfail: Keep,
                    zpass: Keep,
                    write_mask: 0xFFFF_FFFF,
                ),
            ),
            // Vertex shader code.
            vertex_shader:
                r#&quot;
                layout(location = 0) in vec3 vertexPosition;
                layout(location = 1) in vec2 vertexTexCoord;
                uniform mat4 rg3d_worldViewProjection;
                out vec2 texCoord;
                void main()
                {
                    texCoord = vertexTexCoord;
                    gl_Position = rg3d_worldViewProjection * vertexPosition;
                }
                &quot;#;
            // Pixel shader code.
            pixel_shader:
                r#&quot;
                // Note that the name of this uniform match the name of the property up above.
                uniform sampler2D diffuseTexture;
                out vec4 FragColor;
                in vec2 texCoord;
                void main()
                {
                    FragColor = diffuseColor * texture(diffuseTexture, texCoord);
                }
                &quot;#;
        )
    ],
)
</code></pre>
<h2 id="properties"><a class="header" href="#properties">Properties</a></h2>
<p>Property is a named variable of some type. Properties are directly tied with the uniforms in the sub-shaders,
for each you can have a property called <code>time</code>, and then you can define <code>uniform float time;</code> in your sub-shader
and the engine will pass a property value to that uniform for you before drawing an object. Properties placed in 
a &quot;global namespace&quot;, which means that every sub-shader has &quot;access&quot; to the properties.</p>
<h2 id="built-in-properties"><a class="header" href="#built-in-properties">Built-in properties</a></h2>
<p>There are a number of built-in properties, the full list is available
<a href="https://docs.rs/fyrox/0.23.1/fyrox/material/shader/struct.Shader.html#built-in-variables">here</a></p>
<h2 id="predefined-render-passes"><a class="header" href="#predefined-render-passes">Predefined render passes</a></h2>
<p>Predefined render passes helps you to create your own shader without a need to create your own render pass 
and to quickly start writing your shaders.</p>
<ul>
<li><strong>GBuffer</strong> - A pass that fills a set with render target sized textures with various data about each rendered 
object. These textures then are used for physically-based lighting. Use this pass when you want the standard 
lighting to work with your objects.</li>
<li><strong>Forward</strong> - A pass that draws an object directly in render target. This pass is very limiting, it does not 
support lighting, shadows, etc. It should be only used to render translucent objects.</li>
<li><strong>SpotShadow</strong> - A pass that emits depth values for an object, later this depth map will be used to render shadows.</li>
<li><strong>PointShadow</strong> - A pass that emits distance from a fragment to a point light, later this depth map will be used
to render shadows.</li>
</ul>
<h2 id="drawing-parameters"><a class="header" href="#drawing-parameters">Drawing parameters</a></h2>
<p>Drawing parameters defines which GPU functions to use and at which state. For example, to render transparent
objects you need to enable blending with specific blending rules. Or you need to disable culling to draw objects
from both sides. This is when draw parameters come in handy. There is a relatively large list of drawing
parameters, and it could confuse a person who isn't used to work with graphics. Thankfully there is a good
documentation about this available <a href="https://docs.rs/fyrox/0.23.1/fyrox/material/shader/struct.Shader.html#drawing-parameters">here</a></p>
<h2 id="vertex-shader"><a class="header" href="#vertex-shader">Vertex shader</a></h2>
<p>Vertex shader operates on single vertices, it must provide at least the position of the vertex
in clipping space. In other words it has to do at least this:</p>
<pre><code class="language-glsl">layout(location = 0) in vec3 vertexPosition;

uniform mat4 rg3d_worldViewProjection; // Note the built-in variable.

void main()
{
    gl_Position = rg3d_worldViewProjection * vertexPosition;
}
</code></pre>
<p>This is the simplest vertex shader, using vertex shaders you can create various graphical effects that affects
vertices.</p>
<h2 id="pixel-shader"><a class="header" href="#pixel-shader">Pixel Shader</a></h2>
<p>Pixel shader (or more precisely - fragment shader), operates on a small fragment of your render target. In general
pixels shaders just writes some color to a render target (or multiple targets) using some program.</p>
<pre><code class="language-glsl">out vec4 FragColor;

void main()
{
    FragColor = vec4(1, 0, 0, 1);
}
</code></pre>
<p>This is the simplest pixel shader, it just fills the render target with red color.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="materials"><a class="header" href="#materials">Materials</a></h1>
<p>Material defines a set of values for a shader. Materials usually contains textures (diffuse, normal, height, emission and other maps), numerical values (floats, integers), vectors, booleans, matrices and arrays of each type, except
textures. Each parameter can be changed in runtime giving you the ability to create animated materials. However,
in practice, most materials are static, this means that once it's created, it won't be changed anymore.</p>
<p>Please keep in mind that the actual &quot;rules&quot; of drawing an entity are stored in the shader, 
<strong>material is only a storage</strong> for specific uses of the shader. </p>
<p>Multiple materials can share the same shader, for example standard shader covers 95% of most common use cases,
and it is shared across multiple materials. The only difference are property values, for example you can draw
multiple cubes using the same shader, but with different textures.</p>
<p>Material itself can be shared across multiple places as well as the shader. This gives you the ability to render
multiple objects with the same material efficiently.</p>
<h2 id="performance-9"><a class="header" href="#performance-9">Performance</a></h2>
<p>It is very important re-use materials as much as possible, because the amount of materials used per frame
significantly correlates with performance. The more unique materials you have per frame, the more work
the renderer and video driver need in order to render a frame and more time the frame will require for
rendering, thus lowering your FPS.</p>
<h2 id="standard-material"><a class="header" href="#standard-material">Standard material</a></h2>
<p>The engine offers a standard PBR material, PBR stands for &quot;Physically-Based Rendering&quot; which gives you the quality
of shading which is very close to materials in real world (to some extent of course).</p>
<p>The standard material can cover 95% of use cases, and it is suitable for almost any kind of game, except maybe
some cartoon-ish or stylized games. </p>
<p>The standard material has quite a lot of properties that can be used to fully utilize the power of PBR rendering:</p>
<ul>
<li><strong>diffuseColor</strong> - an RGBA color that will be used as a base color for you object. <strong>Caveat:</strong> the opacity value
(alpha) will be used only with <code>Forward</code> render path! This means that you will need to switch render path on your
mesh (<a href="fyrox/rendering/materials.html#transparency">see below</a>)</li>
<li><strong>diffuseTexture</strong> - a 2D texture containing the unlit &quot;basic&quot; colors of your object, this is the most commonly
used texture. For example, you can assign a brick wall texture to this property and your object will look like a brick
wall.</li>
<li><strong>normalTexture</strong> - a 2D texture containing per-pixel normal vectors. </li>
<li><strong>metallicTexture</strong> - a 2D texture containing per-pixel metallic factor, where 0 - dielectric, 1 - metal.
In simple words it defines whether your object reflects (1.0) the environment or not (0.0). </li>
<li><strong>roughnessTexture</strong> - a 2D texture containing per-pixel roughness factor, where 0 - completely flat, 1 - 
very rough.</li>
<li><strong>heightTexture</strong> - a 2D texture containing per-pixel displacement value, it is used with parallax mapping to
crate an effect of volume on a flat surface.</li>
<li><strong>emissionTexture</strong> - a 2D texture containing per-pixel emission lighting. You could use this to create emissive
surfaces like small lamps on wall of sci-fi ship, or to create glowing eyes for your monsters that will scare 
the player.</li>
<li><strong>lightmapTexture</strong> - a 2D texture containing per-pixel <strong>static</strong> lighting. It is used to apply precomputed
light to your 3D models, and the most common use case is to lit a static object using a static light. Precomputed
light is very cheap. The engine offers built-in lightmapper that can generate lightmaps for you.</li>
<li><strong>aoTexture</strong> - a 2D texture containing per-pixel shading values, allows you to &quot;bake&quot; shadows in for your 3D
object.</li>
<li><strong>texCoordScale</strong> - a 2D vector that allows you to scale texture coordinates used to sample the textures 
mentioned above (except lightmaps, they're using separate texture coordinates)</li>
<li><strong>layerIndex</strong> - a natural number that is used for decals masking, a decal will only be applied to your mesh
if and only if the decal has matching index. </li>
<li><strong>emissionStrength</strong> - a 3D vector that allows you to set the strength of emission per-channel (R, G, B) for 
your <code>emissionTexture</code></li>
</ul>
<h2 id="transparency"><a class="header" href="#transparency">Transparency</a></h2>
<p>The standard material offers very basic transparency support, to use it you have to explicitly switch render
path on your mesh object. It could be done in this way:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    scene::{mesh::RenderPath, node::Node, Scene},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn set_forward_render_path(scene: &amp;mut Scene, mesh_handle: Handle&lt;Node&gt;) {
</span>    scene.graph[mesh_handle]
        .as_mesh_mut()
        .set_render_path(RenderPath::Forward);
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>After this, your mesh will be rendered using a specialized render pass called Forward which supports alpha-blending
and transparent objects. <strong>Caveat:</strong> Current forward renderer implementation does not support any kind of lighting,
if you need lighting, you will need to use custom shader for that!</p>
<h2 id="material-import"><a class="header" href="#material-import">Material import</a></h2>
<p>When you're loading a 3D model in the engine, the engine tries to convert the materials stored inside to standard
material. In most cases there is no way to create 100% matching material on the fly, instead the engine tries 
to do its best to make sure the material will be imported as closely as possible to the original one. Various 3D modelling
tools use different material system, but all of them allow you to export your 3D model in one of the commonly
used formats (such as FBX).</p>
<h3 id="blender"><a class="header" href="#blender">Blender</a></h3>
<p>When using Blender, make sure you are using <strong>Principled BSDF</strong> material, it is the closest material that can be converted
to engine's standard material at almost 100% fidelity. </p>
<h3 id="3ds-max"><a class="header" href="#3ds-max">3Ds max</a></h3>
<p>It highly depends on the version of the 3Ds max, but in general the default material should work fine.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="light-maps-wip"><a class="header" href="#light-maps-wip">Light Maps (WIP)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="settings"><a class="header" href="#settings">Settings</a></h1>
<p>Renderer has a large set of settings, that allows you to tweak graphics quality to find optimal balance between
rendering quality and performance. Quality settings are represented by the following structure:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::renderer::{CsmSettings, ShadowMapPrecision};
</span>struct QualitySettings {
    point_shadow_map_size: usize,
    point_soft_shadows: bool,
    point_shadows_enabled: bool,
    point_shadows_distance: f32,
    point_shadow_map_precision: ShadowMapPrecision,
    spot_shadow_map_size: usize,
    spot_soft_shadows: bool,
    spot_shadows_enabled: bool,
    spot_shadows_distance: f32,
    spot_shadow_map_precision: ShadowMapPrecision,
    csm_settings: CsmSettings,
    use_ssao: bool,
    ssao_radius: f32,
    light_scatter_enabled: bool,
    fxaa: bool,
    use_parallax_mapping: bool,
    use_bloom: bool,
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li><code>point_shadow_map_size</code> - size of a cube map face of shadow map texture (in pixels). The higher, the better quality,
but lower performance. Typical values for medium GPU (GTX 1050) is 1024 pixels.</li>
<li><code>point_soft_shadows</code> - should the shadows from point lights be smooth (<code>true</code>) or blocky (<code>false</code>). The latter option
has better performance, but lower quality.</li>
<li><code>point_shadows_enabled</code> - are the shadows from point lights enabled? </li>
<li><code>point_shadows_distance</code> - maximal distance from a camera to draw point light shadows. It is used to disable shadows
on distant lights. The distance is given in meters. The lower the value, the better performance is.</li>
<li><code>point_shadow_map_precision</code> - defines bit-depth (<code>u16</code> or <code>u32</code>) for shadow map pixels. Lower bit depth means better
performance and lower quality.</li>
<li><code>spot_shadow_map_size</code> - size of a shadow map texture for spotlights. The higher, the better quality,
but lower performance. Typical values for medium GPU (GTX 1050) is 1024 pixels.</li>
<li><code>spot_soft_shadows</code> - should the shadows from spotlights be smooth (<code>true</code>) or blocky (<code>false</code>). The latter option
has better performance, but lower quality.</li>
<li><code>spot_shadows_enabled</code> - are the shadows from spotlights enabled? </li>
<li><code>spot_shadows_distance</code> - maximal distance from a camera to draw spotlight shadows. It is used to disable shadows
on distant lights. The distance is given in meters. The lower the value, the better performance is. </li>
<li><code>spot_shadow_map_precision</code> - defines bit-depth (<code>u16</code> or <code>u32</code>) for shadow map pixels.  Lower bit depth means better
performance and lower quality.</li>
<li><code>csm_settings</code> - settings for cascaded shadow maps for directional lights.
<ul>
<li><code>enabled</code> - whether cascaded shadow maps enabled or not. </li>
<li><code>size</code> - size of texture for each cascade.</li>
<li><code>precision</code> - defines bit-depth (<code>u16</code> or <code>u32</code>) for shadow map pixels. Lower bit depth means better
performance and lower quality.</li>
<li><code>pcf</code> - should the shadows from directional lights be smooth (<code>true</code>) or blocky (<code>false</code>). The latter option
has better performance, but lower quality.</li>
</ul>
</li>
<li><code>use_ssao</code> - defines whether the renderer should perform separate screen-space ambient occlusion pass. This option
has relatively small performance impact.</li>
<li><code>ssao_radius</code> - radius of sampling hemisphere used in SSAO, it defines much ambient occlusion will be in your scene.
has no performance impact.</li>
<li><code>light_scatter_enabled</code> - global switch to enable or disable light scattering. Each light have its own scatter switch,
but this one is able to globally disable scatter. Light scattering has medium performance impact, it also depends on 
light count in your scene.</li>
<li><code>fxaa</code> - is full-screen anti-aliasing needed? This option has low performance impact.</li>
<li><code>use_parallax_mapping</code> - defines whether the renderer should use parallax mapping to simulate bumps and dents on
flat surfaces using special textures. This option has low performance impact.</li>
<li><code>use_bloom</code> - defines whether the renderer should draw glowing pixels. This option has low performance impact.</li>
</ul>
<h2 id="presets"><a class="header" href="#presets">Presets</a></h2>
<p>The renderer offers built-in presets for various graphics quality, use <code>QualitySettings::ultra()</code>, 
<code>QualitySettings::high()</code>, <code>QualitySettings::medium()</code> and <code>QualitySettings::low()</code> presets to quickly tune 
quality-performance balance.</p>
<h2 id="how-to-apply"><a class="header" href="#how-to-apply">How to apply</a></h2>
<p>To apply the settings, use <code>renderer.set_quality_settings</code> method:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    renderer::{QualitySettings, Renderer},
</span><span class="boring">    core::log::Log,
</span><span class="boring">};
</span><span class="boring">
</span>fn set_quality_settings(renderer: &amp;mut Renderer) {
    let mut settings = QualitySettings::high();

    // Disable something.
    settings.use_ssao = false;
    settings.fxaa = false;

    // Apply.
    Log::verify(renderer.set_quality_settings(&amp;settings))
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="render-pass"><a class="header" href="#render-pass">Render Pass</a></h1>
<p>You can define your own render passes that extends the renderer, currently there are render passes only for scenes,
so no custom post-effects (this is planned to be improved in Fyrox 0.28). Render pass has full access to graphics 
framework (which is a thin wrapper around OpenGL) so it can utilize full power of it to implement various graphical
effects.</p>
<h2 id="creating-a-render-pass"><a class="header" href="#creating-a-render-pass">Creating a render pass</a></h2>
<p>Render pass is a complex thing, that requires relatively deep knowledge in computer graphics. It is intended to be used
by experienced graphics programmers. Here's the simplest render pass that renders unit quad without any textures.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::{algebra::Matrix4, pool::Handle, sstorage::ImmutableString},
</span><span class="boring">    renderer::{
</span><span class="boring">        framework::{
</span><span class="boring">            error::FrameworkError,
</span><span class="boring">            framebuffer::{DrawParameters},
</span><span class="boring">            geometry_buffer::{GeometryBuffer, ElementRange, GeometryBufferKind},
</span><span class="boring">            gpu_program::{GpuProgram, UniformLocation},
</span><span class="boring">        },
</span><span class="boring">        RenderPassStatistics, Renderer, SceneRenderPass, SceneRenderPassContext,
</span><span class="boring">    },
</span><span class="boring">    scene::{mesh::surface::SurfaceData, Scene},
</span><span class="boring">};
</span><span class="boring">use std::{cell::RefCell, rc::Rc};
</span><span class="boring">
</span>struct MyRenderPass {
    enabled: bool,
    shader: GpuProgram,
    target_scene: Handle&lt;Scene&gt;,
    quad: GeometryBuffer,
    world_view_proj: UniformLocation,
}

impl MyRenderPass {
    pub fn new(
        renderer: &amp;mut Renderer,
        target_scene: Handle&lt;Scene&gt;,
    ) -&gt; Result&lt;Self, FrameworkError&gt; {
        let vs = r#&quot;
                layout(location = 0) in vec3 vertexPosition;
                
                uniform mat4 c;
                         
                void main()
                {
                    gl_Position = worldViewProjectionMatrix * vertexPosition;
                }
            &quot;#;

        let fs = r#&quot;                
                out vec4 FragColor;             
                
                void main()
                {
                    FragColor = vec4(1.0, 0.0, 0.0, 1.0);
                }
            &quot;#;

        let shader = GpuProgram::from_source(&amp;mut renderer.state, &quot;MyShader&quot;, vs, fs)?;

        Ok(Self {
            enabled: true,
            world_view_proj: shader.uniform_location(
                &amp;renderer.state,
                &amp;ImmutableString::new(&quot;worldViewProjectionMatrix&quot;),
            )?,
            target_scene,
            quad: GeometryBuffer::from_surface_data(
                &amp;SurfaceData::make_quad(&amp;Matrix4::identity()),
                GeometryBufferKind::StaticDraw,
                &amp;mut renderer.state,
            ),
            shader,
        })
    }
}

impl SceneRenderPass for MyRenderPass {
    fn on_ldr_render(
        &amp;mut self,
        ctx: SceneRenderPassContext,
    ) -&gt; Result&lt;RenderPassStatistics, FrameworkError&gt; {
        let mut stats = RenderPassStatistics::default();

        // Make sure to render only to target scene.
        if self.enabled &amp;&amp; ctx.scene_handle == self.target_scene {
            stats += ctx.framebuffer.draw(
                &amp;self.quad,
                ctx.pipeline_state,
                ctx.viewport,
                &amp;self.shader,
                &amp;DrawParameters::default(),
                ElementRange::Full,
                |mut program| {
                    program.set_matrix4(&amp;self.world_view_proj, &amp;Matrix4::identity());
                },
            )?;
        }

        Ok(stats)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The code snippet shows how to create a shader, find its uniforms, and finally how to actually render something in 
target frame buffer.</p>
<h2 id="registering-a-render-pass"><a class="header" href="#registering-a-render-pass">Registering a render pass</a></h2>
<p>Every render pass must be registered in the renderer, otherwise it won't be used. You can register a render pass using
<code>add_render_pass</code> method of the <code>Renderer</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::renderer::{Renderer, SceneRenderPass};
</span><span class="boring">use std::{cell::RefCell, rc::Rc};
</span><span class="boring">
</span><span class="boring">struct MyRenderPass;
</span><span class="boring">impl SceneRenderPass for MyRenderPass {}
</span><span class="boring">
</span>fn usage_example(renderer: &amp;mut Renderer, render_pass: MyRenderPass) {
    let shared_pass = Rc::new(RefCell::new(render_pass));
    // You can share the pass across multiple places to be able to control it.
    renderer.add_render_pass(shared_pass);
}
<span class="boring">}</span></code></pre></pre>
<p>Please notice that we've wrapped render pass in <code>Rc&lt;RefCell&lt;..&gt;&gt;</code>, this means that you can share it across multiple places
and modify its data from the code of your game.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="asset-management-1"><a class="header" href="#asset-management-1">Asset Management</a></h1>
<p>This chapter covers asset management in the engine. Asset management is performed by <code>Asset Browser</code> in the editor 
and by <code>ResourceManager</code> from API.</p>
<h2 id="general-info"><a class="header" href="#general-info">General Info</a></h2>
<p>Assets loading is asynchronous, it is possible to load multiple assets in parallel or load until a specific asset is 
loaded.</p>
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<p>It is strongly advised to specify all resources used by your game entities inside your scripts, instead of requesting 
resources directly from the resource manager on demand. This approach solves two common issues:</p>
<ol>
<li>It allows you to set resources directly from the editor by a simple drag'n'drop from the Asset Browser.</li>
<li>The engine will be able to wait until all resources used by a scene are fully loaded. This is especially important,
because this way can guarantee, that scene loading will be &quot;seamless&quot; and if the scene was loaded, it means that all
resources used by it are loaded too. </li>
</ol>
<p>This can be achieved by adding a respective field in your script. For example, you may a have a weapon script that 
shoots some projectiles. In this case all you need to add a <code>projectile: Option&lt;ModelResource&gt;</code> field in your script,
assign it so some prefab in the editor and then instantiate it from code when shooting. Storing resource handle 
directly in your script helps the engine to gather all resources used by parent scene and preload them too while loading
the scene itself. Such approach prevent lags when doing actual shooting, which is especially important if you're targeting
a WebAssembly platform. On WebAssembly all the files accessed over network API which could work with unstable connection.
In any case, even on PC it helps a lot.</p>
<p>Requesting resources on demand could be useful in limited situations:</p>
<ol>
<li>You're loading a new game level - in this case it is perfectly fine to request the resource manually.</li>
<li>You're doing some background work (level streaming for instance).</li>
</ol>
<h2 id="asset-browser"><a class="header" href="#asset-browser">Asset Browser</a></h2>
<p>Asset browser allows you to preview your assets and edit their import properties. It looks something like this (keep
in mind that the screenshot could be outdated).</p>
<p><img src="fyrox/resources/asset_browser.png" alt="Asset Browser" /></p>
<p>There are three main areas in it:</p>
<ol>
<li>Left directory tree - shows all <em>directories</em> starting from project root. It does <em>not</em> show any files, this is 
for what the center section is.</li>
<li>Center asset previewer - shows all assets from selected directory. The path at the top of the section shows asset
path.</li>
<li>Right asset import options inspector - it shows import properties of selected asset.</li>
</ol>
<p>Typical workflow could look like this:</p>
<ol>
<li>Select desired directory from the left tree</li>
<li>Select desired asset in the center previewer</li>
<li>Edit import properties of selected asset and click &quot;Apply&quot; button to save import options and re-load the asset with
new options.</li>
</ol>
<p>Check next chapters to learn how to manage specific asset types and what their import does what.</p>
<h2 id="api-docs"><a class="header" href="#api-docs">API Docs</a></h2>
<p>Please read API docs <a href="https://docs.rs/fyrox/latest/fyrox/engine/resource_manager/index.html">here</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="model-resources"><a class="header" href="#model-resources">Model resources</a></h1>
<h2 id="supported-formats"><a class="header" href="#supported-formats">Supported formats</a></h2>
<p>Fyrox supports these file formats for 3D models:</p>
<ul>
<li>FBX - standard game development industry 3D model exchange format</li>
<li>RGS - native scenes format produced by Fyroxed (the editor)</li>
</ul>
<p>The list could be extended in the future.</p>
<h2 id="instantiation"><a class="header" href="#instantiation">Instantiation</a></h2>
<p>Model must be instantiated in your scene, there is no other way of using it. To do this, you can either use drag'n'drop
from Asset Browser in the editor or instantiate the model dynamically from code:</p>
<pre><pre class="playground"><code class="language-rust no_run edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    asset::manager::ResourceManager, resource::model::{Model, ModelResourceExtension},
</span><span class="boring">    scene::{node::Node, Scene},
</span><span class="boring">};
</span><span class="boring">use std::path::Path;
</span>async fn instantiate_model(
    path: &amp;Path,
    resource_manager: ResourceManager,
    scene: &amp;mut Scene,
) -&gt; Handle&lt;Node&gt; {
    // Load model first. Alternatively, you can store resource handle somewhere and use it for
    // instantiation.
    let model = resource_manager.request::&lt;Model, _&gt;(path).await.unwrap();

    model.instantiate(scene)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="material-import-1"><a class="header" href="#material-import-1">Material import</a></h2>
<p>The engine tries to import materials as close as possible to originals in the model, however it is not always possible
because some 3D modelling software could use different shading models. By default, the engine tries to convert
everything to PBR materials, so if you have a 3D model with a special material made for cartoon shading, the
engine will still import it as PBR material (with lots of missing textures of course). You should take this into
account when working with something other than PBR materials. </p>
<p>In cases when your 3D model have some weird materials, you should create appropriate materials and shaders <em>manually</em>,
the engine is not a magic tool, it has some defaults that do not cover all possible cases.</p>
<p>It is also possible to specify how to resolve textures while loading a 3D model, select your model in the <code>Asset Browser</code>
and there will be import options right below the model preview:</p>
<p><img src="fyrox/resources/model_import.png" alt="model import" /></p>
<p>It is also possible to specify such options manually. To do that, you need to create import options file with the 
following content near your 3D model (this is what the editor does for you):</p>
<pre><code class="language-text">(
    material_search_options: RecursiveUp
)
</code></pre>
<p>The file must have the <code>.options</code> additional extension. For example, if you have a <code>foo.fbx</code> model, the options
file should have <code>foo.fbx.options</code> name. Even if it is possible to modify it by hand, it is strongly advised to use
the editor to edit import options, because it reduces the chance of messing up.</p>
<h2 id="tips-for-blender"><a class="header" href="#tips-for-blender">Tips for Blender</a></h2>
<p>Blender's FBX exporter has exporting scale properties usually set to 100%, this may lead to incorrect scale
of your model in the engine. It will have <code>(100.0, 100.0, 100.0)</code> scale which is very huge. To fix that, set
the scale in the exporter to <code>0.01</code>.</p>
<h2 id="tips-for-3ds-max"><a class="header" href="#tips-for-3ds-max">Tips for 3Ds Max</a></h2>
<p>Latest versions of 3Ds max have node-based material editor which creates some &quot;junk&quot; nodes which may mess up
material import. To prevent any issues with that, you should clean all assignments to material slots to use
maps directly.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="textures-1"><a class="header" href="#textures-1">Textures</a></h1>
<p>Texture is an image that is used to fill faces to add details to them. In most cases textures are just 2D images, however 
there are some exclusions to that - for example cube maps, that may be used for environment mapping. Fyrox supports 1D,
2D, 3D and Cube textures.</p>
<h2 id="supported-formats-1"><a class="header" href="#supported-formats-1">Supported formats</a></h2>
<p>To load images and decode them, Fyrox uses image and ddsfile crates. Here is the list of supported formats: png,
tga, bmp, dds, jpg, gif, tiff, dds.</p>
<h2 id="compressed-textures"><a class="header" href="#compressed-textures">Compressed textures</a></h2>
<p>Fyrox supports most commonly used formats of compressed textures: DXT1, DXT3, DXT5. Such textures can be loaded
only from <code>DDS</code> files. You can specify on-demand texture compression in import options (see below), it works for every
texture format except DDS. It is meant to be used when you don't want to bother with DDS format, there are two
compression methods:</p>
<ul>
<li><code>Quality</code> - has 4:1 compression ratio, supports full 8-bit alpha channel. Textures with gradients will most likely
suffer from noticeable banding.</li>
<li><code>Speed</code> - has lower quality compared to <code>Quality</code> mode, but it has 8:1 compression ratio for texture without alpha
channel and 6:1 with alpha channel. Keep in mind, that alpha channel in this mode supports only 1 bit - it is either
enabled or not.</li>
</ul>
<p>Compressed textures usually does not support color gradient very well, if you have a texture with a lot of colors and
gradients, then you'll most likely get compressed texture with lots of graphical artifacts such as banding.</p>
<p>It is also worth mentioning, that you should <strong>never</strong> use compression with normal maps, it can significantly distort 
normals because normal maps usually have lots of color gradients.</p>
<h2 id="import-options"><a class="header" href="#import-options">Import options</a></h2>
<p>It is possible to define custom import options. Using import options you could set desired compression quality,
filtering, wrapping, etc. Import options should be defined using Asset Browser in the editor:</p>
<p><img src="fyrox/resources/texture_import.png" alt="texture import" /></p>
<p>It is also possible to define import options manually in a separate file with the same name as the source
texture, but with additional extension <code>options</code>, this is what the editor does for you. For example, you have a 
<code>foo.jpg</code> texture, a file with import options should be called <code>foo.jpg.options</code>. Its content may look something like
this:</p>
<pre><code class="language-text">(
    minification_filter: Linear,
    magnification_filter: Linear,
    s_wrap_mode: Repeat,
    t_wrap_mode: ClampToEdge,
    anisotropy: 8.0,
    compression: NoCompression,    
)
</code></pre>
<p>Even if it is possible to modify it by hand, it is strongly advised to use the editor to edit import options, because
it reduces chances of messing up.</p>
<h2 id="render-target"><a class="header" href="#render-target">Render target</a></h2>
<p>Texture can be used as a render target to render a scene in it. To do this you should use <code>new_render_target</code> method and
pass its result to scene's render target property. Renderer will automatically provide you info about metrics of
texture, but it won't give you access to pixels of render target.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sound-wip"><a class="header" href="#sound-wip">Sound (WIP)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="curve-wip"><a class="header" href="#curve-wip">Curve (WIP)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-resources"><a class="header" href="#custom-resources">Custom Resources</a></h1>
<p>In Fyrox, you can create your own, custom resource type that can be embedded in the standard resource management pipeline.
It could be useful to access specific data using engine's resource manager. Custom resources has a few major advantages 
over manual resource management via direct files access:</p>
<ol>
<li>Since Fyrox resource system is asynchronous, your resource can be loaded in separate worker thread which speeds up
loading (since it may run on a separate CPU core).</li>
<li>You can access your resources from the Asset Browser and assign their handles to scripts directly from the editor.</li>
<li>File access for resource management has an abstraction, that unifies the access over all supported platforms. This 
means that you don't need to use <code>fetch</code> API directly, if you're targeting WebAssembly platform, or use <code>AssetManager</code>
on Android.</li>
</ol>
<p>To create a custom resource, you need to do three major steps:</p>
<ol>
<li>Define your resource structure with all required traits implemented.</li>
<li>Add a custom resource loader, that will be used by the resource manager to load your custom resource.</li>
<li>Register the resource loader in the resource manager.</li>
</ol>
<p>See the code snippet in the next section as a guide. </p>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<p>Custom resource is just an ordinary struct with some data. It must implement <code>Debug</code>, <code>Reflect</code>, <code>Visit</code>, <code>ResourceData</code>
traits. Also, it must contain at least path to external file with the content. Here's the simplest custom resource, that
contains some string data.</p>
<pre><pre class="playground"><code class="language-rust no_run edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    asset::{
</span><span class="boring">        event::ResourceEventBroadcaster,
</span><span class="boring">        loader::{BoxedLoaderFuture, ResourceLoader},
</span><span class="boring">        untyped::UntypedResource,
</span><span class="boring">        ResourceData,
</span><span class="boring">    },
</span><span class="boring">    core::{
</span><span class="boring">        io::{self},
</span><span class="boring">        reflect::prelude::*,
</span><span class="boring">        uuid::{uuid, Uuid},
</span><span class="boring">        visitor::prelude::*,
</span><span class="boring">        TypeUuidProvider,
</span><span class="boring">    },
</span><span class="boring">};
</span><span class="boring">use std::{
</span><span class="boring">    any::Any,
</span><span class="boring">    borrow::Cow,
</span><span class="boring">    path::{Path, PathBuf},
</span><span class="boring">};
</span><span class="boring">
</span>#[derive(Debug, Visit, Reflect)]
struct CustomResource {
    // You resource must store the path.
    path: PathBuf,
    some_data: String,
}

impl TypeUuidProvider for CustomResource {
    // Every resource must provide a unique identifier, that is used for dynamic type
    // casting, serialization, etc.
    fn type_uuid() -&gt; Uuid {
        uuid!(&quot;15551157-651b-4f1d-a5fb-6874fbfe8637&quot;)
    }
}

impl ResourceData for CustomResource {
    fn path(&amp;self) -&gt; Cow&lt;Path&gt; {
        Cow::Borrowed(&amp;self.path)
    }

    fn set_path(&amp;mut self, path: PathBuf) {
        self.path = path;
    }

    fn as_any(&amp;self) -&gt; &amp;dyn Any {
        self
    }

    fn as_any_mut(&amp;mut self) -&gt; &amp;mut dyn Any {
        self
    }

    fn type_uuid(&amp;self) -&gt; Uuid {
        &lt;Self as TypeUuidProvider&gt;::type_uuid()
    }
}

struct CustomResourceLoader;

impl ResourceLoader for CustomResourceLoader {
    fn extensions(&amp;self) -&gt; &amp;[&amp;str] {
        // An array of extensitions, supported by this loader. There could be any number of extensions
        // since sometimes multiple extensions map to a single resource (for instance, jpg, png, bmp, are
        // all images).
        &amp;[&quot;my_resource&quot;]
    }

    fn into_any(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Any&gt; {
        self
    }

    fn as_any(&amp;self) -&gt; &amp;dyn Any {
        self
    }

    fn as_any_mut(&amp;mut self) -&gt; &amp;mut dyn Any {
        self
    }

    fn load(
        &amp;self,
        resource: UntypedResource,
        event_broadcaster: ResourceEventBroadcaster,
        reload: bool,
    ) -&gt; BoxedLoaderFuture {
        Box::pin(async move {
            let path = resource.path();
            match io::load_file(&amp;path).await {
                Ok(content) =&gt; {
                    let my_resource = CustomResource {
                        path,
                        some_data: String::from_utf8(content).unwrap(),
                    };

                    resource.commit_ok(my_resource);

                    // Notify potential subscribers that the resource was loader.
                    event_broadcaster.broadcast_loaded_or_reloaded(resource, reload);
                }
                Err(err) =&gt; {
                    resource.commit_error(path, err);
                }
            }
        })
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Keep in mind, that you must provide <strong>unique</strong> UUID for every resource type that you're creating. Otherwise, using
existing id multiple times will cause incorrect serialization and type casting. The next step is to register the new 
resource in the resource manager. This can be done by: <code>resource_manager.state().loaders.set::&lt;CustomResourceLoader&gt;()</code>.
After doing so, any attempt to load a resource with <code>my_resource</code> extension will call the <code>load</code> method of your 
resource loader. See <a href="https://github.com/FyroxEngine/Fyrox/blob/master/examples/custom_loader.rs">custom_loader</a> for 
runnable example.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="user-interface"><a class="header" href="#user-interface">User Interface</a></h1>
<p>Fyrox features an extremely powerful and flexible node-based user interface system. Power and flexibility comes with
a certain price: it has a steep learning curve. This chapter will cover user interface usage in the engine, explain
basic concepts, provide information about most commonly used widgets, and so on.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basic-concepts-3"><a class="header" href="#basic-concepts-3">Basic concepts</a></h1>
<p>This chapter should help you understand basic concepts lying in the foundation of the GUI in the engine.</p>
<h2 id="stateful"><a class="header" href="#stateful">Stateful</a></h2>
<p>*<em>Stateful UI</em> means that we can create and destroy widgets when we need to, it is the opposite approach of 
<strong>immediate-mode</strong> or <strong>stateless UIs</strong> when you don't have long-lasting state for your widgets
(usually stateless UI hold its state only for one or two frames). </p>
<p>Stateful UI is much more powerful and flexible, it allows you to have complex layout system without having to 
create hacks to create complex layout as you'd do in immediate-mode UIs. It is also much faster in terms of 
performance.</p>
<p>Stateful UI is a must for complex user interfaces that requires rich layout and high performance. I'm not telling
that you <em>can't</em> do it in immediate mode UI, you can, but using tons of hacks. See <a href="fyrox/ui/basic_concepts/basic_concepts.html#layout">Layout</a> section for
more info.</p>
<h2 id="node-based-architecture"><a class="header" href="#node-based-architecture">Node-based architecture</a></h2>
<p>Every user interface could be represented as a set of small blocks that have hierarchical bonding between each
other. For example a button could be represented using two parts: a background and a foreground. Usually the background
is just a simple rectangle (either a vector or bitmap), and a foreground is a text. The text (the foreground widget)
is a child object of the rectangle (the background widget). These two widgets forms another, more complex widget that
we call button. Graphically it will look like this:</p>
<p><img src="fyrox/ui/basic_concepts/./button.svg" alt="Button" /></p>
<p>On the right side of the image we can see the generic button and on the left side, we can see its hierarchical 
structure. Such approach allows us to modify the look of the button as we wish, we can create a button with 
image background, or with any vector image, or even other widgets. The foreground can be anything too, it can also
contain its own complex hierarchy, like a pair of an icon with a text and so on.</p>
<h2 id="composition"><a class="header" href="#composition">Composition</a></h2>
<p>Every widget in the engine uses composition to build more complex widgets. All widgets (and respective builders) contains
<code>Widget</code> instance inside, it provides basic functionality the widget such as layout information, hierarchy, default
foreground and background brushes (their usage depends on derived widget), render and layout transform and so on. </p>
<h2 id="component-querying"><a class="header" href="#component-querying">Component Querying</a></h2>
<p>Many widgets provide component querying functionality - you can get an immutable reference to inner component by its type. It is 
used instead of type casting in many places. Component querying is much more flexible compared to direct type casting. 
For example, you may want to build a custom <a href="fyrox/ui/basic_concepts/../tree.html">Tree</a> widget, you want your CustomTree to inherit all the 
functionality from the Tree, but add something new. The Tree widget can manage its children subtrees, but it needs to
somehow get required data from subtree. Direct type casting would fail in this case, because now you have something
like this:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::gui::tree::Tree;
</span>struct CustomTree {
    tree: Tree,
    my_data: u32
}
<span class="boring">}</span></code></pre></pre>
<p>On other hand, component querying will work fine, because you can query inner component (Tree in our case). Please note 
that this has nothing similar with ECS and stuff, it is made to circumvent Rust's lack of inheritance.</p>
<h2 id="message-passing-1"><a class="header" href="#message-passing-1">Message passing</a></h2>
<p>The engine uses message passing mechanism for any UI logic. What does that mean? Let's see at the button from the
previous section and imagine we want to change its text. To do that we need to explicitly &quot;tell&quot; the button's text
widget to change its content to something new. This is done by sending a message to the widget.</p>
<p>There is no classic callbacks to handle various types of messages, which may come from widgets. Instead, you should write
your own message dispatcher where you'll handle all messages. Why so? At first - decoupling, in this case business logic
is decoupled from the UI. You just receive messages one-by-one and do specific logic. The next reason is that any 
callback would require context capturing which could be somewhat restrictive - since you need to share context with the 
UI, it would force you to wrap it in <code>Rc&lt;RefCell&lt;..&gt;&gt;</code>/<code>Arc&lt;Mutex&lt;..&gt;&gt;</code>.</p>
<p>Message dispatcher is very easy to write, all you need to do is to handle UI messages in <code>Plugin::on_ui_message</code> method:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::{pool::Handle},
</span><span class="boring">    event_loop::ControlFlow,
</span><span class="boring">    gui::{button::ButtonMessage, message::UiMessage, UiNode},
</span><span class="boring">    plugin::{Plugin, PluginContext},
</span><span class="boring">};
</span><span class="boring">
</span>struct MyPlugin {
    button: Handle&lt;UiNode&gt;,
}

impl Plugin for MyPlugin {
    fn on_ui_message(
        &amp;mut self,
        _context: &amp;mut PluginContext,
        message: &amp;UiMessage,
        _control_flow: &amp;mut ControlFlow,
    ) {
        if let Some(ButtonMessage::Click) = message.data() {
            if message.destination() == self.button {
                println!(&quot;The button was clicked!&quot;);
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>As you can see, all you need to do is to check type of incoming message and message destination, which is a node handle
from which a message was come from. Then you do any actions you want.</p>
<h3 id="message-routing-strategies"><a class="header" href="#message-routing-strategies">Message routing strategies</a></h3>
<p>Message passing mechanism works in pair with various routing strategies that allows you to define how the message 
will &quot;travel&quot; across the tree of nodes.</p>
<ol>
<li>Bubble - a message starts its way from a widget and goes up on hierarchy until it reaches root node of hierarchy.
Nodes that lies outside that path won't receive the message. This is the most important message routing strategy, that
is used for <strong>every</strong> node by default.</li>
<li>Direct - a message passed directly to every node that are capable to handle it. There is actual routing in this 
case. Direct routing is used in rare cases when you need to catch a message outside its normal &quot;bubble&quot; route.</li>
</ol>
<h2 id="layout"><a class="header" href="#layout">Layout</a></h2>
<p>The engine uses very complex, yet powerful layout system that allows you to build complex user interfaces with 
complex layout. Layout pass has two <em>recursive</em> sub-passes:</p>
<ol>
<li>Measurement - the sub-pass is used to fetch the desired size of each node in hierarchy.</li>
<li>Arrangement - the sub-pass is used to set final position and size of each node in hierarchy.</li>
</ol>
<p>Such split is required because we need to know desired size of each node in hierarchy before we can actually do an
arrangement.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="general-rules-1"><a class="header" href="#general-rules-1">General rules</a></h1>
<p>This chapter covers general rules that will help you to write code that will be easy to understand.</p>
<h2 id="fluent-syntax"><a class="header" href="#fluent-syntax">Fluent syntax</a></h2>
<p>Widget builders supports fluent syntax, this means that you can create your widget in series of nested 
call of other widget builders. In code, it looks something like this:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::pool::Handle, resource::texture::Texture,
</span><span class="boring">    asset::manager::ResourceManager,
</span><span class="boring">    gui::{
</span><span class="boring">        button::ButtonBuilder, image::ImageBuilder, widget::WidgetBuilder, UiNode,
</span><span class="boring">        UserInterface,
</span><span class="boring">    },
</span><span class="boring">    utils::into_gui_texture,
</span><span class="boring">};
</span><span class="boring">fn create_fancy_button(ui: &amp;mut UserInterface, resource_manager: ResourceManager) -&gt; Handle&lt;UiNode&gt; {
</span><span class="boring">let ctx = &amp;mut ui.build_ctx();
</span>ButtonBuilder::new(WidgetBuilder::new())
    .with_back(
        ImageBuilder::new(WidgetBuilder::new())
            .with_texture(into_gui_texture(
                resource_manager.request::&lt;Texture, _&gt;(&quot;path/to/your/texture&quot;),
            ))
            .build(ctx),
    )
    .with_text(&quot;Click me!&quot;)
    .build(ctx)
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>This code snippet creates a button with an image and a text. Actually it creates <strong>three</strong> widgets, that forms 
complex hierarchy. The topmost widget in hierarchy is the <code>Button</code> widget itself, it has two children widgets:
background image and a text. Background image is set explicitly by calling image widget builder with specific 
texture. The text is created implicitly, the button builder creates <code>Text</code> widget for you and attaches it to 
the button. The structure of the button can contain <em>any</em> amount of nodes, for example you can create a button
that contains text with some icon. To do that, replace <code>.with_text(&quot;My Button&quot;)</code> with this:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    asset::manager::ResourceManager, resource::texture::Texture,
</span><span class="boring">    gui::{
</span><span class="boring">        button::ButtonBuilder,
</span><span class="boring">        grid::{Column, GridBuilder, Row},
</span><span class="boring">        image::ImageBuilder,
</span><span class="boring">        text::TextBuilder,
</span><span class="boring">        widget::WidgetBuilder,
</span><span class="boring">        UiNode, UserInterface,
</span><span class="boring">    },
</span><span class="boring">    utils::into_gui_texture,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn create_fancy_button(
</span><span class="boring">    ui: &amp;mut UserInterface,
</span><span class="boring">    resource_manager: ResourceManager,
</span><span class="boring">) -&gt; Handle&lt;UiNode&gt; {
</span><span class="boring">    let ctx = &amp;mut ui.build_ctx();
</span><span class="boring">
</span><span class="boring">    ButtonBuilder::new(WidgetBuilder::new())
</span>        .with_content(
            GridBuilder::new(
                WidgetBuilder::new()
                    .with_child(
                        ImageBuilder::new(WidgetBuilder::new().on_column(0))
                            .with_texture(into_gui_texture(
                                resource_manager.request::&lt;Texture, _&gt;(&quot;your_icon&quot;),
                            ))
                            .build(ctx),
                    )
                    .with_child(
                        TextBuilder::new(WidgetBuilder::new().on_column(1))
                            .with_text(&quot;My Button&quot;)
                            .build(ctx),
                    ),
            )
            .add_row(Row::stretch())
            .add_column(Column::auto())
            .add_column(Column::stretch())
            .build(ctx),
        )
<span class="boring">      .build(ctx)
</span><span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>Quite often you need to store a handle to a widget in a variable, there is one neat trick to do that preserving
the fluent syntax:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    asset::manager::ResourceManager, resource::texture::Texture,
</span><span class="boring">    gui::{
</span><span class="boring">        button::ButtonBuilder, image::ImageBuilder, widget::WidgetBuilder, UiNode,
</span><span class="boring">        UserInterface,
</span><span class="boring">    },
</span><span class="boring">    utils::into_gui_texture,
</span><span class="boring">};
</span><span class="boring">fn create_fancy_button(ui: &amp;mut UserInterface, resource_manager: ResourceManager) -&gt; Handle&lt;UiNode&gt; {
</span><span class="boring">let ctx = &amp;mut ui.build_ctx();
</span>let image;
ButtonBuilder::new(WidgetBuilder::new())
    .with_back({
        image = ImageBuilder::new(WidgetBuilder::new())
            .with_texture(into_gui_texture(
                resource_manager.request::&lt;Texture, _&gt;(&quot;path/to/your/texture&quot;),
            ))
            .build(ctx);
        image
    })
    .with_text(&quot;Click me!&quot;)
    .build(ctx)
<span class="boring">}
</span>// image now contains a handle of the Image widget 
<span class="boring">}</span></code></pre></pre>
<h2 id="should-i-create-a-custom-widget-or-use-composition-of-other-widgets"><a class="header" href="#should-i-create-a-custom-widget-or-use-composition-of-other-widgets">Should I create a custom widget or use composition of other widgets?</a></h2>
<p>The answer depends on the use case, but the general rules here is quite simple: </p>
<ul>
<li>If your widget exist in a single instance, then there is no need to create a custom widget for it.</li>
<li>If you need to create multiple instances of your widget, and each widget will carry some specific data, then you
definitely need a custom widget.</li>
</ul>
<p>Custom widgets have some limitations that could be limiting, one of them is that custom widgets do not have 
access to your code, since they're &quot;living&quot; inside UI and know nothing about the &quot;environment&quot; where they're 
being used.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="font"><a class="header" href="#font">Font</a></h1>
<p>Font is used to store graphical representation of characters. The engine supports TTF and OTF fonts, you can load
pretty much any font from the internet and use it as is.</p>
<h2 id="create-new-font"><a class="header" href="#create-new-font">Create New Font</a></h2>
<p>There are two ways to create font instance - either load font from file, or load it directly from memory.</p>
<h3 id="loading-font-from-file"><a class="header" href="#loading-font-from-file">Loading Font From File</a></h3>
<p>The easiest way to create a font is load it from file:</p>
<pre><pre class="playground"><code class="language-rust no_run edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::gui::ttf::Font;
</span>async fn load_font_from_file() -&gt; Font {
    let character_set = Font::default_char_set(); // ASCII character set.
    Font::from_file(&quot;path/to/your/font.ttf&quot;, 20.0, character_set)
        .await
        .unwrap()
}
<span class="boring">}</span></code></pre></pre>
<p>Please note, that this function is <code>async</code> due to the fact that it supports <code>fetch</code> API on WebAssembly, which does
remote file fetching which is asynchronous by its nature. If you don't plan to support WebAssembly and don't want to
use <code>async</code>, then the next section is for you.</p>
<h3 id="creating-font-from-memory"><a class="header" href="#creating-font-from-memory">Creating Font From Memory</a></h3>
<p>This option could be useful, if you already have your font loaded into memory. Loading font from data buffer is very
simple:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::gui::ttf::Font;
</span>fn load_font_from_memory(data: &amp;[u8]) -&gt; Font {
    let character_set = Font::default_char_set(); // ASCII character set.
    Font::from_memory(data, 20.0, character_set).unwrap()
}
<span class="boring">}</span></code></pre></pre>
<p><code>data</code> input parameter could be a buffer that contains any valid TTF/OTF font. For example, you can load TTF file into
a data buffer and create font using the data buffer:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::gui::ttf::Font;
</span><span class="boring">use std::{fs::File, io::Read};
</span>fn load_font_from_memory() -&gt; Font {
    let character_set = Font::default_char_set(); // ASCII character set.

    let mut data = Vec::new();
    File::open(&quot;path/to/your/font.ttf&quot;)
        .unwrap()
        .read_to_end(&amp;mut data)
        .unwrap();

    Font::from_memory(data, 20.0, character_set).unwrap()
}
<span class="boring">}</span></code></pre></pre>
<h2 id="default-font"><a class="header" href="#default-font">Default Font</a></h2>
<p>User interface provides its own font of fixed size, it is enough to cover most of the use cases, but the default font
includes only ASCII characters, if you need extended character set, you can replace default font using the following
code snippet:</p>
<pre><pre class="playground"><code class="language-rust no_run edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::gui::{ttf::Font, UserInterface};
</span>async fn set_default_font(ui: &amp;mut UserInterface) {
    // Select character set.
    let character_set = Font::korean_char_set();
    // Load font.
    let new_font = Font::from_file(&quot;path/to/your/font.ttf&quot;, 20.0, character_set)
        .await
        .unwrap();
    // Set as default font.
    ui.default_font.set(new_font)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="how-to-change-font-size"><a class="header" href="#how-to-change-font-size">How to Change Font Size</a></h2>
<p>Unfortunately, you need to create new font instance for that, there is a 
<a href="https://github.com/FyroxEngine/Fyrox/issues/74">tracking issue</a> for that. Use any method from above paragraphs.</p>
<h2 id="character-set"><a class="header" href="#character-set">Character Set</a></h2>
<p>Current font implementation requires you to define fixed character set while creating an instance. What is character
set and how it can be extended? Character set is just a set of ranges from Unicode, for example here's korean character
set:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::ops::Range;
</span>pub fn korean_char_set() -&gt; &amp;'static [Range&lt;u32&gt;] {
    &amp;[
        // Basic Latin + Latin Supplement
        0x0020..0x00FF,
        // Korean alphabets
        0x3131..0x3163,
        // Korean characters
        0xAC00..0xD7A3,
        // Invalid
        0xFFFD..0xFFFD,
    ]
}
<span class="boring">}</span></code></pre></pre>
<p>You can create custom character set yourself by defining desired ranges from Unicode.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="theme"><a class="header" href="#theme">Theme</a></h1>
<p>The engine has an ability to customize the look of widgets, however it is not centralized, and has to be done 
per widget. Check <code>Theme</code> section of each widget.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="widgets"><a class="header" href="#widgets">Widgets</a></h1>
<p>The subsections of this chapter explains how to use every widget built into Fyrox. The widgets in the table of contents to the left are ordered in alphebetical order. However, below we will order them by primary function to help introduce them to new users.</p>
<h2 id="containers"><a class="header" href="#containers">Containers</a></h2>
<p>The Container widgets primary purpose is to contain other widgets. They are mostly used as a tool to layout the UI in visually different ways.</p>
<ul>
<li><a href="fyrox/ui/./stack_panel.html">Stack panel</a>: The Stack Panel arranges widgets in a linear fashion, either vertically or horizontally depending on how it's setup.</li>
<li><a href="fyrox/ui/./wrap_panel.html">Wrap Panel</a>: The Wrap Panel arranges widgets in a linear fashion but if it overflows the widgets are continued adjacent to the first line. Can arrange widgets either vertically or horizontally depending on how it's setup.</li>
<li><a href="fyrox/ui/./grid.html">Grid</a>: The Grid arranges widgets into rows and columns with given size constraints.</li>
<li><a href="fyrox/ui/./canvas.html">Canvas</a>: The Canvas arranges widgets with pixel perfect precision.</li>
<li><a href="fyrox/ui/./window.html">Window</a>: The Window holds other widgets in a panel that can be configured at setup to be move-able, expanded and contracted via user input, exited, and have a displayed label. The window has a title bar to assist with these features.
<ul>
<li><a href="fyrox/ui/./message_box.html">Message Box</a>: The Message Box is a Window that has been streamlined to show standard confirmation/information dialogues, for example, closing a document with unsaved changes. It has a title, some text, and a fixed set of buttons (Yes, No, Cancel in different combinations).</li>
</ul>
</li>
<li><a href="fyrox/ui/./menu.html">Menu</a>: The Menu is a root container for Menu Items, an example could be a menu strip with File, Edit, View, etc items.</li>
<li><a href="fyrox/ui/./popup.html">Popup</a>: The Popup is a panel that locks input to its content while it is open. A simple example of it could be a context menu.</li>
<li><a href="fyrox/ui/./scroll_viewer.html">Scroll Viewer</a>: The ScrollViewer is a wrapper for Scroll Panel that adds two scroll bars to it.
<ul>
<li><a href="fyrox/ui/./scroll_panel.html">Scroll Panel</a>: The Scroll Panel is a panel that allows you apply some offset to children widgets. It is used to create &quot;scrollable&quot; area in conjunction with the Scroll Viewer.</li>
</ul>
</li>
<li><a href="fyrox/ui/./expander.html">Expander</a>: The Expander handles hiding and showing multiple panels of widgets in an accordian style UI element. Multiple panels can be shown or hidden at any time based on user input.</li>
<li><a href="fyrox/ui/./tab_control.html">Tab Control</a>: The Tab Control handles hiding several panels of widgets, only showing the one that the user has selected.</li>
<li><a href="fyrox/ui/./dock.html">Docking Manager</a>: The Docking manager allows you to dock windows and hold them in-place.</li>
<li><a href="fyrox/ui/./tree.html">Tree</a>: The Tree allows you to create views for hierarchical data.</li>
</ul>
<h2 id="visual"><a class="header" href="#visual">Visual</a></h2>
<p>The Visual widgets primary purpose is to provide the user feedback generally without the user directly interacting with them.</p>
<ul>
<li><a href="fyrox/ui/./text.html">Text</a>: The Text widget is used to display a string to the user.</li>
<li><a href="fyrox/ui/./image.html">Image</a>: The Image widget is used to display a pixel image to the user.</li>
<li><a href="fyrox/ui/./vector_image.html">Vector Image</a>: The Vector Image is used to render vector instructions as a graphical element.</li>
<li><a href="fyrox/ui/./rect.html">Rect</a>: The Rect allows you to specify numeric values for X, Y, Width, and Height of a rectangle.</li>
<li><a href="fyrox/ui/./progress_bar.html">Progress Bar</a>: The Progress Bar shows a bar whoes fill state can be adjusted to indicate visually how full something is, for example how close to 100% is a loading process.</li>
<li><a href="fyrox/ui/./decorator.html">Decorator</a>: The Decorator is used to style any widget. It has support for different styles depending on various events like mouse hover or click.
<ul>
<li><a href="fyrox/ui/./border.html">Border</a>: The Border widget is used in conjunction with the Decorator widget to provide configurable boarders to any widget for styling purposes.</li>
</ul>
</li>
</ul>
<h2 id="controls-1"><a class="header" href="#controls-1">Controls</a></h2>
<p>Control widgets primary purpose is to provide users with intractable UI elements to control some aspect of the program.</p>
<ul>
<li><a href="fyrox/ui/./creating_button.html">Button</a>: The Button provides a press-able control that can contain other UI elements, for example a Text or Image Widget.</li>
<li><a href="fyrox/ui/./checkbox/check_box.html">Check Box</a>: The Check Box is a toggle-able control that can contain other UI elements, for example a Text or Image Widget.</li>
<li><a href="fyrox/ui/./text_box.html">Text Box</a>: The Text Box is a control that allows the editing of text.</li>
<li><a href="fyrox/ui/./scroll_bar.html">Scroll Bar</a>: The Scroll Bar provides a scroll bar like control that can be used on it's own as a data input or with certain other widgets to provide content scrolling capabilities.</li>
<li><a href="fyrox/ui/./numeric.html">Numeric Field</a>: The Numeric Field provides the ability to adjust a number via increment and decrement buttons or direct input. The number can be constrained to remain inside a specific range or have a specific step.</li>
<li><a href="fyrox/ui/./range.html">Range</a>: The Range allows the user to edit a numeric range - specify its begin and end values.</li>
<li><a href="fyrox/ui/./list_view.html">List View</a>: The List View provides a control where users can select from a list of items.</li>
<li><a href="fyrox/ui/./dropdown_list.html">Dropdown List</a>: The Drop-down List is a control which shows the currently selected item and provides a drop-down list to select an item.</li>
<li><a href="fyrox/ui/./file_browser.html">File Browser</a>: The File Browser is a tree view of the file system allowing the user to select a file or folder.</li>
<li><a href="fyrox/ui/./curve_editor.html">Curve Editor</a>: The CurveEditor allows editing parametric curves - adding points, and setting up transitions (constant, linear, cubic) between them.</li>
<li><a href="fyrox/ui/./inspector.html">Inspector</a>: The Inspector automatically creates and handles the input of UI elements based on a populated Inspector Context given to it allowing the user to adjust values of a variety of models without manually creating UI's for each type.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="button"><a class="header" href="#button">Button</a></h1>
<h2 id="simple-button-with-text"><a class="header" href="#simple-button-with-text">Simple button with text</a></h2>
<p>To create a simple button with text you should do something like this:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    gui::{button::ButtonBuilder, widget::WidgetBuilder, UiNode, UserInterface},
</span><span class="boring">};
</span>fn create_button(ui: &amp;mut UserInterface) -&gt; Handle&lt;UiNode&gt; {
    ButtonBuilder::new(WidgetBuilder::new())
        .with_text(&quot;Click me!&quot;)
        .build(&amp;mut ui.build_ctx())
}
<span class="boring">}</span></code></pre></pre>
<p>How to create a button using custom dimensions (100x100) and custom text alignment (Vertical centered and Horizontal 
right aligned):</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    gui::{button::ButtonBuilder, widget::WidgetBuilder, UiNode, UserInterface, HorizontalAlignment, VerticalAlignment, text::TextBuilder},
</span><span class="boring">};
</span>fn create_button(ui: &amp;mut UserInterface) -&gt; Handle&lt;UiNode&gt; {
    ButtonBuilder::new(
        WidgetBuilder::new()
            .with_width(100.0)
            .with_height(100.0),
    )
    .with_content(
        TextBuilder::new(WidgetBuilder::new())
            .with_text(&quot;Click me!&quot;)
            .with_horizontal_text_alignment(HorizontalAlignment::Right)
            .with_vertical_text_alignment(VerticalAlignment::Center)
            .build(&amp;mut ui.build_ctx()),
    )
    .build(&amp;mut ui.build_ctx())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="a-button-with-image"><a class="header" href="#a-button-with-image">A button with image</a></h2>
<p>More fancy-looking button with an image as a background could be created using this code snippet:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::pool::Handle, resource::texture::Texture,
</span><span class="boring">    asset::manager::ResourceManager,
</span><span class="boring">    gui::{
</span><span class="boring">        button::ButtonBuilder, image::ImageBuilder, widget::WidgetBuilder, UiNode,
</span><span class="boring">        UserInterface,
</span><span class="boring">    },
</span><span class="boring">    utils::into_gui_texture,
</span><span class="boring">};
</span>fn create_fancy_button(ui: &amp;mut UserInterface, resource_manager: ResourceManager) -&gt; Handle&lt;UiNode&gt; {
    let ctx = &amp;mut ui.build_ctx();

    ButtonBuilder::new(WidgetBuilder::new())
        .with_back(
            ImageBuilder::new(WidgetBuilder::new())
                .with_texture(into_gui_texture(
                    resource_manager.request::&lt;Texture, _&gt;(&quot;path/to/your/texture&quot;),
                ))
                .build(ctx),
        )
        .with_text(&quot;Click me!&quot;)
        .build(ctx)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="message-handling"><a class="header" href="#message-handling">Message handling</a></h2>
<p>When clicked, a button sends a <code>ButtonMessage::Click</code> message, you can catch it in your code and do something
useful:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    event_loop::ControlFlow,
</span><span class="boring">    gui::{button::ButtonMessage, message::UiMessage, UiNode},
</span><span class="boring">    plugin::PluginContext,
</span><span class="boring">};
</span><span class="boring">
</span>struct Game {
    button: Handle&lt;UiNode&gt;,
}

impl Game {
    fn on_ui_message(
        &amp;mut self,
        context: &amp;mut PluginContext,
        message: &amp;UiMessage,
        control_flow: &amp;mut ControlFlow,
    ) {
        if let Some(ButtonMessage::Click) = message.data() {
            if message.destination() == self.button {
                //
                // Insert your code clicking handling code here.
                //
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="using-a-button-to-exit-the-game"><a class="header" href="#using-a-button-to-exit-the-game">Using a button to exit the game</a></h2>
<p>This example shows how to create a button that will close your game.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    event_loop::ControlFlow,
</span><span class="boring">    gui::{
</span><span class="boring">        button::{ButtonBuilder, ButtonMessage},
</span><span class="boring">        message::UiMessage,
</span><span class="boring">        text::TextBuilder,
</span><span class="boring">        widget::WidgetBuilder,
</span><span class="boring">        UiNode, UserInterface,
</span><span class="boring">    },
</span><span class="boring">    plugin::PluginContext,
</span><span class="boring">};
</span><span class="boring">
</span>struct Game {
    quit_button_handle: Handle&lt;UiNode&gt;,
}

fn create_button(ui: &amp;mut UserInterface) -&gt; Handle&lt;UiNode&gt; {
    ButtonBuilder::new(WidgetBuilder::new())
        .with_content(
            TextBuilder::new(WidgetBuilder::new())
                .with_text(&quot;Quit&quot;)
                .build(&amp;mut ui.build_ctx()),
        )
        .build(&amp;mut ui.build_ctx())
}

impl Game {
    fn new(ctx: PluginContext) -&gt; Self {
        Self {
            quit_button_handle: create_button(ctx.user_interface),
        }
    }

    fn on_ui_message(
        &amp;mut self,
        context: &amp;mut PluginContext,
        message: &amp;UiMessage,
        control_flow: &amp;mut ControlFlow,
    ) {
        if let Some(ButtonMessage::Click) = message.data() {
            if message.destination() == self.quit_button_handle {
                *control_flow = ControlFlow::Exit;
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="border"><a class="header" href="#border">Border</a></h1>
<p>The Border widget provides a stylized, static border around its child widget. Below is an example of creating a 1 pixel
thick border around a button widget:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span>use fyrox::gui::{
    UserInterface,
    widget::WidgetBuilder, 
    border::BorderBuilder, 
    Thickness, 
    text::TextBuilder,
};

fn create_border_with_button(ui: &amp;mut UserInterface) {
    BorderBuilder::new(
        WidgetBuilder::new()
            .with_child(
                TextBuilder::new(WidgetBuilder::new())
                    .with_text(&quot;I'm boxed in!&quot;)
                    .build(&amp;mut ui.build_ctx())
            )
    )
    //You can also use Thickness::uniform(1.0)
    .with_stroke_thickness(Thickness {left: 1.0, right: 1.0, top: 1.0, bottom: 1.0})
    .build(&amp;mut ui.build_ctx());
}
<span class="boring">}</span></code></pre></pre>
<p>As with other UI elements, we create the border using the BorderBuilder helper struct. The widget that should have a
border around it is added as a child of the base WidgetBuilder, and the border thickness can be set by providing a 
Thickness struct to the BorderBuilder's <em>with_stroke_thickness</em> function. This means you can set different thicknesses 
for each edge of the border.</p>
<p>You can style the border by creating a Brush and setting the border's base WidgetBuilder's foreground or background. 
The foreground will set the style of the boarder itself, while setting the background will color the whole area within 
the border. Below is an example of a blue border and a red background with white text inside.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::gui::{
</span><span class="boring">    brush::Brush,
</span><span class="boring">    core::color::Color,
</span><span class="boring">    widget::WidgetBuilder, 
</span><span class="boring">    text::TextBuilder,
</span><span class="boring">    border::BorderBuilder,
</span><span class="boring">    UserInterface,
</span><span class="boring">    Thickness, 
</span><span class="boring">};
</span>
<span class="boring">let mut ui = UserInterface::new(Default::default());
</span>
BorderBuilder::new(
    WidgetBuilder::new()
        .with_foreground(Brush::Solid(Color::opaque(0, 0, 200)))
        .with_background(Brush::Solid(Color::opaque(200, 0, 0)))
        .with_child(
            TextBuilder::new(WidgetBuilder::new())
                .with_text(&quot;I'm boxed in Blue and backed in Red!&quot;)
                .build(&amp;mut ui.build_ctx())
        )
)
.with_stroke_thickness(Thickness {left: 2.0, right: 2.0, top: 2.0, bottom: 2.0})
.build(&amp;mut ui.build_ctx());
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="canvas"><a class="header" href="#canvas">Canvas</a></h1>
<p>Canvas is a panel widget that allows you to explicitly set coordinates for children widgets. It is useful when you 
need to manually control position of children widgets. Root UI node is canvas, so any widgets that are not attached
to any other widgets can have explicit position.</p>
<h2 id="how-to-create-13"><a class="header" href="#how-to-create-13">How to create</a></h2>
<p>Use <code>CanvasBuilder</code> to create Canvas instance:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    gui::{canvas::CanvasBuilder, widget::WidgetBuilder, BuildContext, UiNode},
</span><span class="boring">};
</span><span class="boring">
</span>fn create_canvas(ctx: &amp;mut BuildContext) -&gt; Handle&lt;UiNode&gt; {
    CanvasBuilder::new(WidgetBuilder::new()).build(ctx)
}
<span class="boring">}</span></code></pre></pre>
<p>Canvas does not have any specific options, so its creation is probably simplest of all widgets.</p>
<h2 id="how-to-position-children-nodes"><a class="header" href="#how-to-position-children-nodes">How to position children nodes</a></h2>
<p>Use <code>.with_desired_position</code> on children widgets to set specific position:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::{algebra::Vector2, pool::Handle},
</span><span class="boring">    gui::{
</span><span class="boring">        button::ButtonBuilder, canvas::CanvasBuilder, text::TextBuilder, widget::WidgetBuilder,
</span><span class="boring">        BuildContext, UiNode,
</span><span class="boring">    },
</span><span class="boring">};
</span><span class="boring">
</span>fn create_canvas_with_children_widgets(ctx: &amp;mut BuildContext) -&gt; Handle&lt;UiNode&gt; {
    CanvasBuilder::new(
        WidgetBuilder::new()
            .with_child(
                TextBuilder::new(
                    WidgetBuilder::new().with_desired_position(Vector2::new(100.0, 200.0)),
                )
                .with_text(&quot;Simple Text at (100.0, 200.0)&quot;)
                .build(ctx),
            )
            .with_child(
                ButtonBuilder::new(
                    WidgetBuilder::new().with_desired_position(Vector2::new(200.0, 100.0)),
                )
                .with_text(&quot;Simple Button at (200.0, 100.0)&quot;)
                .build(ctx),
            ),
    )
    .build(ctx)
}
<span class="boring">}</span></code></pre></pre>
<p>The code snippet will create a canvas with a text widget located at (100.0, 200.0) relative to top-left corner of the
canvas and a button located at (200.0, 100.0).</p>
<h2 id="tips"><a class="header" href="#tips">Tips</a></h2>
<p>Canvas provides infinite bounds for children widgets, this means that children nodes <strong>will not</strong> be stretched, instead
they'll shrink to fit their content. For example, a button with a text will take slightly bigger rectangle than the 
text bounds.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="check-box"><a class="header" href="#check-box">Check box</a></h1>
<p>Checkbox is a UI widget that have three states - <code>Checked</code>, <code>Unchecked</code> and <code>Undefined</code>. In most cases it is used
only with two values which fits in <code>bool</code> type. Third, undefined, state is used for specific situations when your
data have such state. </p>
<h2 id="how-it-looks"><a class="header" href="#how-it-looks">How it looks</a></h2>
<p>Checkbox in <code>Checked</code> state:</p>
<p><img src="fyrox/ui/checkbox/checked.PNG" alt="Checked" /></p>
<p>Checkbox in <code>Unchecked</code> state:</p>
<p><img src="fyrox/ui/checkbox/unchecked.PNG" alt="Unchecked" /></p>
<h2 id="how-to-create-14"><a class="header" href="#how-to-create-14">How to create</a></h2>
<p>To create a checkbox you should do something like this:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    gui::{check_box::CheckBoxBuilder, widget::WidgetBuilder, UiNode, UserInterface},
</span><span class="boring">};
</span>fn create_checkbox(ui: &amp;mut UserInterface) -&gt; Handle&lt;UiNode&gt; {
    CheckBoxBuilder::new(WidgetBuilder::new())
        // A custom value can be set during initialization.
        .checked(Some(true))
        .build(&amp;mut ui.build_ctx())
}
<span class="boring">}</span></code></pre></pre>
<p>The above code will create a checkbox without any textual info, but usually checkboxes have some useful info
near them. To create such checkbox, you could use <code>.with_content(..)</code> method which accepts any widget handle.
For checkbox with text, you could use <code>TextBuilder</code> to create textual content, for checkbox with text - use 
<code>ImageBuilder</code>. As already said, you're free to use any widget handle there.</p>
<p>Here's an example of checkbox with textual content.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    gui::{
</span><span class="boring">        check_box::CheckBoxBuilder, text::TextBuilder, widget::WidgetBuilder, UiNode,
</span><span class="boring">        UserInterface,
</span><span class="boring">    },
</span><span class="boring">};
</span>fn create_checkbox(ui: &amp;mut UserInterface) -&gt; Handle&lt;UiNode&gt; {
    let ctx = &amp;mut ui.build_ctx();

    CheckBoxBuilder::new(WidgetBuilder::new())
        // A custom value can be set during initialization.
        .checked(Some(true))
        .with_content(
            TextBuilder::new(WidgetBuilder::new())
                .with_text(&quot;This is a checkbox&quot;)
                .build(ctx),
        )
        .build(ctx)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="message-handling-1"><a class="header" href="#message-handling-1">Message handling</a></h2>
<p>Checkboxes are not static widget and have multiple states. To handle a message from a checkbox, you need to handle
a <code>CheckBoxMessage::Check</code> message. To do so, you can do something like this:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    engine::Engine,
</span><span class="boring">    event_loop::ControlFlow,
</span><span class="boring">    gui::{check_box::CheckBoxMessage, message::UiMessage, UiNode},
</span><span class="boring">    plugin::PluginContext,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">struct Foo {
</span><span class="boring">    checkbox: Handle&lt;UiNode&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Foo {
</span>fn on_ui_message(
    &amp;mut self,
    context: &amp;mut PluginContext,
    message: &amp;UiMessage,
    control_flow: &amp;mut ControlFlow,
) {
    if let Some(CheckBoxMessage::Check(value)) = message.data() {
        if message.destination() == self.checkbox {
            //
            // Insert your clicking handling code here.
            //
        }
    }
}
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>Keep in mind that checkbox (as any other widget) generates <code>WidgetMessage</code> instances. You can catch them too and
do a custom handling if you need.</p>
<h2 id="theme-1"><a class="header" href="#theme-1">Theme</a></h2>
<p>Checkbox can be fully customized to have any look you want, there are few methods that will help you with 
customization:</p>
<ol>
<li><code>.with_content(..)</code> - sets the content that will be shown near the checkbox. </li>
<li><code>.with_check_mark(..)</code> - sets the widget that will be used as checked icon. </li>
<li><code>.with_uncheck_mark(..)</code> - sets the widget that will be used as unchecked icon.</li>
<li><code>.with_undefined_mark(..)</code> - sets the widget that will be used as undefined icon.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="curve-editor-wip"><a class="header" href="#curve-editor-wip">Curve editor (WIP)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="decorator"><a class="header" href="#decorator">Decorator</a></h1>
<p>A visual element that changes its appearance by listening specific events. It can have &quot;pressed&quot;, &quot;hover&quot;, &quot;selected&quot; or 
normal appearance:</p>
<ul>
<li><code>Pressed</code> - enables on mouse down message.</li>
<li><code>Selected</code> - whether decorator selected or not.</li>
<li><code>Hovered</code> - mouse is over the decorator.</li>
<li><code>Normal</code> - not selected, pressed or hovered.</li>
</ul>
<p>This element is widely used to provide some generic visual behaviour for various widgets. For example, it used in 
buttons, tree items, dropdown list items, etc.; in other words - everywhere where a widget needs to give visual 
feedback the user.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="docking-manager-wip"><a class="header" href="#docking-manager-wip">Docking manager (WIP)</a></h1>
<p>Docking manager allows you to dock windows and hold them in-place.</p>
<p>Docking manager can hold any types of UI elements, but dragging works only
for windows.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dropdown-list-wip"><a class="header" href="#dropdown-list-wip">Dropdown list (WIP)</a></h1>
<p>Drop-down list. This is control which shows currently selected item and provides drop-down
list to select its current item. It is build using composition with standard list view.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="expander-wip"><a class="header" href="#expander-wip">Expander (WIP)</a></h1>
<p>Expander is a collapsible container for child widgets with a field that describes a content. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="file-browser-wip"><a class="header" href="#file-browser-wip">File browser (WIP)</a></h1>
<p>FileBrowser widget is a simple file system tree, FileSelector is a window with FileBrowser and few buttons.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="grid"><a class="header" href="#grid">Grid</a></h1>
<p>Grids are one of several methods to position multiple widgets in relation to each other. A Grid Widget, as the name 
implies, is able to position children widgets into a grid of specifically sized rows and columns. </p>
<p>Here is a simple example that positions several text widgets into a 2 by 2 grid:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::gui::{
</span><span class="boring">    UiNode,
</span><span class="boring">    BuildContext,
</span><span class="boring">    widget::WidgetBuilder,
</span><span class="boring">    text::TextBuilder,
</span><span class="boring">    grid::{GridBuilder, GridDimension},
</span><span class="boring">};
</span>
fn create_text_grid(ctx: &amp;mut BuildContext) -&gt; fyrox::core::pool::Handle&lt;UiNode&gt; {

    GridBuilder::new(
        WidgetBuilder::new()
            .with_child(
                TextBuilder::new(WidgetBuilder::new())
                    .with_text(&quot;top left &quot;)
                    .build(ctx)
            )
            .with_child(
                TextBuilder::new(
                    WidgetBuilder::new()
                        .on_column(1)
                )
                    .with_text(&quot; top right&quot;)
                    .build(ctx)
            )
            .with_child(
                TextBuilder::new(
                    WidgetBuilder::new()
                        .on_row(1)
                )
                    .with_text(&quot;bottom left &quot;)
                    .build(ctx)
            )
            .with_child(
                TextBuilder::new(
                    WidgetBuilder::new()
                        .on_row(1)
                        .on_column(1)
                )
                    .with_text(&quot; bottom right&quot;)
                    .build(ctx)
            )
        )
            .add_row(GridDimension::auto())
            .add_row(GridDimension::auto())
            .add_column(GridDimension::auto())
            .add_column(GridDimension::auto())
            .build(ctx)
}
<span class="boring">}</span></code></pre></pre>
<p>As with other UI widgets, Grids are created via the GridBuilder struct. Each widget whose position should be controlled
by the Grid should be added as a child of the GridBuilder's base widget.</p>
<p>You then need to tell each child what row and column it belongs to via the on_column and on_row functions of their base
widget. By default, all children will be placed into row 0, column 0. </p>
<p>After that you need to provide sizing constraints for each row and column to the GridBuilder by using the add_row and 
add_column functions while providing a GridDimension instance to the call. GridDimension can be constructed with the 
following functions:</p>
<ul>
<li>GridDimension::auto() - Sizes the row or column so it's just large enough to fit the largest child's size.</li>
<li>GridDimension::stretch() - Stretches the row or column to fill the parent's available space, if multiple rows or 
columns have this option the size is evenly distributed between them.</li>
<li>GridDimension::strict(f32) - Sets the row or column to be exactly the given value of pixels long. So a row will only 
be the given number of pixels wide, while a column will be that many pixels tall.</li>
</ul>
<p>You can add any number of rows and columns to a grid widget, and each grid cell does <strong>not</strong> need to have a UI widget 
in it to be valid. For example you can add a column and set it to a specific size via strict to provide spacing between
two other columns.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="image"><a class="header" href="#image">Image</a></h1>
<p>Image widget is a rectangle with a texture, it is used draw custom bitmaps. The UI in the engine is vector-based, Image
widget is the only way to draw a bitmap. Usage of the Image is very simple:</p>
<h2 id="usage-3"><a class="header" href="#usage-3">Usage</a></h2>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    asset::manager::ResourceManager, resource::texture::Texture,
</span><span class="boring">    gui::{image::ImageBuilder, widget::WidgetBuilder, BuildContext, UiNode},
</span><span class="boring">    utils::into_gui_texture,
</span><span class="boring">};
</span>
fn create_image(ctx: &amp;mut BuildContext, resource_manager: ResourceManager) -&gt; Handle&lt;UiNode&gt; {
    // You must explicitly set width and height of the image, otherwise it will collapse to a
    // point and you won't see anything.
    let width = 100.0;
    let height = 100.0;
    ImageBuilder::new(WidgetBuilder::new().with_width(width).with_height(height))        
        .with_texture(into_gui_texture(
            // Ask resource manager to load a texture.
            resource_manager.request::&lt;Texture, _&gt;(&quot;path/to/your/texture.png&quot;),
        ))
        .build(ctx)
}
<span class="boring">}</span></code></pre></pre>
<p>There are one common pitfall when using Image widget - you must explicitly set width and height of the image if it is
not placed to some panel, that will stretch it automatically. In other words if you created an image with undefined
width and height, then putting it to some container like Grid' cell will stretch the image to fit cell bounds.</p>
<h2 id="equal-size-to-source"><a class="header" href="#equal-size-to-source">Equal Size to Source</a></h2>
<p>Sometimes you need your image to have equal size with the texture it uses, in this case you should fetch texture 
bounds first and then create an Image width these bounds:</p>
<pre><pre class="playground"><code class="language-rust no_run edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    asset::manager::ResourceManager, resource::texture::Texture,
</span><span class="boring">    gui::{image::ImageBuilder, widget::WidgetBuilder, BuildContext, UiNode},
</span><span class="boring">    resource::texture::TextureKind,
</span><span class="boring">    utils::into_gui_texture,
</span><span class="boring">};
</span>
async fn create_image(
    ctx: &amp;mut BuildContext&lt;'_&gt;,
    resource_manager: ResourceManager,
) -&gt; Handle&lt;UiNode&gt; {
    // Ask resource manager to load the texture and wait while it loads using `.await`.
    if let Ok(texture) = resource_manager
        .request::&lt;Texture, _&gt;(&quot;path/to/your/texture.png&quot;)
        .await
    {
        // A texture can be not only rectangular, so we must check that.
        let texture_kind = texture.data_ref().kind();
        if let TextureKind::Rectangle { width, height } = texture_kind {
            return ImageBuilder::new(
                WidgetBuilder::new()
                    .with_width(width as f32)
                    .with_height(height as f32),
            )
            .with_texture(into_gui_texture(texture))
            .build(ctx);
        }
    }

    // Image wasn't created.
    Handle::NONE
}
<span class="boring">}</span></code></pre></pre>
<p>This function can be used as-is whenever you need to create an Image that have same size as the source file. It is
marked as <code>async</code> because resource loading (texture is a resource) happens in separate thread and to get actual texture
data we must wait it. If you don't want to use async, then use any executor to block current thread and execute the
promise immediately:</p>
<pre><pre class="playground"><code class="language-rust no_run edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    asset::manager::ResourceManager,
</span><span class="boring">    gui::{BuildContext, UiNode},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">async fn create_image(
</span><span class="boring">    ctx: &amp;mut BuildContext&lt;'_&gt;,
</span><span class="boring">    resource_manager: ResourceManager,
</span><span class="boring">) -&gt; Handle&lt;UiNode&gt; {
</span><span class="boring">    Handle::NONE
</span><span class="boring">}
</span>fn create_image_sync(
    ctx: &amp;mut BuildContext&lt;'_&gt;,
    resource_manager: ResourceManager,
) -&gt; Handle&lt;UiNode&gt; {
    fyrox::core::futures::executor::block_on(create_image(ctx, resource_manager))
}
<span class="boring">}</span></code></pre></pre>
<h2 id="vertical-flip"><a class="header" href="#vertical-flip">Vertical Flip</a></h2>
<p>In some rare cases you need to flip your source image before showing it, there is <code>.with_flip</code> option for that:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    asset::manager::ResourceManager, resource::texture::Texture,
</span><span class="boring">    gui::{image::ImageBuilder, widget::WidgetBuilder, BuildContext, UiNode},
</span><span class="boring">    utils::into_gui_texture,
</span><span class="boring">};
</span>
fn create_image(ctx: &amp;mut BuildContext, resource_manager: ResourceManager) -&gt; Handle&lt;UiNode&gt; {
    ImageBuilder::new(WidgetBuilder::new().with_width(100.0).with_height(100.0))
        .with_flip(true) // Flips an image vertically
        .with_texture(into_gui_texture(
            resource_manager.request::&lt;Texture, _&gt;(&quot;path/to/your/texture.png&quot;),
        ))
        .build(ctx)
}
<span class="boring">}</span></code></pre></pre>
<p>There are few places where it can be helpful:</p>
<ul>
<li>You're using render target as a source texture for your Image instance, render targets are vertically flipped due
to mismatch of coordinates of UI and graphics API. The UI has origin at left top corner, the graphics API - bottom left.</li>
<li>Your source image is vertically mirrored.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="inspector-wip"><a class="header" href="#inspector-wip">Inspector (WIP)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="list-view-wip"><a class="header" href="#list-view-wip">List view (WIP)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="menu-wip"><a class="header" href="#menu-wip">Menu (WIP)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="message-box-wip"><a class="header" href="#message-box-wip">Message box (WIP)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="numericupdown-widget"><a class="header" href="#numericupdown-widget">NumericUpDown Widget</a></h1>
<p>A widget that handles numbers of any machine type. Use this widget if you need to provide input field for a numeric
type.</p>
<h2 id="how-to-create-15"><a class="header" href="#how-to-create-15">How to create</a></h2>
<p>Use <code>NumericUpDownBuilder</code> to create a new instance of the <code>NumericUpDown</code> widget:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::pool::Handle, gui::{numeric::NumericUpDownBuilder, widget::WidgetBuilder, BuildContext, UiNode}
</span><span class="boring">};
</span>fn create_numeric_widget(ctx: &amp;mut BuildContext) -&gt; Handle&lt;UiNode&gt; {
 NumericUpDownBuilder::new(WidgetBuilder::new())
     .with_value(123.0f32)
     .build(ctx)
}
<span class="boring">}</span></code></pre></pre>
<p>Keep in mind, that this widget is generic and can work with any numeric types. Sometimes you might get an &quot;unknown type&quot;
error message from the compiler (especially if your use <code>123.0</code> ambiguous numeric literals), in this case you need to
specify the type explicitly (<code>NumericUpDownBuilder::&lt;f32&gt;::new...</code>).</p>
<h2 id="limits-1"><a class="header" href="#limits-1">Limits</a></h2>
<p>This widget supports lower and upper limits for the values. It can be specified by <code>NumericUpDownBuilder::with_min_value</code>
and <code>NumericUpDownBuilder::with_max_value</code> (or changed at runtime using <code>NumericUpDownMessage::MinValue</code> and <code>NumericUpDownMessage::MaxValue</code>
messages):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::pool::Handle, gui::{numeric::NumericUpDownBuilder, widget::WidgetBuilder, BuildContext, UiNode}
</span><span class="boring">};
</span>fn create_numeric_widget(ctx: &amp;mut BuildContext) -&gt; Handle&lt;UiNode&gt; {
 NumericUpDownBuilder::new(WidgetBuilder::new())
     .with_value(123.0f32)
     .with_min_value(42.0)
     .with_max_value(666.0)
     .build(ctx)
}
<span class="boring">}</span></code></pre></pre>
<p>The default limits for min and max are <code>NumericType::min_value</code> and <code>NumericType::max_value</code> respectively.</p>
<h2 id="step"><a class="header" href="#step">Step</a></h2>
<p>Since the value of the widget can be changed via up/down arrow buttons (also by dragging the cursor up or down on them), the widget
provides a way to set the step of the value (for increment and decrement at the same time):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::pool::Handle, gui::{numeric::NumericUpDownBuilder, widget::WidgetBuilder, BuildContext, UiNode}
</span><span class="boring">};
</span>fn create_numeric_widget(ctx: &amp;mut BuildContext) -&gt; Handle&lt;UiNode&gt; {
 NumericUpDownBuilder::new(WidgetBuilder::new())
     .with_value(125.0f32)
     .with_step(5.0)
     .build(ctx)
}
<span class="boring">}</span></code></pre></pre>
<p>The default value of the step is <code>NumericType::one</code>.</p>
<h2 id="precision"><a class="header" href="#precision">Precision</a></h2>
<p>It is possible to specify <strong>visual</strong> rounding of the value up to desired decimal place (it does not change the way how
the actual value is rounded). For example, in some cases you might get irrational values such as <code>1/3 ~= 0.33333333</code>,
but you interested in only first two decimal places. In this case you can set the precision to <code>2</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::pool::Handle, gui::{numeric::NumericUpDownBuilder, widget::WidgetBuilder, BuildContext, UiNode}
</span><span class="boring">};
</span>fn create_numeric_widget(ctx: &amp;mut BuildContext) -&gt; Handle&lt;UiNode&gt; {
 NumericUpDownBuilder::new(WidgetBuilder::new())
     .with_value(0.3333333f32)
     .with_precision(2)
     .build(ctx)
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="popup-wip"><a class="header" href="#popup-wip">Popup (WIP)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="progress-bar-wip"><a class="header" href="#progress-bar-wip">Progress bar (WIP)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="range-wip"><a class="header" href="#range-wip">Range (WIP)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rect-editor-wip"><a class="header" href="#rect-editor-wip">Rect editor (WIP)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scroll-bar-wip"><a class="header" href="#scroll-bar-wip">Scroll bar (WIP)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scroll-panel-wip"><a class="header" href="#scroll-panel-wip">Scroll panel (WIP)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scroll-viewer-wip"><a class="header" href="#scroll-viewer-wip">Scroll viewer (WIP)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stack-panel"><a class="header" href="#stack-panel">Stack Panel</a></h1>
<p>Stack Panels are one of several methods to position multiple widgets in relation to each other. A Stack Panel Widget 
orders it's children widgets linerarly, aka in a stack of widgets, based on the order the widgets were added as children. 
So the first widget added will be at the top or left most position, while each additional widget will decend from top to 
bottom or continue from left most to right most. The below example code places 3 text widgets into a vertical stack:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::gui::{
</span><span class="boring">    UiNode,
</span><span class="boring">    BuildContext,
</span><span class="boring">    widget::WidgetBuilder,
</span><span class="boring">    text::TextBuilder,
</span><span class="boring">    stack_panel::StackPanelBuilder,
</span><span class="boring">};
</span>
fn create_stack_panel(ctx: &amp;mut BuildContext) -&gt; fyrox::core::pool::Handle&lt;UiNode&gt; {

    StackPanelBuilder::new(
        WidgetBuilder::new()
            .with_child(
                TextBuilder::new(WidgetBuilder::new())
                    .with_text(&quot;Top&quot;)
                    .build(ctx)
            )
            .with_child(
                TextBuilder::new(WidgetBuilder::new())
                    .with_text(&quot;Middle&quot;)
                    .build(ctx)
            )
            .with_child(
                TextBuilder::new(WidgetBuilder::new())
                    .with_text(&quot;Bottom&quot;)
                    .build(ctx)
            )
    )
        .build(ctx)
    
}
<span class="boring">}</span></code></pre></pre>
<p>As you can see from the example, creating a Stack Panel uses the standard method for creating widgets. Create a new 
StackPanelBuilder and provide it with a new WidgetBuilder. Adding widgets to the stack is done by adding childeren to 
the StackBuilder's WidgetBuilder.</p>
<h2 id="stack-panel-orientation"><a class="header" href="#stack-panel-orientation">Stack Panel Orientation</a></h2>
<p>As has been indicated, Stack Panels can be oriented to order it's children either Vertical, from top to bottom, or 
Horizontal, Left most to right most. This is done using the StackPanelBuilder's with_orientation function providing it 
with a gui::Orientation enum value. <strong>By default</strong> all Stack Panel's are Vertical.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::gui::{
</span><span class="boring">    Orientation,
</span><span class="boring">    BuildContext,
</span><span class="boring">    widget::WidgetBuilder,
</span><span class="boring">    stack_panel::StackPanelBuilder,
</span><span class="boring">};
</span>
<span class="boring">fn build(ctx: &amp;mut BuildContext) {
</span>StackPanelBuilder::new(
    WidgetBuilder::new()
)
    .with_orientation(Orientation::Horizontal)
    .build(ctx);
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tab-control"><a class="header" href="#tab-control">Tab Control</a></h1>
<p>The Tab Control handles the visibility of several tabs, only showing a single tab that the user has selected via the 
tab header buttons. Each tab is defined via a Tab Definition struct which takes two widgets, one representing the tab
header and the other representing the tab's contents.</p>
<p>The following example makes a 2 tab, Tab Control containing some simple text widgets:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::gui::{
</span><span class="boring">    BuildContext,
</span><span class="boring">    widget::WidgetBuilder,
</span><span class="boring">    text::TextBuilder,
</span><span class="boring">    tab_control::{TabControlBuilder, TabDefinition},
</span><span class="boring">};
</span>
fn create_tab_control(ctx: &amp;mut BuildContext) {

    TabControlBuilder::new(WidgetBuilder::new())
        .with_tab(
            TabDefinition{
                header: TextBuilder::new(WidgetBuilder::new())
                            .with_text(&quot;First&quot;)
                            .build(ctx),
                            
                content: TextBuilder::new(WidgetBuilder::new())
                            .with_text(&quot;First tab's contents!&quot;)
                            .build(ctx),
            }
        )
        .with_tab(
            TabDefinition{
                header: TextBuilder::new(WidgetBuilder::new())
                            .with_text(&quot;Second&quot;)
                            .build(ctx),
                            
                content: TextBuilder::new(WidgetBuilder::new())
                            .with_text(&quot;Second tab's contents!&quot;)
                            .build(ctx),
            }
        )
        .build(ctx);
}
<span class="boring">}</span></code></pre></pre>
<p>As usual, we create the widget via the builder TabControlBuilder. Tabs are added via the <em>with_tab</em> function in the 
order you want them to appear, passing each call to the function a directly constructed TabDefinition struct. Tab 
headers will appear from left to right at the top with tab contents shown directly below the tabs. As usual, if no 
constraints are given to the base WidgetBuilder of the TabControlBuilder, then the tab content area will resize to fit
whatever is in the current tab.</p>
<p>Each tab's content is made up of one widget, so to be useful you will want to use one of the container widgets to help 
arrange additional widgets within the tab.</p>
<h2 id="tab-header-styling"><a class="header" href="#tab-header-styling">Tab Header Styling</a></h2>
<p>Notice that you can put any widget into the tab header, so if you want images to denote each tab you can add an Image
widget to each header, and if you want an image <em>and</em> some text you can insert a stack panel with an image on top and 
text below it. </p>
<p>You will also likely want to style whatever widgets you add. As can be seen when running the code example above, the 
tab headers are scrunched when there are no margins provided to your text widgets. Simply add something like the below 
code example and you will get a decent look:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::gui::{
</span><span class="boring">    BuildContext,
</span><span class="boring">    widget::WidgetBuilder,
</span><span class="boring">    text::TextBuilder,
</span><span class="boring">    Thickness, 
</span><span class="boring">    tab_control::{TabDefinition},
</span><span class="boring">};
</span>
<span class="boring">fn build(ctx: &amp;mut BuildContext) {
</span><span class="boring">TabDefinition{
</span>header: TextBuilder::new(
            WidgetBuilder::new()
                .with_margin(Thickness::uniform(4.0))
        )
            .with_text(&quot;First&quot;)
            .build(ctx),
<span class="boring">content: Default::default()
</span><span class="boring">};
</span><span class="boring">}
</span>
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="text"><a class="header" href="#text">Text</a></h1>
<p>Text is a simple widget that allows you to print text on screen. It has various options like word wrapping, text
alignment, and so on.</p>
<h2 id="how-to-create-16"><a class="header" href="#how-to-create-16">How to create</a></h2>
<p>An instance of the Text widget could be created like so:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    gui::{text::TextBuilder, widget::WidgetBuilder, UiNode, UserInterface},
</span><span class="boring">};
</span>fn create_text(ui: &amp;mut UserInterface, text: &amp;str) -&gt; Handle&lt;UiNode&gt; {
    TextBuilder::new(WidgetBuilder::new())
        .with_text(text)
        .build(&amp;mut ui.build_ctx())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="text-alignment-and-word-wrapping"><a class="header" href="#text-alignment-and-word-wrapping">Text alignment and word wrapping</a></h2>
<p>There are various text alignment options for both vertical and horizontal axes. Typical alignment values are:
<code>Left</code>, <code>Center</code>, <code>Right</code> for horizontal axis, and <code>Top</code>, <code>Center</code>, <code>Bottom</code> for vertical axis. An instance of 
centered text could be created like so:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    gui::{
</span><span class="boring">        text::TextBuilder, widget::WidgetBuilder, HorizontalAlignment, UiNode, UserInterface,
</span><span class="boring">        VerticalAlignment,
</span><span class="boring">    },
</span><span class="boring">};
</span>fn create_centered_text(ui: &amp;mut UserInterface, text: &amp;str) -&gt; Handle&lt;UiNode&gt; {
    TextBuilder::new(WidgetBuilder::new())
        .with_horizontal_text_alignment(HorizontalAlignment::Center)
        .with_vertical_text_alignment(VerticalAlignment::Center)
    .with_text(text)
    .build(&amp;mut ui.build_ctx())
}
<span class="boring">}</span></code></pre></pre>
<p>Long text is usually needs to wrap on available bounds, there are three possible options for word wrapping:
<code>NoWrap</code>, <code>Letter</code>, <code>Word</code>. An instance of text with word-based wrapping could be created like so:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    gui::{
</span><span class="boring">        formatted_text::WrapMode, text::TextBuilder, widget::WidgetBuilder, UiNode,
</span><span class="boring">        UserInterface,
</span><span class="boring">    },
</span><span class="boring">};
</span>fn create_text_with_word_wrap(ui: &amp;mut UserInterface, text: &amp;str) -&gt; Handle&lt;UiNode&gt; {
    TextBuilder::new(WidgetBuilder::new())
        .with_wrap(WrapMode::Word)
        .with_text(text)
        .build(&amp;mut ui.build_ctx())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="background"><a class="header" href="#background">Background</a></h2>
<p>If you need to have a text with some background, you should use <a href="fyrox/ui/./border.html">Border</a> widget as a parent widget of your 
text. <strong>Caveat:</strong> <code>Widget::background</code> is ignored for <code>Text</code> widget!</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::{color::Color, pool::Handle},
</span><span class="boring">    gui::{
</span><span class="boring">        border::BorderBuilder, brush::Brush, text::TextBuilder, widget::WidgetBuilder, UiNode,
</span><span class="boring">        UserInterface,
</span><span class="boring">    },
</span><span class="boring">};
</span><span class="boring">
</span>fn create_text_with_background(ui: &amp;mut UserInterface, text: &amp;str) -&gt; Handle&lt;UiNode&gt; {
    let text_widget =
        TextBuilder::new(WidgetBuilder::new().with_foreground(Brush::Solid(Color::RED)))
            .with_text(text)
            .build(&amp;mut ui.build_ctx());
    BorderBuilder::new(
        WidgetBuilder::new()
            .with_child(text_widget) // &lt;-- Text is now a child of the border
            .with_background(Brush::Solid(Color::opaque(50, 50, 50))),
    )
    .build(&amp;mut ui.build_ctx())
}
<span class="boring">}</span></code></pre></pre>
<p>Keep in mind that now the text widget is a child widget of the border, so if you need to position the text, you should
position the border, not the text.</p>
<h2 id="fonts-and-colors"><a class="header" href="#fonts-and-colors">Fonts and colors</a></h2>
<p>To set a color of the text just use <code>.with_foreground(..)</code> of the <code>WidgetBuilder</code> while building the text instance:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::{color::Color, pool::Handle},
</span><span class="boring">    gui::{brush::Brush, text::TextBuilder, widget::WidgetBuilder, UiNode, UserInterface},
</span><span class="boring">};
</span>fn create_text(ui: &amp;mut UserInterface, text: &amp;str) -&gt; Handle&lt;UiNode&gt; {
    //               vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
    TextBuilder::new(WidgetBuilder::new().with_foreground(Brush::Solid(Color::RED)))
        .with_text(text)
        .build(&amp;mut ui.build_ctx())
}
<span class="boring">}</span></code></pre></pre>
<p>By default, text is created with default font, however it is possible to set any custom font:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::{futures::executor::block_on, pool::Handle},
</span><span class="boring">    gui::{
</span><span class="boring">        text::TextBuilder,
</span><span class="boring">        ttf::{Font, SharedFont},
</span><span class="boring">        widget::WidgetBuilder,
</span><span class="boring">        UiNode, UserInterface,
</span><span class="boring">    },
</span><span class="boring">};
</span>
fn load_font() -&gt; SharedFont {
    // Choose desired character set, default is Basic Latin + Latin Supplement.
    // Character set is a set of ranges with Unicode code points.
    let character_set = Font::default_char_set();

    // Normally `block_on` should be avoided.
    let font = block_on(Font::from_file(
        &quot;path/to/your/font.ttf&quot;,
        24.0,
        character_set,
    ))
    .unwrap();

    SharedFont::new(font)
}

fn create_text(ui: &amp;mut UserInterface, text: &amp;str) -&gt; Handle&lt;UiNode&gt; {
    TextBuilder::new(WidgetBuilder::new())
        .with_font(load_font())
        .with_text(text)
        .build(&amp;mut ui.build_ctx())
}
<span class="boring">}</span></code></pre></pre>
<p>Please refer to <a href="fyrox/ui/font.html">Font</a> chapter to learn more about fonts.</p>
<h3 id="font-size"><a class="header" href="#font-size">Font size</a></h3>
<p>There is no way to change font size without changing the entire font used by Text, it is known issue and there is
<a href="https://github.com/FyroxEngine/Fyrox/issues/74">tracking issue</a> for that. Check <a href="fyrox/ui/font.html">Font</a> chapter to learn how 
to create fonts.</p>
<h2 id="shadows-1"><a class="header" href="#shadows-1">Shadows</a></h2>
<p>Text widget supports shadows effect to add contrast to your text, which could be useful to make text readable independent
on the background colors. This effect could be used for subtitles. Shadows are pretty easy to add, all you need to do
is to enable them, setup desired thickness, offset and brush (solid color or gradient).</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::{algebra::Vector2, color::Color, pool::Handle},
</span><span class="boring">    gui::{brush::Brush, text::TextBuilder, widget::WidgetBuilder, UiNode, UserInterface},
</span><span class="boring">};
</span><span class="boring">
</span>fn create_red_text_with_black_shadows(ui: &amp;mut UserInterface, text: &amp;str) -&gt; Handle&lt;UiNode&gt; {
    TextBuilder::new(WidgetBuilder::new().with_foreground(Brush::Solid(Color::RED)))
        .with_text(text)
        // Enable shadows.
        .with_shadow(true)
        // Black shadows.
        .with_shadow_brush(Brush::Solid(Color::BLACK))
        // 1px thick.
        .with_shadow_dilation(1.0)
        // Offset the shadow slightly to the right-bottom.
        .with_shadow_offset(Vector2::new(1.0, 1.0))
        .build(&amp;mut ui.build_ctx())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="messages"><a class="header" href="#messages">Messages</a></h2>
<p>Text widget can accept the following list of messages at runtime (respective constructors are name with small letter - 
<code>TextMessage::Text -&gt; TextMessage::text(widget_handle, direction, text)</code>):</p>
<ul>
<li><code>TextMessage::Text</code> - sets new text for a <code>Text</code> widget.</li>
<li><code>TextMessage::Wrap</code> - sets new <a href="fyrox/ui/text.html#text-alignment-and-word-wrapping">wrapping mode</a>. </li>
<li><code>TextMessage::Font</code> - sets new <a href="fyrox/ui/text.html#fonts-and-colors">font</a> </li>
<li><code>TextMessage::VerticalAlignment</code> and <code>TextMessage::HorizontalAlignment</code> sets 
<a href="fyrox/ui/text.html#text-alignment-and-word-wrapping">vertical and horizontal</a> text alignment respectively.</li>
<li><code>TextMessage::Shadow</code> - enables or disables <a href="fyrox/ui/text.html#shadows">shadow casting</a></li>
<li><code>TextMessage::ShadowDilation</code> - sets &quot;thickness&quot; of the shadows under the tex.</li>
<li><code>TextMessage::ShadowBrush</code> - sets shadow brush (allows you to change color and even make shadow with color gradients).</li>
<li><code>TextMessage::ShadowOffset</code> - sets offset of the shadows.</li>
</ul>
<p>An example of changing text at runtime could be something like this:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    gui::{
</span><span class="boring">        message::{MessageDirection},
</span><span class="boring">        UiNode, UserInterface,
</span><span class="boring">        text::TextMessage
</span><span class="boring">    },
</span><span class="boring">};
</span>fn request_change_text(ui: &amp;UserInterface, text_widget_handle: Handle&lt;UiNode&gt;, text: &amp;str) {
    ui.send_message(TextMessage::text(
        text_widget_handle,
        MessageDirection::ToWidget,
        text.to_owned(),
    ))
}
<span class="boring">}</span></code></pre></pre>
<p>Please keep in mind, that like any other situation when you &quot;changing&quot; something via messages, you should remember
that the change is <strong>not</strong> immediate. The change will be applied on <code>ui.poll_message(..)</code> call somewhere in your
code (or will be done automatically if you're using scripts or Framework (obsolete)).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="text-box"><a class="header" href="#text-box">Text Box</a></h1>
<p>TextBox is a text widget that allows you to edit text and create specialized input fields. It has various options like 
word wrapping, text alignment, and so on.</p>
<h2 id="how-to-create-17"><a class="header" href="#how-to-create-17">How to create</a></h2>
<p>An instance of the TextBox widget could be created like so:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    gui::{text_box::TextBoxBuilder, widget::WidgetBuilder, UiNode, UserInterface},
</span><span class="boring">};
</span>fn create_text_box(ui: &amp;mut UserInterface, text: &amp;str) -&gt; Handle&lt;UiNode&gt; {
    TextBoxBuilder::new(WidgetBuilder::new())
        .with_text(text)
        .build(&amp;mut ui.build_ctx())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="text-alignment-and-word-wrapping-1"><a class="header" href="#text-alignment-and-word-wrapping-1">Text alignment and word wrapping</a></h2>
<p>There are various text alignment options for both vertical and horizontal axes. Typical alignment values are:
<code>Left</code>, <code>Center</code>, <code>Right</code> for horizontal axis, and <code>Top</code>, <code>Center</code>, <code>Bottom</code> for vertical axis. An instance of
centered text could be created like so:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    gui::{
</span><span class="boring">        text_box::TextBoxBuilder, widget::WidgetBuilder, HorizontalAlignment, UiNode, UserInterface,
</span><span class="boring">        VerticalAlignment,
</span><span class="boring">    },
</span><span class="boring">};
</span>fn create_centered_text(ui: &amp;mut UserInterface, text: &amp;str) -&gt; Handle&lt;UiNode&gt; {
    TextBoxBuilder::new(WidgetBuilder::new())
        .with_horizontal_text_alignment(HorizontalAlignment::Center)
        .with_vertical_text_alignment(VerticalAlignment::Center)
    .with_text(text)
    .build(&amp;mut ui.build_ctx())
}
<span class="boring">}</span></code></pre></pre>
<p>Long text is usually needs to wrap on available bounds, there are three possible options for word wrapping:
<code>NoWrap</code>, <code>Letter</code>, <code>Word</code>. An instance of text with word-based wrapping could be created like so:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    gui::{
</span><span class="boring">        formatted_text::WrapMode, text_box::TextBoxBuilder, widget::WidgetBuilder, UiNode,
</span><span class="boring">        UserInterface,
</span><span class="boring">    },
</span><span class="boring">};
</span>fn create_text_with_word_wrap(ui: &amp;mut UserInterface, text: &amp;str) -&gt; Handle&lt;UiNode&gt; {
    TextBoxBuilder::new(WidgetBuilder::new())
        .with_wrap(WrapMode::Word)
        .with_text(text)
        .build(&amp;mut ui.build_ctx())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="fonts-and-colors-1"><a class="header" href="#fonts-and-colors-1">Fonts and colors</a></h2>
<p>To set a color of the text just use <code>.with_foreground(..)</code> of the <code>WidgetBuilder</code> while building the text instance:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::{color::Color, pool::Handle},
</span><span class="boring">    gui::{brush::Brush, text_box::TextBoxBuilder, widget::WidgetBuilder, UiNode, UserInterface},
</span><span class="boring">};
</span>fn create_text(ui: &amp;mut UserInterface, text: &amp;str) -&gt; Handle&lt;UiNode&gt; {
    //                  vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
    TextBoxBuilder::new(WidgetBuilder::new().with_foreground(Brush::Solid(Color::RED)))
        .with_text(text)
        .build(&amp;mut ui.build_ctx())
}
<span class="boring">}</span></code></pre></pre>
<p>By default, text is created with default font, however it is possible to set any custom font:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::{futures::executor::block_on, pool::Handle},
</span><span class="boring">    gui::{
</span><span class="boring">        text_box::TextBoxBuilder,
</span><span class="boring">        ttf::{Font, SharedFont},
</span><span class="boring">        widget::WidgetBuilder,
</span><span class="boring">        UiNode, UserInterface,
</span><span class="boring">    },
</span><span class="boring">};
</span>
fn load_font() -&gt; SharedFont {
    // Choose desired character set, default is Basic Latin + Latin Supplement.
    // Character set is a set of ranges with Unicode code points.
    let character_set = Font::default_char_set();

    // Normally `block_on` should be avoided.
    let font = block_on(Font::from_file(
        &quot;path/to/your/font.ttf&quot;,
        24.0,
        character_set,
    ))
    .unwrap();

    SharedFont::new(font)
}

fn create_text(ui: &amp;mut UserInterface, text: &amp;str) -&gt; Handle&lt;UiNode&gt; {
    TextBoxBuilder::new(WidgetBuilder::new())
        .with_font(load_font())
        .with_text(text)
        .build(&amp;mut ui.build_ctx())
}
<span class="boring">}</span></code></pre></pre>
<p>Please refer to <a href="fyrox/ui/font.html">Font</a> chapter to learn more about fonts.</p>
<h3 id="font-size-1"><a class="header" href="#font-size-1">Font size</a></h3>
<p>There is no way to change font size without changing the entire font used by Text, it is known issue and there is
<a href="https://github.com/FyroxEngine/Fyrox/issues/74">tracking issue</a> for that. Check <a href="fyrox/ui/font.html">Font</a> chapter to learn how
to create fonts.</p>
<h2 id="messages-1"><a class="header" href="#messages-1">Messages</a></h2>
<p>TextBox widget accepts the following list of messages:</p>
<ul>
<li><code>TextBoxMessage::SelectionBrush</code> - change the brush that is used to highlight selection.</li>
<li><code>TextBoxMessage::CaretBrush</code> - changes the brush of the caret (small blinking vertical line).</li>
<li><code>TextBoxMessage::TextCommitMode</code> - changes the <a href="fyrox/ui/text_box.html#text-commit-mode">text commit mode</a>.</li>
<li><code>TextBoxMessage::Multiline</code> - makes the TextBox either multiline (<code>true</code>) or single line (<code>false</code>)</li>
<li><code>TextBoxMessage::Editable</code> - enables or disables editing of the text. </li>
</ul>
<p><strong>Important:</strong> Please keep in mind, that TextBox widget also accepts <code>Text</code> <a href="fyrox/ui/text.html#messages">widget messages</a>. An 
example of changing text at runtime could be something like this:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    gui::{
</span><span class="boring">        message::{MessageDirection},
</span><span class="boring">        UiNode, UserInterface,
</span><span class="boring">        text::TextMessage
</span><span class="boring">    },
</span><span class="boring">};
</span>fn request_change_text(ui: &amp;UserInterface, text_box_widget_handle: Handle&lt;UiNode&gt;, text: &amp;str) {
    ui.send_message(TextMessage::text(
        text_box_widget_handle,
        MessageDirection::ToWidget,
        text.to_owned(),
    ))
}
<span class="boring">}</span></code></pre></pre>
<p>Please keep in mind, that like any other situation when you &quot;changing&quot; something via messages, you should remember
that the change is <strong>not</strong> immediate. The change will be applied on <code>ui.poll_message(..)</code> call somewhere in your
code (or will be done automatically if you're using scripts or Framework (obsolete)).</p>
<h2 id="shortcuts"><a class="header" href="#shortcuts">Shortcuts</a></h2>
<p>There are number of default shortcuts that can be used to speed up text editing:</p>
<ul>
<li><code>Ctrl+A</code> - select all</li>
<li><code>Ctrl+C</code> - copy selected text</li>
<li><code>Ctrl+V</code> - paste text from clipboard</li>
<li><code>Ctrl+Home</code> - move caret to the beginning of the text</li>
<li><code>Ctrl+End</code> - move caret to the beginning of the text</li>
<li><code>Shift+Home</code> - select everything from current caret position until the beginning of current line</li>
<li><code>Shift+End</code> - select everything from current caret position until the end of current line</li>
<li><code>Arrows</code> - move caret accordingly</li>
<li><code>Delete</code> - deletes next character</li>
<li><code>Backspace</code> - deletes previous character</li>
<li><code>Enter</code> - new line (if multiline mode is set) or <code>commit</code> message</li>
</ul>
<h2 id="multiline-text-box"><a class="header" href="#multiline-text-box">Multiline Text Box</a></h2>
<p>By default, text box will not add new line character to the text if you press <code>Enter</code> on keyboard. To enable this 
functionality use <code>.with_multiline(true)</code></p>
<h2 id="read-only-mode"><a class="header" href="#read-only-mode">Read-only Mode</a></h2>
<p>You can enable or disable content editing by using read-only mode. Use <code>.with_readonly</code> at build stage.</p>
<h2 id="mask-character"><a class="header" href="#mask-character">Mask Character</a></h2>
<p>You can specify replacement character for every other characters, this is useful option for password fields. Use 
<code>.with_mask_char</code> at build stage. For example, you can set replacement character to asterisk <code>*</code> using 
<code>.with_mask_char(Some('*'))</code></p>
<h2 id="text-commit-mode"><a class="header" href="#text-commit-mode">Text Commit Mode</a></h2>
<p>In many situations you don't need the text box to send <code>new text</code> message every new character, you either want this 
message if <code>Enter</code> key is pressed or TextBox has lost keyboard focus (or both). There is <code>with_text_commit_mode</code> on builder 
specifically for that purpose. Use one of the following modes:</p>
<ul>
<li><code>TextCommitMode::Immediate</code> - text box will immediately send <code>Text</code> message after any change.</li>
<li><code>TextCommitMode::LostFocus</code> - text box will send <code>Text</code> message only when it loses focus.</li>
<li><code>TextCommitMode::LostFocusPlusEnter</code> - text box will send <code>Text</code> message when it loses focus or if Enter key was pressed. 
This is <strong>default</strong> behavior. In case of multiline text box hitting Enter key won't commit text!</li>
</ul>
<h2 id="filtering"><a class="header" href="#filtering">Filtering</a></h2>
<p>It is possible specify custom input filter, it can be useful if you're creating special input fields like numerical or
phone number. A filter can be specified at build stage like so:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    gui::{text_box::TextBoxBuilder, widget::WidgetBuilder, UiNode, UserInterface},
</span><span class="boring">};
</span><span class="boring">use std::{cell::RefCell, rc::Rc};
</span>fn create_text_box(ui: &amp;mut UserInterface) -&gt; Handle&lt;UiNode&gt; {
    TextBoxBuilder::new(WidgetBuilder::new())
        // Specify a filter that will pass only digits.
        .with_filter(Rc::new(RefCell::new(|c: char| c.is_ascii_digit())))
        .build(&amp;mut ui.build_ctx())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="style"><a class="header" href="#style">Style</a></h2>
<p>You can change brush of caret by using <code>.with_caret_brush</code> and also selection brush by using <code>.with_selection_brush</code>,
it could be useful if you don't like default colors.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tree-wip"><a class="header" href="#tree-wip">Tree (WIP)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vector-image-wip"><a class="header" href="#vector-image-wip">Vector image (WIP)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="window"><a class="header" href="#window">Window</a></h1>
<p>The Window widget provides a standared window that can contain another widget. Based on setting windows can be configured
so users can do any of the following:</p>
<ul>
<li>Movable by the user. Not configurable.</li>
<li>Have title text on the title bar. Set by the <em>with_title</em> function.</li>
<li>Able to be exited by the user. Set by the <em>can_close</em> function.</li>
<li>Able to be minimized to just the Title bar, and of course maximized again. Set by the <em>can_minimize</em> function.</li>
<li>Able to resize the window. Set by the <em>can_resize</em> function.</li>
</ul>
<p>As with other UI elements, you create and configure the window using the WindowBuilder.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span>use fyrox::{
    core::{pool::Handle, algebra::Vector2},
    gui::{
        window::{WindowBuilder, WindowTitle}, 
        text::TextBuilder, 
        widget::WidgetBuilder, 
        UiNode, 
        UserInterface
    },
};

fn create_window(ui: &amp;mut UserInterface) {
    WindowBuilder::new(
        WidgetBuilder::new()
            .with_desired_position(Vector2::new(300.0, 0.0))
            .with_width(300.0),
    )
    .with_content(
        TextBuilder::new(WidgetBuilder::new())
            .with_text(&quot;Example Window content.&quot;)
            .build(&amp;mut ui.build_ctx())
    )
    .with_title(WindowTitle::text(&quot;Window&quot;))
    .can_close(true)
    .can_minimize(true)
    .open(true)
    .can_resize(false)
    .build(&amp;mut ui.build_ctx());
}
<span class="boring">}</span></code></pre></pre>
<p>You will likely want to constrain the initial size of the window to somethig as shown in the example by providing a set
width and/or height to the base WidgetBuilder. Otherwise it will expand to fit it's content.</p>
<p>You may also want to set an inital position with the <em>with_desired_position</em> function called on the base WidgetBuilder 
which sets the position of the window's top-left corner. Otherwise all your windows will start with it's top-left corner
at 0,0 and be stacked on top of eachother.</p>
<p>Windows can only contain a single direct child widget, set by using the <em>with_content</em> function. 
Additional calls to <em>with_content</em> replaces the widgets given in previous calls, and the old widgets exist outside the 
window, so you should delete old widgets before changing a window's widget.  If you want multiple widgets, you need to 
use one of the layout container widgets like the Grid, Stack Panel, etc then add the additional widgets to that widget 
as needed.</p>
<p>The Window is a user editable object, but can only be affected by UI Messages they trigger if the message's corresponding
variable has been set to true aka what is set by the <em>can_close</em>, <em>can_minimize</em>, and <em>can_resize</em> functions.</p>
<h2 id="initial-open-state"><a class="header" href="#initial-open-state">Initial Open State</a></h2>
<p>By default, the window will be created in the open, or maximized, state. You can manually set this state via the <em>open</em>
function providing a true or false as desired.</p>
<h2 id="styling-the-buttons"><a class="header" href="#styling-the-buttons">Styling the Buttons</a></h2>
<p>The window close and minimise buttons can be configured with the <em>with_close_button</em> and <em>with_minimize_button</em> functions.
You will want to pass them a button widget, but can do anything else you like past that.</p>
<h2 id="modal-aka-forced-focus"><a class="header" href="#modal-aka-forced-focus">Modal (AKA Forced Focus)</a></h2>
<p>A Modal in UI design terms indicates a window or box that has forced focus. The user is not able to interact with anything 
else until the modal is dissmissed. </p>
<p>Any window can be set and unset as a modal via the <em>modal</em> function.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wrap-panel"><a class="header" href="#wrap-panel">Wrap panel</a></h1>
<p>Wrap panel is used to stack children widgets either in vertical or horizontal direction with overflow - every widget
that does not have enough space on current line, will automatically be placed on the next line.</p>
<h2 id="how-to-create-18"><a class="header" href="#how-to-create-18">How to create</a></h2>
<p>Use <code>WrapPanelBuilder</code> to create new wrap panel instance:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    gui::{
</span><span class="boring">        widget::WidgetBuilder, wrap_panel::WrapPanelBuilder, BuildContext, Orientation, UiNode,
</span><span class="boring">    },
</span><span class="boring">};
</span><span class="boring">
</span>fn create_wrap_panel(ctx: &amp;mut BuildContext) -&gt; Handle&lt;UiNode&gt; {
    WrapPanelBuilder::new(WidgetBuilder::new())
        .with_orientation(Orientation::Horizontal)
        .build(ctx)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="orientation"><a class="header" href="#orientation">Orientation</a></h2>
<p>Wrap panel can stack your widgets either in vertical or horizontal direction. Use <code>.with_orientation</code> while building 
the panel to switch orientation to desired.</p>
<h2 id="use-cases"><a class="header" href="#use-cases">Use cases</a></h2>
<p>One of many use case examples could be picture gallery, or asset browser in the Fyroxed:</p>
<p><img src="fyrox/ui/wrap_panel.png" alt="wrap panel" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="serialization"><a class="header" href="#serialization">Serialization</a></h1>
<p>Serialization is a process that converts arbitrary objects into a set of bytes that can be stored to disk or to send
them over the network. An opposite to serialization - deserialization - is a process that restores objects from a given
set of bytes. Serialization often used to make save/load functionality in games.</p>
<p>Fyrox has built-in serializer that is used all over the place the engine and which is represented by a <code>Visit</code> trait. 
<code>Visit</code> name could be confusing, but it is called after well-known <a href="https://en.wikipedia.org/wiki/Visitor_pattern">Visitor</a> 
design pattern. </p>
<p>Serialization and deserialization itself is handled by <code>Visitor</code>, it can be created in two modes: read and write. See
mode info in respective sections below.</p>
<h2 id="usage-4"><a class="header" href="#usage-4">Usage</a></h2>
<p>There are two main ways to implement <code>Visit</code> trait, each way serves for specific cases. Let's understand which one to
use when.</p>
<h3 id="proc-macro-derivevisit"><a class="header" href="#proc-macro-derivevisit">Proc-macro <code>#[derive(Visit)]</code></a></h3>
<p>The engine provides proc-macro, that uses code generation to implement <code>Visit</code> trait for you. All you need to do is 
to add <code>#[derive(Visit)]</code> to your struct/enum. Code generation in most cases is capable to generate typical 
implementation for serialization/deserialization. You should prefer proc-macro to manual implementation in most cases.</p>
<p>The macro supports few very useful attributes, that can be added to fields of a struct/enum:</p>
<ul>
<li><code>#[visit(optional)]</code> - forces the engine to ignore any errors that may occur during deserialization, leaving a field's
value in default state. Very useful option if you're adding a new field to your structure, otherwise the engine will
refuse to continue loading of your struct. In case of scripts, deserialization will stop on missing field, and it will
be partially loaded.</li>
<li><code>#[visit(rename = &quot;new_name&quot;)]</code> - replaces the name of a field with given value. Useful if you need to rename a field
in the code, but leave backward compatibility with previous versions.</li>
<li><code>#[visit(skip)]</code> - ignores a field completely. Useful if you don't want to serialize a field at all, or a field is not
serializable.</li>
</ul>
<p>To use the macro, you must import all types related to <code>Visit</code> trait by <code>use fyrox::core::visitor::prelude::*;</code>. Here's
an example:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span>use fyrox::core::visitor::prelude::*;

#[derive(Visit)]
struct MyStruct {
    foo: u32,

    #[visit(rename = &quot;baz&quot;)]
    foobar: f32,

    #[visit(optional)]
    optional: String,

    #[visit(skip)]
    ignored: usize,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="manual-implementation"><a class="header" href="#manual-implementation">Manual implementation</a></h3>
<p>Manual implementation of the trait gives you an opportunity to fix compatibility issues, do some specific actions
during serialization (logging, for instance). Typical manual implementation could look like this:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span>use fyrox::core::visitor::prelude::*;

struct MyStruct {
    foo: u32,
    foobar: f32,
    optional: String,
    ignored: usize,
}

impl Visit for MyStruct {
    fn visit(&amp;mut self, name: &amp;str, visitor: &amp;mut Visitor) -&gt; VisitResult {
        // Create a region first.
        let mut region = visitor.enter_region(name)?;

        // Add fields to it.
        self.foo.visit(&quot;Foo&quot;, &amp;mut region)?;

        // Manually rename the field for serialization.
        self.foobar.visit(&quot;Baz&quot;, &amp;mut region)?;

        // Ignore result for option field.
        let _ = self.optional.visit(&quot;Baz&quot;, &amp;mut region);

        // Ignore `self.ignored`

        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This code pretty much shows the result of macro expansion from the previous section. As you can see, proc-macro saves
you from writing tons of boilerplate code.</p>
<p>Implementing <code>Visit</code> trait is a first step, the next step is to either serialize an object or deserialize it. See
the following section for more info.</p>
<h2 id="serialization-and-deserialization"><a class="header" href="#serialization-and-deserialization">Serialization and Deserialization</a></h2>
<p>To serialize an object all you need to do is to create an instance of a Visitor in either read or write mode and use it
like so:</p>
<pre><pre class="playground"><code class="language-rust no_run edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span>use fyrox::core::visitor::prelude::*;
use std::path::Path;

#[derive(Visit, Default)]
struct MyStruct {
    foo: u32,

    #[visit(rename = &quot;baz&quot;)]
    foobar: f32,

    #[visit(optional)]
    optional: String,

    #[visit(skip)]
    ignored: usize,
}

async fn visit_my_structure(path: &amp;Path, object: &amp;mut MyStruct, write: bool) -&gt; VisitResult {
    if write {
        let mut visitor = Visitor::new();
        object.visit(&quot;MyObject&quot;, &amp;mut visitor)?;

        // Dump to the path.
        visitor.save_binary(path)
    } else {
        let mut visitor = Visitor::load_binary(path).await?;

        // Create default instance of an object.
        let mut my_object = MyStruct::default();

        // &quot;Fill&quot; it with contents from visitor.
        my_object.visit(&quot;MyObject&quot;, &amp;mut visitor)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The key function here is <code>visit_my_structure</code> which works in both serialization and deserialization modes depending on
<code>write</code> flag value. </p>
<p>When <code>write</code> is true (serialization), we're creating a new empty visitor and filling it with values from our <code>object</code> 
and then &quot;dump&quot; its content to binary file.</p>
<p>When <code>write</code> is false (deserialization), we're loading contents of a file, creating the object in its default state and 
then &quot;filling&quot; it with values from the visitor.</p>
<h2 id="environment"><a class="header" href="#environment">Environment</a></h2>
<p>Sometimes there is a need to pass custom data to <code>visit</code> methods, one of the ways to do this is to use <code>blackboard</code> field
of the visitor:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span>use fyrox::core::visitor::prelude::*;
use std::sync::Arc;

struct MyStruct {
    // Fields are intentionally omitted.
}

struct MyEnvironment {
    some_data: String,
}

impl Visit for MyStruct {
    fn visit(&amp;mut self, name: &amp;str, visitor: &amp;mut Visitor) -&gt; VisitResult {
        if let Some(environment) = visitor
            .blackboard
            .get::&lt;MyEnvironment&gt;()            
        {
            println!(&quot;{}&quot;, environment.some_data);
        }

        Ok(())
    }
}

fn serialize_with_environment() {
    let mut my_object = MyStruct {};

    let mut visitor = Visitor::new();

    visitor.blackboard.register(Arc::new(MyEnvironment {
        some_data: &quot;Foobar&quot;.to_owned(),
    }));

    my_object.visit(&quot;MyObject&quot;, &amp;mut visitor).unwrap();
}
<span class="boring">}</span></code></pre></pre>
<h2 id="limitations-5"><a class="header" href="#limitations-5">Limitations</a></h2>
<p>All fields of your structure must implement <code>Default</code> trait, this is essential limitation because deserialization must
have a way to create an instance of an object for you. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="saved-games-wip"><a class="header" href="#saved-games-wip">Saved Games (WIP)</a></h1>
<p>Saved game is used to store progress made in a play-through of a game to disk or some other storage. It is very important
for pretty much every game and this chapter will help you to understand basic concepts of saved games in the engine.</p>
<h2 id="saved-game-structure"><a class="header" href="#saved-game-structure">Saved Game Structure</a></h2>
<p>This could sound weird, but saved game in most cases is just a scene with additional data. Let's understand why. At first,
when you're making a save file you need to take a &quot;snapshot&quot; of your game world. Essential way of storing such data is
a scene. Secondly, game plugins is also may store some data that should be saved. By these two facts, it is quite easy
to get a full picture: to make a save all you need to do is to serialize current scene, serialize some other data and 
just &quot;dump&quot; it to a file. You might ask: is this efficient to serialize the entire scene? In short: yes. A bit more
detailed answer: when you serialize a scene, it does not store everything, it only stores <em>changed</em> fields and references
to external assets.</p>
<p>To load a save file you need to do pretty much the same, but instead of serializing things, you need to deserialize 
data from file into a scene and restore data for plugins. So how the engine is able to restore the data on load if it
does not store everything? If you carefully read the book, you might already know the answer -
<a href="fyrox/serialization//src/fyrox/scene/inheritance.html">property inheritance</a>. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="editor-3"><a class="header" href="#editor-3">Editor</a></h1>
<p>This section of the book covers various aspects of the editor. Keep in mind, that this section covers aspects of the 
editor, that does not have direct relations with engine entities. For example, this section covers 
<a href="fyrox/editor/settings.html">Editor Settings</a>, but does not cover <a href="fyrox/editor/../animation/editor.html">Animation Editor</a>. This is because, it 
is better to show how to use a thing from both sides at once (code and editor), than split it to separate sections.</p>
<p>In this section, you'll know how to use editor-specific parts of the engine, how to use special tools it provides.
Check next chapters to learn more about a part that interests you now.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="settings-1"><a class="header" href="#settings-1">Settings</a></h1>
<p>This chapter should help you to have better understanding of how to configure the editor and which settings 
are responsible for what.</p>
<p><img src="fyrox/editor/settings.png" alt="settings" /></p>
<h2 id="selection"><a class="header" href="#selection">Selection</a></h2>
<p>This section contains options for objects selection.</p>
<ul>
<li><code>Ignore Back Faces</code> - if set, forces mouse picking to ignore back faces of triangles, allowing you to &quot;click-thru&quot; 
triangles from back side. It is useful to pick objects in scenes where you have a ceiling, if the ceiling is one-sided,
then all clicks will pass through it allowing you to select objects below the ceiling.</li>
</ul>
<h2 id="graphics"><a class="header" href="#graphics">Graphics</a></h2>
<p>Options in this section defines quality settings for rendering. It directly affects performance and can be used to
see how well your scene will be rendered with different options. Almost everything in this section is very well 
covered in <a href="fyrox/editor/../rendering/settings.html">Quality Settings section</a>. The rest of the fields described below.</p>
<ul>
<li><code>Z Near</code> - defines near clipping plane for main preview camera in the scene.</li>
<li><code>Z Far</code> - defines far clipping plane for main preview camera in the scene.</li>
</ul>
<h2 id="debugging"><a class="header" href="#debugging">Debugging</a></h2>
<p>This section contains options for visual debugging, it helps you to see invisible geometry, such as bounding boxes,
physical objects, etc.</p>
<ul>
<li><code>Show Physics</code> - if set, shows physical entities in wireframe mode using debug renderer. It is useful to see where
physical entities are, and what shape they have.</li>
<li><code>Show Bounds</code> - if set, shows bounding boxes of scene nodes.</li>
<li><code>Show Tbn</code> - if set, shows tangent-binormal-normal basis of every mesh in the scene. It can be useful to debug 
graphical issues related to incorrect tangent space.</li>
</ul>
<h2 id="move-mode-settings"><a class="header" href="#move-mode-settings">Move Mode Settings</a></h2>
<p>Options in this section responsible for behaviour of Move interaction mode (a tool that allows you to move a node
with a gizmo).</p>
<ul>
<li><code>Grid Snapping</code> - if set, restricts movement to a 3D grid nodes with axes steps defined by Snap Step parameter
for respective axis.</li>
<li><code>X/Y/Z Snap Step</code> - defines snapping step (in meters) on respective axis.</li>
</ul>
<h2 id="rotate-mode-settings"><a class="header" href="#rotate-mode-settings">Rotate Mode Settings</a></h2>
<p>This section contains options for Rotate interaction mode (a tool that allows you to rotate a node with a gizmo).</p>
<ul>
<li><code>Angle Snapping</code> - if set, restricts rotation around each axis to a series of marks with uniform
angular step added to imaginary dial.</li>
<li><code>X/Y/Z Snap Step</code> - defines snapping step (in radians) around respective axis.</li>
</ul>
<h2 id="model"><a class="header" href="#model">Model</a></h2>
<p>Options in this section affects how the editor handles <a href="fyrox/editor/../resources/model.html">Model</a> assets.</p>
<ul>
<li><code>Instantiation Scale</code> - defines a scale that will be applied to a root node of every Model resource being instantiated
in the editor. It is useful if you have tons of Model resources that are either too large or too small, and you want 
to re-scale them automatically.</li>
</ul>
<h2 id="camera"><a class="header" href="#camera">Camera</a></h2>
<p>This section contains options of editor camera that is used in Scene Preview window. </p>
<ul>
<li><code>Speed</code> - speed of camera in meters per second.</li>
<li><code>Invert Dragging</code> - if set, inverts dragging of the camera via middle mouse button.</li>
<li><code>Drag Speed</code> - defines how fast the camera will move while being dragged via middle mouse button.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="miscellaneous"><a class="header" href="#miscellaneous">Miscellaneous</a></h1>
<p>This section contains information about miscellaneous things, which does not deserve separate section.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="logging"><a class="header" href="#logging">Logging</a></h1>
<p>The engine has built-in logger that allows you to trace execution of your game by creating log entries when needed.</p>
<p><img src="fyrox/misc/log.png" alt="Log" /></p>
<p>The window allows you to select severity of the messages that will be put in the window:</p>
<ul>
<li><code>Info+</code> will show all messages with <code>Info</code>, <code>Warning</code>, <code>Error</code> severities.</li>
<li><code>Warning+</code> will show all messages with <code>Warning</code> and <code>Error</code> severities.</li>
<li><code>Error</code> will show all messages with only <code>Error</code> severity.</li>
</ul>
<p>Each log entry can be copied to the clipboard by right-clicking on it and pressing <code>Copy</code> in the context menu. You can
also clear the log using <code>Clear</code> button.</p>
<h2 id="writing-to-the-log"><a class="header" href="#writing-to-the-log">Writing to the log</a></h2>
<p>You can use one of <code>Log::info</code>, <code>Log::warn</code>, <code>Log::err</code> methods, or use <code>Log::writeln</code> with severity specified. It is also
possible to select desired severity level:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::core::log::{Log, MessageKind};
</span>// These lines will be printed.
Log::info(&quot;This is some info&quot;);
Log::warn(&quot;This is some warning&quot;);
Log::err(&quot;This is some error&quot;);

Log::set_verbosity(MessageKind::Warning);

Log::info(&quot;This is some info&quot;); // This won't be printed.
Log::warn(&quot;This is some warning&quot;);
Log::err(&quot;This is some error&quot;);
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tutorials"><a class="header" href="#tutorials">Tutorials</a></h1>
<p>The book offers a set of tutorials of how to write a game of specific genre using the engine. Every tutorial starts
from mild difficulty and keep increasing the difficulty until the end. All tutorials are very well structured and
you shouldn't be able to lost in them.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="first-person-shooter-tutorial"><a class="header" href="#first-person-shooter-tutorial">First-Person Shooter Tutorial</a></h1>
<p><strong>WARNING: This tutorial is using obsolete engine features, which are subject to be removed in future versions!</strong></p>
<p>In this tutorial we'll make a 3D shooter - something similar to <a href="https://github.com/mrDIMAS/rusty-shooter">rusty-shooter</a>.
Also, the series should help you to learn basic principles which lies in the foundation of the engine.</p>
<h2 id="fyrox-and-fyroxed-version"><a class="header" href="#fyrox-and-fyroxed-version">Fyrox and Fyroxed version</a></h2>
<p>Fyrox changes rapidly and tutorial's code could not compile with the newest versions of the engine, to prevent that
and keep the code compilable over time the versions of both the engine and the editor are set to specific commits 
in the main repo.</p>
<p><strong>Fyrox version</strong>: 0.28<br />
<strong>Source code</strong>: <a href="https://github.com/FyroxEngine/Fyrox-tutorials/">GitHub</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fps-tutorial-part-1---character-controller"><a class="header" href="#fps-tutorial-part-1---character-controller">FPS Tutorial Part 1 - Character Controller.</a></h1>
<p><strong>WARNING: This tutorial is using obsolete engine features, which are subject to be removed in future versions!</strong></p>
<p><strong>Source code</strong>: <a href="https://github.com/FyroxEngine/Fyrox-tutorials/tree/main/tutorial1-character-controller">GitHub</a></p>
<h2 id="table-of-contents"><a class="header" href="#table-of-contents">Table of contents</a></h2>
<ul>
<li><a href="fyrox/tutorials/fps/tutorial-1/tutorial-part-1.html#introduction">Introduction</a></li>
<li><a href="fyrox/tutorials/fps/tutorial-1/tutorial-part-1.html#creating-a-window">Creating a window</a></li>
<li><a href="fyrox/tutorials/fps/tutorial-1/tutorial-part-1.html#creating-your-first-scene">Creating your first scene</a></li>
<li><a href="fyrox/tutorials/fps/tutorial-1/tutorial-part-1.html#using-the-scene">Using the scene</a></li>
<li><a href="fyrox/tutorials/fps/tutorial-1/tutorial-part-1.html#character-controller">Character controller</a></li>
<li><a href="fyrox/tutorials/fps/tutorial-1/tutorial-part-1.html#finishing-touch">Finishing touch</a></li>
<li><a href="fyrox/tutorials/fps/tutorial-1/tutorial-part-1.html#conclusion">Conclusion</a></li>
</ul>
<h2 id="introduction-1"><a class="header" href="#introduction-1">Introduction</a></h2>
<p>Fyrox is a general purpose 3D engine, it allows creating any kind of 3D game, but today we'll focus on classic 3D shooter.
In this tutorial we'll write a simple character controller. This is what we're aiming for:</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/VcN3NUdfg3E" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<p>Let's start by creating a new cargo project, make a folder and execute this:</p>
<pre><code class="language-bash">cargo init --bin
</code></pre>
<p>Open Cargo.toml and add <code>fyrox</code> dependency:</p>
<pre><code class="language-toml">[dependencies]
fyrox = &quot;0.28.0&quot;
</code></pre>
<h3 id="creating-a-window"><a class="header" href="#creating-a-window">Creating a window</a></h3>
<p>Great! Now we can start writing the game. Let's start from something very simple - a window and a main loop. Just copy 
and paste this code in the <code>main.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">extern crate fyrox;
</span>use fyrox::{
    core::{
        algebra::{UnitQuaternion, Vector3},
        pool::Handle,
    },
    engine::{Engine, EngineInitParams, SerializationContext},
    asset::manager::ResourceManager,
    event::{DeviceEvent, ElementState, Event, VirtualKeyCode, WindowEvent},
    event_loop::{ControlFlow, EventLoop},
    resource::texture::TextureWrapMode,
    scene::{
        base::BaseBuilder,
        camera::{CameraBuilder, SkyBox, SkyBoxBuilder},
        collider::{ColliderBuilder, ColliderShape},
        node::Node,
        rigidbody::RigidBodyBuilder,
        transform::TransformBuilder,
        Scene,
    },
    window::WindowBuilder,
};
use std::{sync::Arc, time};
use fyrox::window::WindowAttributes;
use fyrox::engine::{GraphicsContextParams, GraphicsContext};

// Our game logic will be updated at 60 Hz rate.
const TIMESTEP: f32 = 1.0 / 60.0;

struct Game {
    // Empty for now.
}

impl Game {
    pub fn new() -&gt; Self {
        Self {}
    }

    pub fn update(&amp;mut self) {
        // Game logic will be placed here.
    }
}

fn main() {
    // Create event loop that will be used to &quot;listen&quot; events from the OS.
    let event_loop = EventLoop::new();

    // Finally create an instance of the engine.
    let graphics_context_params = GraphicsContextParams {
        window_attributes: WindowAttributes {
            title: &quot;3D Shooter Tutorial&quot;.to_string(),
            resizable: true,
            ..Default::default()
        },
        vsync: true,
    };

    let serialization_context = Arc::new(SerializationContext::new());
    let mut engine = Engine::new(EngineInitParams {
        graphics_context_params,
        resource_manager: ResourceManager::new(),
        serialization_context,
    })
    .unwrap();

    // Initialize game instance. It is empty for now.
    let mut game = Game::new();

    // Run the event loop of the main window. which will respond to OS and window events and update
    // engine's state accordingly. Engine lets you to decide which event should be handled,
    // this is a minimal working example of how it should be.
    let mut previous = time::Instant::now();
    let mut lag = 0.0;
    event_loop.run(move |event, _, control_flow| {
        match event {
            Event::MainEventsCleared =&gt; {
                // This main game loop - it has fixed time step which means that game
                // code will run at fixed speed even if renderer can't give you desired
                // 60 fps.
                let elapsed = previous.elapsed();
                previous = time::Instant::now();
                lag += elapsed.as_secs_f32();
                while lag &gt;= TIMESTEP {
                    lag -= TIMESTEP;

                    // Run our game's logic.
                    game.update();

                    // Update engine each frame.
                    engine.update(TIMESTEP, control_flow, &amp;mut lag, Default::default());
                }

                // Rendering must be explicitly requested and handled after RedrawRequested event is received.
                if let GraphicsContext::Initialized(ref ctx) = engine.graphics_context {
                    ctx.window.request_redraw();
                }
            }
            Event::RedrawRequested(_) =&gt; {
                // Render at max speed - it is not tied to the game code.
                engine.render().unwrap();
            }
            Event::WindowEvent { event, .. } =&gt; match event {
                WindowEvent::CloseRequested =&gt; *control_flow = ControlFlow::Exit,
                WindowEvent::KeyboardInput { input, .. } =&gt; {
                    // Exit game by hitting Escape.
                    if let Some(VirtualKeyCode::Escape) = input.virtual_keycode {
                        *control_flow = ControlFlow::Exit
                    }
                }
			    WindowEvent::Resized(size) =&gt; {
                    // It is very important to handle Resized event from window, because
                    // renderer knows nothing about window size - it must be notified
                    // directly when window size has changed.
                    engine.set_frame_size(size.into()).unwrap();
                }
                _ =&gt; (),
            },
            _ =&gt; *control_flow = ControlFlow::Poll,
        }
    });
}</code></pre></pre>
<p>Wow! There is lots of code for such a simple task. Fear not, everything here is pretty straightforward, let's dive into
this code and disassemble it line by line. Just skip imports, it's too boring. Let's look at this line:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const TIMESTEP: f32 = 1.0 / 60.0;
<span class="boring">}</span></code></pre></pre>
<p>Here we define a rate of update for logic of our future game, just sticking to common 60 FPS. Next goes the skeleton of
the game, just a struct with two methods. It will be filled later in this tutorial.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Game {
    // Empty for now.
}

impl Game {
    pub fn new() -&gt; Self {
        Self {}
    }

    pub fn update(&amp;mut self) {
        // Game logic will be placed here.
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Finally, we at the point where the interesting stuff happens - <code>fn main()</code>. We're starting by creating our event loop: </p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::event_loop::EventLoop;
</span>let event_loop = EventLoop::new();
<span class="boring">}</span></code></pre></pre>
<p>The event loop is a &quot;magic&quot; thing that receives events from the operating system and feeds your application, this is a very 
important part which makes the application work. Finally, we're creating an instance of the engine:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let graphics_context_params = GraphicsContextParams {
    window_attributes: WindowAttributes {
        title: &quot;3D Shooter Tutorial&quot;.to_string(),
        resizable: true,
        ..Default::default()
    },
    vsync: true,
};

let serialization_context = Arc::new(SerializationContext::new());
let mut engine = Engine::new(EngineInitParams {
    graphics_context_params,
    resource_manager: ResourceManager::new(serialization_context.clone()),
    serialization_context,
})
.unwrap();
<span class="boring">}</span></code></pre></pre>
<p>At first, we're creating an instance of <code>SerializationContext</code> - it is used to store type constructors used for 
serialization needs. Next, we're filling <code>EngineInitParams</code> structure, there is nothing interesting there, except maybe
a flag that is responsible for vertical synchronization (VSync). In this tutorial we'll have VSync disabled, because
it requires specific platform-dependent extensions which are not always available and calling <code>.unwrap()</code> might result
in panic on some platforms. Next we're creating an instance of the game, remember this line, it will be changed soon:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut game = Game::new();
<span class="boring">}</span></code></pre></pre>
<p>Next we define two variables for the game loop: </p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let clock = time::Instant::now();
let mut elapsed_time = 0.0;
<span class="boring">}</span></code></pre></pre>
<p>At first, we &quot;remember&quot; the starting point of the game in time. The next variable is used to control the game loop. Finally, we run the
event loop and start checking for events coming from the OS:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>event_loop.run(move |event, _, control_flow| {
    match event {
        ...
    }
});
<span class="boring">}</span></code></pre></pre>
<p>Let's look at each event separately starting from <code>Event::MainEventsCleared</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Event::MainEventsCleared =&gt; {
    // This main game loop - it has fixed time step which means that game
    // code will run at fixed speed even if renderer can't give you desired
    // 60 fps.
    let mut dt = clock.elapsed().as_secs_f32() - elapsed_time;
    while dt &gt;= TIMESTEP {
        dt -= TIMESTEP;
        elapsed_time += TIMESTEP;

        // Run our game's logic.
        game.update();

        // Update engine each frame.
        engine.update(TIMESTEP);
    }

    // Rendering must be explicitly requested and handled after RedrawRequested event is received.
    if let GraphicsContext::Initialized(ref ctx) = engine.graphics_context {
        ctx.window.request_redraw();
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This is the heart of game loop - it stabilizes update rate of game logic by measuring time from last update call
and performs a various amount of iterations based on an amount of time since last update. This makes the game logic update
rate independent of FPS - it will be always 60 Hz for game logic even if FPS is 10. The <code>while</code> loop contains 
<code>game.update()</code> and <code>engine.update(TIMESTEP)</code> calls to update game's logic and engine internals respectively. After the
loop we're asking the engine to render the next frame. In the next match arm <code>Event::RedrawRequested</code> we're handing our request: </p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Event::RedrawRequested(_) =&gt; {
    // Render at max speed - it is not tied to the game code.
    engine.render().unwrap();
}
<span class="boring">}</span></code></pre></pre>
<p>As you can see rendering happens in a single line of code. Next we need to handle window events:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Event::WindowEvent { event, .. } =&gt; match event {
    WindowEvent::CloseRequested =&gt; *control_flow = ControlFlow::Exit,
    WindowEvent::KeyboardInput { input, .. } =&gt; {
        // Exit game by hitting Escape.
        if let Some(VirtualKeyCode::Escape) = input.virtual_keycode {
            *control_flow = ControlFlow::Exit
        }
    }
	WindowEvent::Resized(size) =&gt; {
		// It is very important to handle Resized event from window, because
		// renderer knows nothing about window size - it must be notified
		// directly when window size has changed.
		engine.set_frame_size(size.into()).unwrap();
	}
    _ =&gt; (),
},
<span class="boring">}</span></code></pre></pre>
<p>Here we're just checking if the player has hit Escape button and exit game if so. Also, when <code>WindowEvent::Resized</code> is 
received, we're notifying renderer about that, so it's render targets will be resized too. The final match arm is for 
every other event, nothing fancy here - just asking engine to continue listening for new events.</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>_ =&gt; *control_flow = ControlFlow::Poll,
<span class="boring">}</span></code></pre></pre>
<p>So far so good. This small piece of code just creates a new window and fills it with black color, now we can start 
writing the game. </p>
<p><img src="fyrox/tutorials/fps/tutorial-1/./tutorial1-window.jpg" alt="Window" /></p>
<p>Let's start by creating a simple scene where we'll test our character controller. This is the time when 
<a href="https://github.com/FyroxEngine/Fyrox/tree/master/editor">Fyroxed</a> comes into play - Fyroxed is a native scene editor of the
engine. It is worth mentioning what &quot;scene editor&quot; means: unlike many other engines (Unity, UnrealEngine, etc.),
Fyroxed does <strong>not</strong> allow you to run your game inside it, instead you just edit your scene, save it in the editor and load it in
your game. Being able to run a game inside the editor was a very huge task for one person, and I just chose the 
easiest way. Alright, back to the interesting stuff. Build the editor first using instructions from its
<a href="https://github.com/FyroxEngine/Fyrox/tree/master/editor">GitHub page</a> using specific commit stated in the beginning of the article.</p>
<h2 id="creating-your-first-scene"><a class="header" href="#creating-your-first-scene">Creating your first scene</a></h2>
<p>This section is completely optional, if you eager to make the game - just use a 
<a href="fyrox/tutorials/fps/tutorial-1/./data.zip">pre-made scene</a> (download it and unpack in the folder of your game) and go to
the <a href="fyrox/tutorials/fps/tutorial-1/tutorial-part-1.html#using-the-scene">next section</a>. Open Fyroxed, it should look like this:</p>
<p><img src="fyrox/tutorials/fps/tutorial-1/./tutorial1-rusty-editor.jpg" alt="Fyroxed" /></p>
<p>It will ask you to choose a working directory.</p>
<p><img src="fyrox/tutorials/fps/tutorial-1/./tutorial1-configurator.jpg" alt="configurator" /></p>
<p>The working directory is simply a path to your game's executable, in most cases it will be the root folder of your
project.</p>
<p>Next, click <code>File -&gt; CreateScene</code>. Now you can start modifying your scene. All we need for now is a floor and maybe 
some decorations. To do that, you can either create everything from simple objects (cubes, cones, cylinders,
etc.) or load some assets made in 3D editors (like Blender, 3Ds max, etc.). Here we combine two approaches: floor will 
be just a squashed cube and decorations will be 3D models. Let's start from the floor. Click <code>Create -&gt; Mesh -&gt; Cube</code>, 
select the cube and use Scale tool from the toolbar to squash it to form the floor.</p>
<p><img src="fyrox/tutorials/fps/tutorial-1/./tutorial1-rusty-editor-floor.jpg" alt="Floor" /></p>
<p>Next we need to add physical body to the floor to not fall through it. This is very simple, click <code>Create -&gt; Physics -&gt; Rigid Body</code>
then right-click on the rigid body in the World Viewer and click <code>Create -&gt; Physics -&gt; Collider</code>. Next we need to bind the 
floor 3D model with the rigid body, to do that drag'n'drop the floor entity to the rigid body. Now we need to configure the
collider of the rigid body. Select it and go to Inspector, find Shape property and select Trimesh from the dropdown list.
Next, click <code>+</code> sign in Sources and then drag'n'drop floor entity to <code>Unassigned</code> entry while holding <code>Alt</code> on the keyboard.
By doing this, we've added a source of geometry for triangle mesh collider. Also, we need to make the rigid body
static, so it won't be affected by gravity and external forces, otherwise the floor will fall as any other
dynamic rigid body. To do that, simply select the body and change its <code>Body Type</code> property to <code>Static</code>.</p>
<p><img src="fyrox/tutorials/fps/tutorial-1/./tutorial1-rusty-editor-floor-body.jpg" alt="Floor Body" /></p>
<p>Ok, good, but it looks awful, let's add some texture to it, to do that, 
<a href="fyrox/tutorials/fps/tutorial-1/./floor.jpg">download floor texture</a>, place it to <code>data/textures</code> and apply it to the floor. 
To do that, use the asset browser: at its left side it shows file system of your project, locate <code>data/textures</code> folder 
and select <code>floor.jpg</code>. Now just drag-n-drop the texture to the floor, this is what you should get.</p>
<p><img src="fyrox/tutorials/fps/tutorial-1/./tutorial1-rusty-editor-floor-texture.jpg" alt="Floor Texture" /></p>
<p>Now let's add some decorations, to do that <a href="fyrox/tutorials/fps/tutorial-1/./barrel.zip">download 3D model</a> I prepared for
this tutorial and unpack it in <code>data/models</code>. Now go to the <code>data/models</code> in the asset browser and just drag-n-drop the
<code>barrel.FBX</code> to the scene. Now use the Scale and Move tools to adjust scale and position of the barrel, it should look 
like this: </p>
<p><img src="fyrox/tutorials/fps/tutorial-1/./tutorial1-rusty-editor-barrel-body.jpg" alt="Barrel Body" /></p>
<p>Barrel does not have any rigid body yet, and it won't interact with world. Let's fix this. As usual, click <code>Create -&gt; Physics -&gt; Rigid Body</code> 
then click on the added rigid body and add a cylinder collider by right-click on it and selecting <code>Create -&gt; Physics -&gt; Colider</code>.
Now select the collider and set its shape to Cylinder adjust its height and radius. As a final step drag'n'drop the <code>barrel.FBX</code> scene 
node on the rigid body node.</p>
<p>Now clone some barrels, to do that select a parent rigid body of some <code>barrel.FBX</code> in the <code>World Outliner</code>, 
right-click on the scene preview and press <code>Ctrl+C</code> to copy the barrel and <code>Ctrl+V</code> to paste. Repeat multiple times.</p>
<p><img src="fyrox/tutorials/fps/tutorial-1/./tutorial1-rusty-editor-barrels.jpg" alt="Barrel" /></p>
<p>Also add a light source, to do that go to <code>Create -&gt; Light -&gt; Point</code> and adjust its position using the Move tool.</p>
<p><img src="fyrox/tutorials/fps/tutorial-1/./tutorial1-rusty-editor-light.jpg" alt="Barrel" /></p>
<p>The final step: save your scene in <code>data/models</code>, to do that go to <code>File -&gt; Save</code> and select the folder and type name 
of the scene in the field it should be <code>scene.rgs</code>.</p>
<h2 id="using-the-scene"><a class="header" href="#using-the-scene">Using the scene</a></h2>
<p>Now it's the time to load the scene we've made earlier in the game. This is very simple, all we need to do is to load
scene as resource and create its instance. Change <code>fn new()</code> body to:</p>
<pre><pre class="playground"><code class="language-rust no_run edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::{algebra::Vector3, pool::Handle},
</span><span class="boring">    engine::Engine, resource::model::{Model, ModelResourceExtension},
</span><span class="boring">    scene::{
</span><span class="boring">        base::BaseBuilder, camera::CameraBuilder, node::Node, transform::TransformBuilder,
</span><span class="boring">        Scene,
</span><span class="boring">    },
</span><span class="boring">};
</span><span class="boring">struct Stub {
</span><span class="boring">    camera: Handle&lt;Node&gt;,
</span><span class="boring">    scene: Handle&lt;Scene&gt;,
</span><span class="boring">}
</span><span class="boring">impl Stub {
</span>pub async fn new(engine: &amp;mut Engine) -&gt; Self {
    let mut scene = Scene::new();

    // Load a scene resource and create its instance.
    engine
        .resource_manager
        .request::&lt;Model, _&gt;(&quot;data/models/scene.rgs&quot;)
        .await
        .unwrap()
        .instantiate(&amp;mut scene);

    // Next create a camera, it is our &quot;eyes&quot; in the world.
    // This can also be made in editor, but for educational purpose we'll made it by hand.
    let camera = CameraBuilder::new(
        BaseBuilder::new().with_local_transform(
            TransformBuilder::new()
                .with_local_position(Vector3::new(0.0, 1.0, -3.0))
                .build(),
        ),
    )
    .build(&amp;mut scene.graph);

    Self {
        camera,
        scene: engine.scenes.add(scene),
    }
}
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>You may have noticed that the <code>Game</code> structure now has two new fields: </p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Game {
    scene: Handle&lt;Scene&gt;, // A handle to the scene
    camera: Handle&lt;Node&gt;, // A handle to the camera
}
<span class="boring">}</span></code></pre></pre>
<p>These fields are just handles to the &quot;entities&quot; we've created in the <code>Game::new()</code>. Also, change <code>let mut game = Game::new();</code> to this:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut game = fyrox::core::futures::executor::block_on(Game::new(&amp;mut engine));
<span class="boring">}</span></code></pre></pre>
<p>Here we execute async function <code>Game::new()</code> and it creates game's instance with the scene we've made previously.
Run the game and you should see this:</p>
<p><img src="fyrox/tutorials/fps/tutorial-1/./tutorial1-scene.jpg" alt="Barrel" /></p>
<p>Cool! Now let's disassemble <code>fn new()</code> line by line. First, we're creating an empty scene:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut scene = Scene::new();
<span class="boring">}</span></code></pre></pre>
<p>The next few lines are the most interesting:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>engine
    .resource_manager
    .request::&lt;Model, _&gt;(&quot;data/models/scene.rgs&quot;)
    .await
    .unwrap()
    .instantiate(&amp;mut scene);
<span class="boring">}</span></code></pre></pre>
<p>Here we're asking the resource manager to load the scene we've made previously, awaiting while it loads and then instantiating
it on the <code>scene</code>. What does &quot;instantiation&quot; mean? In short, it means that we're creating a copy of a scene and adding the copy
to some other scene, the engine remembers connections between clones and original entities and is capable of restoring data
from resource for the instance. At this point we've successfully instantiated the scene. However, we won't see anything
yet - we need a camera:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let camera = CameraBuilder::new(
    BaseBuilder::new().with_local_transform(
        TransformBuilder::new()
            .with_local_position(Vector3::new(0.0, 1.0, -3.0))
            .build(),
    ),
)
.build(&amp;mut scene.graph);
<span class="boring">}</span></code></pre></pre>
<p>Camera is our &quot;eyes&quot; in the world, here we're just creating a camera and moving it a bit up and back to be able to see the 
scene. Finally, we're adding the scene to the engine's container for scenes, and it gives us a handle to the scene. Later
we'll use the handle to borrow scene and modify it.</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Self {
    camera,
    scene: engine.scenes.add(scene),
}
<span class="boring">}</span></code></pre></pre>
<h2 id="character-controller"><a class="header" href="#character-controller">Character controller</a></h2>
<p>We've made a lot of things already, but still can't move in the scene. Let's fix this! We'll start writing the character
controller which will allow us to walk in our scene. Let's start with a chunk of code as usual:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::{
</span><span class="boring">        algebra::{UnitQuaternion, Vector3},
</span><span class="boring">        pool::Handle,
</span><span class="boring">    },
</span><span class="boring">    engine::{Engine},
</span><span class="boring">    asset::manager::ResourceManager,
</span><span class="boring">    event::{DeviceEvent, ElementState, Event, VirtualKeyCode, WindowEvent},
</span><span class="boring">    event_loop::{ControlFlow, EventLoop},
</span><span class="boring">    resource::texture::TextureWrapMode,
</span><span class="boring">    scene::{
</span><span class="boring">        base::BaseBuilder,
</span><span class="boring">        camera::{CameraBuilder, SkyBox, SkyBoxBuilder},
</span><span class="boring">        collider::{ColliderBuilder, ColliderShape},
</span><span class="boring">        node::Node,
</span><span class="boring">        rigidbody::RigidBodyBuilder,
</span><span class="boring">        transform::TransformBuilder,
</span><span class="boring">        Scene,
</span><span class="boring">    },
</span><span class="boring">    window::WindowBuilder,
</span><span class="boring">};
</span><span class="boring">use std::time;
</span>
#[derive(Default)]
struct InputController {
    move_forward: bool,
    move_backward: bool,
    move_left: bool,
    move_right: bool,
    pitch: f32,
    yaw: f32,
}

struct Player {
    camera: Handle&lt;Node&gt;,
    rigid_body: Handle&lt;Node&gt;,
    controller: InputController,
}

impl Player {
    fn new(scene: &amp;mut Scene) -&gt; Self {
        // Create rigid body with a camera, move it a bit up to &quot;emulate&quot; head.
        let camera;
        let rigid_body_handle = RigidBodyBuilder::new(
            BaseBuilder::new()
                .with_local_transform(
                    TransformBuilder::new()
                        // Offset player a bit.
                        .with_local_position(Vector3::new(0.0, 1.0, -1.0))
                        .build(),
                )
                .with_children(&amp;[
                    {
                        camera = CameraBuilder::new(
                            BaseBuilder::new().with_local_transform(
                                TransformBuilder::new()
                                    .with_local_position(Vector3::new(0.0, 0.25, 0.0))
                                    .build(),
                            ),
                        )
                        .build(&amp;mut scene.graph);
                        camera
                    },
                    // Add capsule collider for the rigid body.
                    ColliderBuilder::new(BaseBuilder::new())
                        .with_shape(ColliderShape::capsule_y(0.25, 0.2))
                        .build(&amp;mut scene.graph),
                ]),
        )
        // We don't want the player to tilt.
        .with_locked_rotations(true)
        // We don't want the rigid body to sleep (be excluded from simulation)
        .with_can_sleep(false)
        .build(&amp;mut scene.graph);

        Self {
            camera,
            rigid_body: rigid_body_handle,
            controller: Default::default(),
        }
    }

    fn update(&amp;mut self, scene: &amp;mut Scene) {
        // Set pitch for the camera. These lines responsible for up-down camera rotation.
        scene.graph[self.camera].local_transform_mut().set_rotation(
            UnitQuaternion::from_axis_angle(&amp;Vector3::x_axis(), self.controller.pitch.to_radians()),
        );

        // Borrow rigid body node.
        let body = scene.graph[self.rigid_body].as_rigid_body_mut();

        // Keep only vertical velocity, and drop horizontal.
        let mut velocity = Vector3::new(0.0, body.lin_vel().y, 0.0);

        // Change the velocity depending on the keys pressed.
        if self.controller.move_forward {
            // If we moving forward then add &quot;look&quot; vector of the body.
            velocity += body.look_vector();
        }
        if self.controller.move_backward {
            // If we moving backward then subtract &quot;look&quot; vector of the body.
            velocity -= body.look_vector();
        }
        if self.controller.move_left {
            // If we moving left then add &quot;side&quot; vector of the body.
            velocity += body.side_vector();
        }
        if self.controller.move_right {
            // If we moving right then subtract &quot;side&quot; vector of the body.
            velocity -= body.side_vector();
        }

        // Finally new linear velocity.
        body.set_lin_vel(velocity);

        // Change the rotation of the rigid body according to current yaw. These lines responsible for
        // left-right rotation.
        body.local_transform_mut()
            .set_rotation(UnitQuaternion::from_axis_angle(
                &amp;Vector3::y_axis(),
                self.controller.yaw.to_radians(),
            ));
    }

    fn process_input_event(&amp;mut self, event: &amp;Event&lt;()&gt;) {
        match event {
            Event::WindowEvent { event, .. } =&gt; {
                if let WindowEvent::KeyboardInput { input, .. } = event {
                    if let Some(key_code) = input.virtual_keycode {
                        match key_code {
                            VirtualKeyCode::W =&gt; {
                                self.controller.move_forward = input.state == ElementState::Pressed;
                            }
                            VirtualKeyCode::S =&gt; {
                                self.controller.move_backward =
                                    input.state == ElementState::Pressed;
                            }
                            VirtualKeyCode::A =&gt; {
                                self.controller.move_left = input.state == ElementState::Pressed;
                            }
                            VirtualKeyCode::D =&gt; {
                                self.controller.move_right = input.state == ElementState::Pressed;
                            }
                            _ =&gt; (),
                        }
                    }
                }
            }
            Event::DeviceEvent { event, .. } =&gt; {
                if let DeviceEvent::MouseMotion { delta } = event {
                    self.controller.yaw -= delta.0 as f32;

                    self.controller.pitch =
                        (self.controller.pitch + delta.1 as f32).clamp(-90.0, 90.0);
                }
            }
            _ =&gt; (),
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This is all the code we need for character controller, quite a lot actually, but as usual everything here is pretty
straightforward.</p>
<pre><pre class="playground"><code class="language-rust no_run edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::core::pool::Handle;
</span><span class="boring">use fyrox::engine::Engine;
</span><span class="boring">use fyrox::scene::Scene;
</span><span class="boring">use fyrox::resource::model::{Model, ModelResourceExtension};
</span><span class="boring">struct Player;
</span><span class="boring">impl Player {
</span><span class="boring">    fn new(_scene: &amp;mut Scene) -&gt; Self {
</span><span class="boring">        Self
</span><span class="boring">    }
</span><span class="boring">    fn update(&amp;mut self, _scene: &amp;mut Scene) {}
</span><span class="boring">}
</span>// Also we must change Game structure a bit too and the new() code.
struct Game {
    scene: Handle&lt;Scene&gt;,
    player: Player, // New
}

impl Game {
    pub async fn new(engine: &amp;mut Engine) -&gt; Self {
        let mut scene = Scene::new();

        // Load a scene resource and create its instance.
        engine
            .resource_manager
            .request::&lt;Model, _&gt;(&quot;data/models/scene.rgs&quot;)
            .await
            .unwrap()
            .instantiate(&amp;mut scene);

        Self {
            player: Player::new(&amp;mut scene), // New
            scene: engine.scenes.add(scene),
        }
    }

    pub fn update(&amp;mut self, engine: &amp;mut Engine) {
        self.player.update(&amp;mut engine.scenes[self.scene]); // New
    }
}
<span class="boring">}</span></code></pre></pre>
<p>We've moved camera creation to <code>Player</code>, because now the camera is attached to the player's body. Also, we must add this line
in the beginning of <code>event_loop.run(...)</code> to let <code>player</code> handle input events:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>game.player.process_input_event(&amp;event);        
<span class="boring">}</span></code></pre></pre>
<p>So, let's try to understand what happens in this huge chunk of code. Let's start from the <code>InputController</code> struct,
it holds the state of the input for a single frame and rotations of player &quot;parts&quot;. </p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Default)]
struct InputController {
    move_forward: bool,
    move_backward: bool,
    move_left: bool,
    move_right: bool,
    pitch: f32,
    yaw: f32,
}
<span class="boring">}</span></code></pre></pre>
<p>Next goes the <code>Player::new()</code> function. First, we're creating a simple chain of nodes of different kinds in the
<a href="https://en.wikipedia.org/wiki/Scene_graph">scene graph</a>. </p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let camera;
let rigid_body_handle = RigidBodyBuilder::new(
        BaseBuilder::new()
            .with_local_transform(
                TransformBuilder::new()
                    // Offset player a bit.
                    .with_local_position(Vector3::new(0.0, 1.0, -1.0))
                    .build(),
            )
            .with_children(&amp;[
                {
                    camera = CameraBuilder::new(
                        BaseBuilder::new().with_local_transform(
                            TransformBuilder::new()
                                .with_local_position(Vector3::new(0.0, 0.25, 0.0))
                                .build(),
                        ),
                    )
                    .build(&amp;mut scene.graph);
                    camera
                },
                // Add capsule collider for the rigid body.
                ColliderBuilder::new(BaseBuilder::new())
                    .with_shape(ColliderShape::capsule_y(0.25, 0.2))
                    .build(&amp;mut scene.graph),
            ]),
    )
    // We don't want the player to tilt.
    .with_locked_rotations(true)
    // We don't want the rigid body to sleep (be excluded from simulation)
    .with_can_sleep(false)
    .build(&amp;mut scene.graph);
<span class="boring">}</span></code></pre></pre>
<p>Basically we're making something like this:</p>
<p><img src="fyrox/tutorials/fps/tutorial-1/./tutorial1-graph-example.png" alt="Graph" /></p>
<p>As you can see, the camera is attached to the rigid body and has a <strong>relative</strong> position of <code>(0.0, 0.25, 0.0)</code>. So when we'll
move rigid body, the camera will move too (and rotate of course). </p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Self {
    camera,
    rigid_body: rigid_body_handle,
    controller: Default::default(),
}
<span class="boring">}</span></code></pre></pre>
<p>Next goes the <code>fn update(...)</code> function, it is responsible for movement of the player. It starts from these lines:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Set pitch for the camera. These lines responsible for up-down camera rotation.
scene.graph[self.camera].local_transform_mut().set_rotation(
    UnitQuaternion::from_axis_angle(&amp;Vector3::x_axis(), self.controller.pitch.to_radians()),
);
<span class="boring">}</span></code></pre></pre>
<p>We're borrowing the camera from the graph (<code>scene.graph[self.camera]</code>) and modifying its <strong>local</strong> rotation, using a 
<a href="https://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation">quaternion</a> built from an axis, and an angle.
This rotates camera in vertical direction. Let's talk about borrowing in the engine. Almost every object in the 
engine &quot;lives&quot; in generational arenas (pool in fyrox's terminology). Pool is a contiguous chunk of memory, to be
able to &quot;reference&quot; an object in a pool Fyrox uses handles. Almost every entity has a single owner - the engine,
so to mutate or read data from an entity your have to borrow it first, like this:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Borrow rigid body node.
let body = scene.graph[self.rigid_body].as_rigid_body_mut();
<span class="boring">}</span></code></pre></pre>
<p>This piece of code <code>scene.graph[self.rigid_body]</code> borrows <code>rigid_body</code> as either mutable or shared, depending on the context (basically
it is just an implementation of Index + IndexMut traits). Once we've borrowed objects, we can modify them. As the next
step we calculate new horizontal speed for the player:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Keep only vertical velocity, and drop horizontal.
let mut velocity = Vector3::new(0.0, body.lin_vel().y, 0.0);

// Change the velocity depending on the keys pressed.
if self.controller.move_forward {
    // If we moving forward then add &quot;look&quot; vector of the body.
    velocity += body.look_vector();
}
if self.controller.move_backward {
    // If we moving backward then subtract &quot;look&quot; vector of the body.
    velocity -= body.look_vector();
}
if self.controller.move_left {
    // If we moving left then add &quot;side&quot; vector of the body.
    velocity += body.side_vector();
}
if self.controller.move_right {
    // If we moving right then subtract &quot;side&quot; vector of the body.
    velocity -= body.side_vector();
}

// Finally new linear velocity.
body.set_lin_vel(velocity);
<span class="boring">}</span></code></pre></pre>
<p>We don't need to modify vertical speed, because it should be controlled by the physics engine. Finally, we're setting
rotation of the rigid body:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Change the rotation of the rigid body according to current yaw. These lines responsible for
// left-right rotation.
body.local_transform_mut()
    .set_rotation(UnitQuaternion::from_axis_angle(
        &amp;Vector3::y_axis(),
        self.controller.yaw.to_radians(),
    ));
<span class="boring">}</span></code></pre></pre>
<p>The next piece of code is a bit boring, but still should be addressed - it is input handling. In the <code>process_input_event</code>
we check input events and configure input controller accordingly. Basically we're just checking if W, S, A, D keys were 
pressed or released. In the <code>MouseMotion</code> arm, we're modifying yaw and pitch of the controller according to mouse 
velocity. Nothing fancy, except this line:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>self.controller.pitch = (self.controller.pitch + delta.1 as f32).clamp(-90.0, 90.0);
<span class="boring">}</span></code></pre></pre>
<p>Here we're just restricting pitch to [-90; 90] degree range to not let flipping camera upside-down. Now let's run the 
game, you should see something like this and be able to walk and turn the camera.</p>
<p><img src="fyrox/tutorials/fps/tutorial-1/./tutorial1-controller.jpg" alt="Controller" /></p>
<h2 id="finishing-touch"><a class="header" href="#finishing-touch">Finishing touch</a></h2>
<p>One more thing before we end the tutorial. Black &quot;void&quot; around us isn't nice, let's add skybox for the camera to improve
that. Skybox is a very simple effect that significantly improves scene quality. To add a skybox, add this code first
somewhere before <code>impl Player</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    asset::manager::{ResourceManager},
</span><span class="boring">    resource::texture::{Texture, TextureWrapMode},
</span><span class="boring">    scene::{
</span><span class="boring">        camera::{SkyBox, SkyBoxBuilder},
</span><span class="boring">    },
</span><span class="boring">};
</span>async fn create_skybox(resource_manager: ResourceManager) -&gt; SkyBox {
    // Load skybox textures in parallel.
    let (front, back, left, right, top, bottom) = fyrox::core::futures::join!(
        resource_manager.request::&lt;Texture, _&gt;(&quot;data/textures/skybox/front.jpg&quot;),
        resource_manager.request::&lt;Texture, _&gt;(&quot;data/textures/skybox/back.jpg&quot;),
        resource_manager.request::&lt;Texture, _&gt;(&quot;data/textures/skybox/left.jpg&quot;),
        resource_manager.request::&lt;Texture, _&gt;(&quot;data/textures/skybox/right.jpg&quot;),
        resource_manager.request::&lt;Texture, _&gt;(&quot;data/textures/skybox/up.jpg&quot;),
        resource_manager.request::&lt;Texture, _&gt;(&quot;data/textures/skybox/down.jpg&quot;)
    );

    // Unwrap everything.
    let skybox = SkyBoxBuilder {
        front: Some(front.unwrap()),
        back: Some(back.unwrap()),
        left: Some(left.unwrap()),
        right: Some(right.unwrap()),
        top: Some(top.unwrap()),
        bottom: Some(bottom.unwrap()),
    }
        .build()
        .unwrap();

    // Set S and T coordinate wrap mode, ClampToEdge will remove any possible seams on edges
    // of the skybox.
    let skybox_texture = skybox.cubemap().unwrap();
    let mut data = skybox_texture.data_ref();
    data.set_s_wrap_mode(TextureWrapMode::ClampToEdge);
    data.set_t_wrap_mode(TextureWrapMode::ClampToEdge);

    skybox
}
<span class="boring">}</span></code></pre></pre>
<p>Then modify signature of <code>Player::new</code> to </p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn new(scene: &amp;mut Scene, resource_manager: ResourceManager) -&gt; Self
<span class="boring">}</span></code></pre></pre>
<p>We just added resource manager parameter here, and made the function async, because we'll load a bunch of textures 
in the <code>create_skybox</code> function. Add following line at camera builder (before <code>.build</code>):</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>.with_skybox(create_skybox(resource_manager).await)
<span class="boring">}</span></code></pre></pre>
<p>Also modify player creation in <code>Game::new</code> to this</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>player: Player::new(&amp;mut scene, engine.resource_manager.clone()).await,
<span class="boring">}</span></code></pre></pre>
<p>Next, download skybox textures from <a href="fyrox/tutorials/fps/tutorial-1/./skybox.zip">here</a> and extract the archive in 
<code>data/textures</code> (all textures from  the archive must be in <code>data/textures/skybox</code>). Now you can run the game, and you
should see something like this:</p>
<p><img src="fyrox/tutorials/fps/tutorial-1/./tutorial1-skybox.jpg" alt="Controller" /></p>
<p>This was the last step of this tutorial.</p>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>In this tutorial we've learned how to use the engine and the editor. Created simple character controller and walked on
the scene we've made in the editor. I hope you liked this tutorial, and if so, please consider supporting the project on 
<a href="https://patreon.com/mrdimas">Patreon</a> or <a href="https://liberapay.com/mrDIMAS">LiberaPay</a>. Source code is available on
<a href="https://github.com/FyroxEngine/Fyrox-tutorials">GitHub</a>. In the next tutorial we'll start adding weapons.</p>
<p>Discussion: <a href="https://www.reddit.com/r/rust/comments/lyj1tq/writing_a_3d_shooter_using_rg3d_game_engine_1/">Reddit</a>,
<a href="https://discord.gg/xENF5Uh">Discord</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fps-tutorial-part-2---weapons"><a class="header" href="#fps-tutorial-part-2---weapons">FPS Tutorial Part 2 - Weapons</a></h1>
<p><strong>WARNING: This tutorial is using obsolete engine features, which are subject to be removed in future versions!</strong></p>
<p><strong>Source code</strong>: <a href="https://github.com/FyroxEngine/Fyrox-tutorials/tree/main/tutorial2-character-controller">GitHub</a></p>
<h2 id="table-of-contents-1"><a class="header" href="#table-of-contents-1">Table of contents</a></h2>
<ul>
<li><a href="fyrox/tutorials/fps/tutorial-2/tutorial-part-2.html#introduction">Introduction</a></li>
<li><a href="fyrox/tutorials/fps/tutorial-2/tutorial-part-2.html#adding-weapons">Adding weapons</a></li>
<li><a href="fyrox/tutorials/fps/tutorial-2/tutorial-part-2.html#game-architecture">Game architecture</a></li>
<li><a href="fyrox/tutorials/fps/tutorial-2/tutorial-part-2.html#recoil">Recoil</a></li>
<li><a href="fyrox/tutorials/fps/tutorial-2/tutorial-part-2.html#impact-effects">Impact effects</a></li>
<li><a href="fyrox/tutorials/fps/tutorial-2/tutorial-part-2.html#conclusion">Conclusion</a></li>
</ul>
<h2 id="introduction-2"><a class="header" href="#introduction-2">Introduction</a></h2>
<p>Of course for a shooter game we need weapons and targets to shoot at. In this tutorial we'll add weapons to the game.
For simplicity, we'll add only one weapon, as you'll see later it is pretty easy to add more weapons yourself. This 
is the result we're aiming in the tutorial:</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/GmVAdBdnqeM" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<h2 id="adding-weapons"><a class="header" href="#adding-weapons">Adding weapons</a></h2>
<p>Add a new module <code>weapon.rs</code> near your <code>main.rs</code> and use it somewhere after other imports:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub mod weapon;
...
use weapon::Weapon;
<span class="boring">}</span></code></pre></pre>
<p>Switch to <code>weapon.rs</code> and paste this code into it:</p>
<pre><pre class="playground"><code class="language-rust no_run edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span>use fyrox::scene::graph::Graph;
use fyrox::{
    core::{algebra::Vector3, math::Vector3Ext, pool::Handle},
    asset::manager::ResourceManager, resource::model::{Model, ModelResourceExtension},
    scene::{node::Node, Scene},
};

pub struct Weapon {
    model: Handle&lt;Node&gt;,
    shot_point: Handle&lt;Node&gt;,
    shot_timer: f32,
}

impl Weapon {
    pub async fn new(scene: &amp;mut Scene, resource_manager: ResourceManager) -&gt; Self {
        // Yeah, you need only few lines of code to load a model of any complexity.
        let model = resource_manager
            .request::&lt;Model, _&gt;(&quot;data/models/m4.fbx&quot;)
            .await
            .unwrap()
            .instantiate(scene);

        let shot_point = scene.graph.find_by_name(model, &quot;Weapon:ShotPoint&quot;).unwrap().0;

        Self {
            model,
            shot_point,
            shot_timer: 0.0,
        }
    }

    pub fn model(&amp;self) -&gt; Handle&lt;Node&gt; {
        self.model
    }

    pub fn shot_point(&amp;self) -&gt; Handle&lt;Node&gt; {
        self.shot_point
    }

    pub fn update(&amp;mut self, dt: f32) {
        self.shot_timer = (self.shot_timer - dt).min(0.0);
    }

    pub fn can_shoot(&amp;self) -&gt; bool {
        self.shot_timer &lt;= 0.0
    }

    pub fn shoot(&amp;mut self) {
        self.shot_timer = 1.0;
    }
}

<span class="boring">}</span></code></pre></pre>
<p>This piece of code just loads a <a href="fyrox/tutorials/fps/tutorial-2/./m4.zip">weapon model</a> and saves an instance handle for 
further use. Also, each weapon should contain a helper node that tells from where it will &quot;emit&quot; bullets, the node 
was added in a 3D editor and has name <code>Weapon:ShotPoint</code>. Weapon implementation has helper methods that provide read-only
access to inner fields (<code>model</code>, <code>shot_point</code>). <code>update</code> method just decreases the timer's value which is used to change
the pace of shooting. You may ask &quot;why <code>shoot</code> method just modifies timer's value and does not create bullets, etc.?&quot; -
please be patient, I will explain this later in <a href="fyrox/tutorials/fps/tutorial-2/tutorial-part-2.html#game-architecture">game architecture</a> section of the tutorial.
OK, now we need to make a point where every weapon will be &quot;mounted&quot; on, go to <code>Player::new</code> and add these lines in 
the <code>BaseBuilder</code> of the <code>CameraBuilder</code> instance (you also need to import <code>PivotBuilder</code>):</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>.with_children(&amp;[{
    weapon_pivot = PivotBuilder::new(
        BaseBuilder::new().with_local_transform(
            TransformBuilder::new()
                .with_local_position(Vector3::new(
                    -0.1, -0.05, 0.015,
                ))
                .build(),
        ),
    )
    .build(&amp;mut scene.graph);
    weapon_pivot
}]),
<span class="boring">}</span></code></pre></pre>
<p>What is going on here? We're just adding new child node to the camera and offset it by some vector. Every weapon will
be attached to this pivot. Please keep in mind that the offset given in <strong>local</strong> coordinates, which means that weapon
pivot will move with the camera, but with some offset relative to it. Also, do not forget to add this line after 
<code>let camera;</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let weapon_pivot;
<span class="boring">}</span></code></pre></pre>
<p>Finally, add the weapon pivot to <code>Self { ... }</code> (and also add <code>weapon_pivot: Handle&lt;Node&gt;</code> to the <code>Player</code> struct):</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Self {
    camera,
    weapon_pivot, // &lt;- here
    rigid_body: rigid_body_handle.into(),
    controller: Default::default(),
}
<span class="boring">}</span></code></pre></pre>
<p>Next we need a container for weapons, let's add it to the <code>Game</code> struct:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Game {
    scene: Handle&lt;Scene&gt;,
    player: Player,
    weapons: Pool&lt;Weapon&gt; // Weapons will live in a pool
}
<span class="boring">}</span></code></pre></pre>
<p>Also do not forget to import <code>Pool</code> from <code>fyrox::core::pool</code> in <code>main.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>...
use fyrox::core::pool::{Handle, Pool};
...
<span class="boring">}</span></code></pre></pre>
<p>Now we need to change <code>Game::new()</code> a bit to add a weapon to the player:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub async fn new(engine: &amp;mut Engine) -&gt; Self {
    let mut scene = Scene::new();

    // Load a scene resource and create its instance.
    engine
        .resource_manager
        .request::&lt;Model, _&gt;(&quot;data/models/scene.rgs&quot;)
        .await
        .unwrap()
        .instantiate(&amp;mut scene);

    // Create player first.
    let player = Player::new(&amp;mut scene, engine.resource_manager.clone()).await;

    // Create weapon next.
    let weapon = Weapon::new(&amp;mut scene, engine.resource_manager.clone()).await;

    // &quot;Attach&quot; the weapon to the weapon pivot of the player.
    scene.graph.link_nodes(weapon.model(), player.weapon_pivot);

    // Create a container for the weapons.
    let mut weapons = Pool::new();

    // Put the weapon into it.
    weapons.spawn(weapon);

    Self {
        player,
        scene: engine.scenes.add(scene),
        weapons,
    }
}
<span class="boring">}</span></code></pre></pre>
<p>At first, we're loading the scene, next we're creating player as usual. Next we're creating a weapon and attach it to 
the weapon pivot we've made earlier. Finally, we're creating a container for the weapons: we'll use Pool to be able 
to borrow weapon later on when we need. So, let's run the game, and you should see something like this:</p>
<p><img src="fyrox/tutorials/fps/tutorial-2/./weapon.jpg" alt="Weapon" /></p>
<p>Alright, now we have a weapon, but it still can't shoot. Let's fix that. </p>
<h3 id="game-architecture"><a class="header" href="#game-architecture">Game architecture</a></h3>
<p>We at the point now where we need to choose correct approach of interaction between parts of the game. We already have
two kinds of entities: player and weapon. In naive approach to shoot a weapon, you'd pass a reference to a weapon in 
<code>Player::update()</code> and would call something like <code>weapon.shoot()</code>. Most likely that at some point you'll end up
in a situation when you need too much of a context in a single method. This is so-called strong coupling, this is
the thing that disappoints borrow checker too much, and it rejects your code because you're trying to borrow same things
multiple times. So we need a way to change strong coupling to loose coupling. To do that we'll use messages to delay 
execution of some actions that require too much of a context. In general, we'll replace direct function call with a 
message that will be put in a common queue and executed later on one by one at the top of call hierarchy (in 
<code>Game::update</code> in our case). Let's begin by adding a MPSC (Multiple Producer Single Consumer) queue to the <code>Game</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Game {
    scene: Handle&lt;Scene&gt;,
    player: Player,
    weapons: Pool&lt;Weapon&gt;,
    receiver: Receiver&lt;Message&gt;, // Single receiver, it cannot be cloned.
    sender: Sender&lt;Message&gt;, // Sender can be cloned and used from various places.
}
<span class="boring">}</span></code></pre></pre>
<p>Now we need a <code>Message</code> enumeration, add <code>message.rs</code> module, import it in <code>main.rs</code> (<code>pub mod message;</code>) and fill it
with the following code:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::weapon::Weapon;
use fyrox::core::pool::Handle;

pub enum Message {
    ShootWeapon {
        weapons: Handle&lt;Weapon&gt;
    }
}
<span class="boring">}</span></code></pre></pre>
<p>For now, we have only one message kind - <code>ShootWeapon</code> with a single parameter, a handle of a weapon to shoot. We need
a place to handle messages, <code>Game::update</code> seems to be the most suitable - it is on top of &quot;call hierarchy&quot; and has 
most wide context. Let's change <code>Game::update</code> to this code:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn update(&amp;mut self, engine: &amp;mut Engine, dt: f32) {
    self.player.update(&amp;mut engine.scenes[self.scene]); 

    // v New code v 
    //
    for weapon in self.weapons.iter_mut() {
        weapon.update(dt);
    }

    // We're using `try_recv` here because we don't want to wait until next message -
    // if the queue is empty just continue to next frame.
    while let Ok(message) = self.receiver.try_recv() {
        match message {
            Message::ShootWeapon { weapon } =&gt; {
                self.shoot_weapon(weapon, engine);
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>So, these first three new lines updating every weapon in the game, for now update of a weapon just updates shooting timer.
As you can see we've added new parameter to the function <code>dt: f32</code>, this is the time span from last frame. Do not forget
to pass this parameter in <code>fn main()</code>: <code>game.update(&amp;mut engine, TIMESTEP);</code>. Finally, at the end of the function we're
handling messages from the queue one by one. As you can see we're handling <code>ShootWeapon</code> message, but there is a 
mysterious line <code>self.shoot_weapon(weapon, engine)</code> which is not yet defined, let's fix that, add these lines to 
<code>impl Game</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span> fn shoot_weapon(&amp;mut self, weapon: Handle&lt;Weapon&gt;, engine: &amp;mut Engine) {
    let weapon = &amp;mut self.weapons[weapon];

    if weapon.can_shoot() {
        weapon.shoot();

        let scene = &amp;mut engine.scenes[self.scene];

        let weapon_model = &amp;scene.graph[weapon.model()];

        // Make a ray that starts at the weapon's position in the world and look toward
        // &quot;look&quot; vector of the weapon.
        let ray = Ray::new(
            scene.graph[weapon.shot_point()].global_position(),
            weapon_model.look_vector().scale(1000.0),
        );

        let mut intersections = Vec::new();

        scene.graph.physics.cast_ray(
            RayCastOptions {
                ray_origin: Point3::from(ray.origin),
                max_len: ray.dir.norm(),
                groups: Default::default(),
                sort_results: true, // We need intersections to be sorted from closest to furthest.
                ray_direction: ray.dir,
            },
            &amp;mut intersections,
        );

        // Ignore intersections with player's capsule.
        let trail_length = if let Some(intersection) = intersections
            .iter()
            .find(|i| i.collider != self.player.collider)
        {
            //
            // TODO: Add code to handle intersections with bots.
            //

            // For now just apply some force at the point of impact.
            let colliders_parent = scene.graph[intersection.collider].parent();
            let picked_rigid_body = scene.graph[colliders_parent].as_rigid_body_mut();
            picked_rigid_body.apply_force_at_point(
                ray.dir.normalize().scale(10.0),
                intersection.position.coords,
            );
            picked_rigid_body.wake_up();

            // Trail length will be the length of line between intersection point and ray origin.
            (intersection.position.coords - ray.origin).norm()
        } else {
            // Otherwise trail length will be just the ray length.
            ray.dir.norm()
        };

        create_shot_trail(&amp;mut scene.graph, ray.origin, ray.dir, trail_length);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Wow! Why is there so much code to shoot a weapon!? Actually, this is not all the code - check the last line</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>create_shot_trail(&amp;mut scene.graph, ray.origin, ray.dir, trail_length);
<span class="boring">}</span></code></pre></pre>
<p>This is yet another function we must add, it is a standalone helper function that creates a shot trail:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::{
</span><span class="boring">        algebra::{UnitQuaternion, Vector3},
</span><span class="boring">        color::Color,
</span><span class="boring">        parking_lot::Mutex,
</span><span class="boring">        sstorage::ImmutableString,
</span><span class="boring">    },
</span><span class="boring">    material::{Material, PropertyValue, SharedMaterial},
</span><span class="boring">    scene::{
</span><span class="boring">        base::BaseBuilder,
</span><span class="boring">        graph::Graph,
</span><span class="boring">        mesh::{
</span><span class="boring">            surface::{SurfaceBuilder, SurfaceData, SurfaceSharedData},
</span><span class="boring">            MeshBuilder, RenderPath,
</span><span class="boring">        },
</span><span class="boring">        transform::TransformBuilder,
</span><span class="boring">    },
</span><span class="boring">};
</span>use std::sync::Arc;
fn create_shot_trail(
    graph: &amp;mut Graph,
    origin: Vector3&lt;f32&gt;,
    direction: Vector3&lt;f32&gt;,
    trail_length: f32,
) {
    let transform = TransformBuilder::new()
        .with_local_position(origin)
        // Scale the trail in XZ plane to make it thin, and apply `trail_length` scale on Y axis
        // to stretch is out.
        .with_local_scale(Vector3::new(0.0025, 0.0025, trail_length))
        // Rotate the trail along given `direction`
        .with_local_rotation(UnitQuaternion::face_towards(&amp;direction, &amp;Vector3::y()))
        .build();

    // Create unit cylinder with caps that faces toward Z axis.
    let shape = SurfaceSharedData::new(SurfaceData::make_cylinder(
        6,     // Count of sides
        1.0,   // Radius
        1.0,   // Height
        false, // No caps are needed.
        // Rotate vertical cylinder around X axis to make it face towards Z axis
        &amp;UnitQuaternion::from_axis_angle(&amp;Vector3::x_axis(), 90.0f32.to_radians()).to_homogeneous(),
    ));

    // Create an instance of standard material for the shot trail.
    let mut material = Material::standard();
    material
        .set_property(
            &amp;ImmutableString::new(&quot;diffuseColor&quot;),
            // Set yellow-ish color.
            PropertyValue::Color(Color::from_rgba(255, 255, 0, 120)),
        )
        .unwrap();

    MeshBuilder::new(
        BaseBuilder::new()
            // Do not cast shadows.
            .with_cast_shadows(false)
            .with_local_transform(transform)
            // Shot trail should live ~0.25 seconds, after that it will be automatically
            // destroyed.
            .with_lifetime(0.25),
    )
    .with_surfaces(vec![SurfaceBuilder::new(shape)
        .with_material(SharedMaterial::new(material))
        .build()])
    // Make sure to set Forward render path, otherwise the object won't be
    // transparent.
    .with_render_path(RenderPath::Forward)
    .build(graph);
}
<span class="boring">}</span></code></pre></pre>
<p>Okay... Let's disassemble this heap of code line by line. At first, we're borrowing the weapon by its handle and 
check if it can shoot (if the timer has reached zero), and &quot;shoot&quot; (reset the timer) if so:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span> let weapon = &amp;mut self.weapons[weapon];

    if weapon.can_shoot() {
        weapon.shoot();
    ...
<span class="boring">}</span></code></pre></pre>
<p>Next we're using ray casting to find the target we're shooting at:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ...

let scene = &amp;mut engine.scenes[self.scene];

let weapon_model = &amp;scene.graph[weapon.model()];

// Make a ray that starts at the weapon's position in the world and look toward
// &quot;look&quot; vector of the weapon.
let ray = Ray::new(
    scene.graph[weapon.shot_point()].global_position(),
    weapon_model.look_vector().scale(1000.0),
);

let mut intersections = Vec::new();

scene.graph.physics.cast_ray(
    RayCastOptions {
        ray_origin: Point3::from(ray.origin),
        max_len: ray.dir.norm(),
        groups: Default::default(),
        sort_results: true, // We need intersections to be sorted from closest to furthest.
        ray_direction: ray.dir,
    },
    &amp;mut intersections,
);

...
<span class="boring">}</span></code></pre></pre>
<p>To determine the &quot;target&quot;, we're have to make a ray first. It starts from the &quot;shot point&quot; we've attached to the weapon.
Direction of the ray is the &quot;look&quot; vector of the weapon model scaled by some large value which defines a &quot;length&quot; of the
ray. Finally, we're casting the ray. Next we have to check each intersection and find the target:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Ignore intersections with player's capsule.
let trail_length = if let Some(intersection) = intersections
    .iter()
    .find(|i| i.collider != self.player.collider)
{
    //
    // TODO: Add code to handle intersections with bots.
    //

    // For now just apply some force at the point of impact.
    let colliders_parent = scene.graph[intersection.collider].parent();
    let picked_rigid_body = scene.graph[colliders_parent].as_rigid_body_mut();
    picked_rigid_body.apply_force_at_point(
        ray.dir.normalize().scale(10.0),
        intersection.position.coords,
    );
    picked_rigid_body.wake_up();

    // Trail length will be the length of line between intersection point and ray origin.
    (intersection.position.coords - ray.origin).norm()
} else {
    // Otherwise trail length will be just the ray length.
    ray.dir.norm()
};
<span class="boring">}</span></code></pre></pre>
<p>First intersection most likely will be player's capsule, because shot point may be inside player's capsule. We're 
filtering such intersection in the first three lines. To do that, we have to remember the handle of player's capsule
in <code>Player</code>: <code>collider: Handle&lt;Node&gt;</code> and fill the field in <code>Player::new</code> like this:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let collider;
...
// Add capsule collider for the rigid body.
{
    collider = ColliderBuilder::new(BaseBuilder::new())
        .with_shape(ColliderShape::capsule_y(0.25, 0.2))
        .build(&amp;mut scene.graph);
    collider
}

...

Self {
    ...
    collider, // &lt;-
    ...
}

<span class="boring">}</span></code></pre></pre>
<p>Next goes <code>TODO</code> comment, remember this line, it will be replaced when we'll add bots in future tutorial.
Until we have no bots, we should somehow emulate shot impact, to do that we'll just apply some force at the point of
impact. Finally, we're calculating desired shot trail length - it is just distance between point of impact and ray's 
origin. In the <code>else</code> branch we're setting the length to be the length of the ray. Finally, we're creating a shot trail: </p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>create_shot_trail(&amp;mut scene.graph, ray.origin, ray.dir, trail_length);
<span class="boring">}</span></code></pre></pre>
<p>Now let's dive into this function. It starts from the definition of local transform of the trail:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let transform = TransformBuilder::new()
    .with_local_position(origin)
    // Scale the trail in XZ plane to make it thin, and apply `trail_length` scale on Y axis
    // to stretch is out.
    .with_local_scale(Vector3::new(0.0025, 0.0025, trail_length))
    // Rotate the trail along given `direction`
    .with_local_rotation(UnitQuaternion::face_towards(&amp;direction, &amp;Vector3::y()))
    .build();
<span class="boring">}</span></code></pre></pre>
<p>Its purpose is to shrink cylinder in XZ plane and stretch it out on Y axis to the length of the trail. Next we're making
geometry for the cylinder:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let shape = SurfaceSharedData::new(SurfaceData::make_cylinder(
    6,     // Count of sides
    1.0,   // Radius
    1.0,   // Height
    false, // No caps are needed.
    // Rotate vertical cylinder around X axis to make it face towards Z axis
    &amp;UnitQuaternion::from_axis_angle(&amp;Vector3::x_axis(), 90.0f32.to_radians()).to_homogeneous(),
));
<span class="boring">}</span></code></pre></pre>
<p>Here we're creating unit vertical cylinder, rotate it to make it face towards Z axis. Finally, we're creating mesh node:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Create an instance of standard material for the shot trail.
let mut material = Material::standard();
material
    .set_property(
        &amp;ImmutableString::new(&quot;diffuseColor&quot;),
        // Set yellow-ish color.
        PropertyValue::Color(Color::from_rgba(255, 255, 0, 120)),
    )
    .unwrap();

MeshBuilder::new(
    BaseBuilder::new()
        .with_local_transform(transform)
        // Shot trail should live ~0.25 seconds, after that it will be automatically
        // destroyed.
        .with_lifetime(0.25),
)
.with_surfaces(vec![SurfaceBuilder::new(shape)
    .with_material(SharedMaterial::new(material))
    .build()])
// Do not cast shadows.
.with_cast_shadows(false)
// Make sure to set Forward render path, otherwise the object won't be
// transparent.
.with_render_path(RenderPath::Forward)
.build(graph);
<span class="boring">}</span></code></pre></pre>
<p>The trail will live just 0.25 seconds, Fyrox has built-in functionality for short-living objects, you have to just set 
desired lifetime, and an object will be removed at the time. Also, we don't want the trail to cast shadows, and we want 
the trail to be transparent yellow, to do that we have to change render path of the mesh to <code>Forward</code>. In short, every
mesh by default rendered using <code>Deferred</code> renderer which does not support transparent objects due to technical reasons,
but Fyrox has <code>Forward</code> renderer for such objects. Check this <a href="https://www.3dgep.com/forward-plus/">article</a> to learn more 
about Deferred and Forward rendering techniques. Ok, now we have to &quot;teach&quot; player how to shoot. At first, let's add new 
field to <code>InputController</code>: <code>shoot: bool</code>. We'll be changing this flag by left mouse click, to do that let's add these lines
at the end of <code>Event::WindowEvent</code> match arm before <code>_ =&gt; {}</code> in <code>Player::process_input_event</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>&amp;WindowEvent::MouseInput { button, state, .. } =&gt; {
    if button == MouseButton::Left {
        self.controller.shoot = state == ElementState::Pressed;
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Now we need a way to send messages to the game from the player. We need a new field in <code>Player</code> struct 
<code>sender: Sender&lt;Message&gt;</code>. Also, we must change signature of <code>Player::new()</code> to this:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn new(
    scene: &amp;mut Scene,
    resource_manager: ResourceManager,
    sender: Sender&lt;Message&gt;,
) -&gt; Self 
<span class="boring">}</span></code></pre></pre>
<p>Just pass the <code>sender</code> in the <code>Self { .. }</code> like this: </p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Self {
    ...
    sender, // &lt;- Pass sender 
    ...
}
<span class="boring">}</span></code></pre></pre>
<p>Player must know about its weapons, let's fix this by adding new field to the <code>Player</code>: <code>weapon: Handle&lt;Weapon&gt;</code>, we'll
fill this field in the <code>Game::new()</code>, not in <code>Player::new()</code> because at the moment of creation of the player there are
no weapons:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>...

// Put the weapon into it - this operation moves the weapon in the pool and returns handle.
let weapon = weapons.spawn(weapon);

// &quot;Give&quot; the weapon to the player.
player.weapon = weapon;

...
<span class="boring">}</span></code></pre></pre>
<p>Finally, at the end of <code>Player::update</code> we will handle the state of the input controller:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if self.controller.shoot {
    self.sender
        .send(Message::ShootWeapon {
            weapon: self.weapon,
        })
        .unwrap();
}
<span class="boring">}</span></code></pre></pre>
<p>Ok, at this momemt you should be able to compile the game and as you run it, you should see something like this when
you'll press left mouse button:</p>
<p><img src="fyrox/tutorials/fps/tutorial-2/./shooting.jpg" alt="Weapon" /></p>
<p>Barrels should react to shots as in the video at the beginning of the tutorial. </p>
<h2 id="recoil"><a class="header" href="#recoil">Recoil</a></h2>
<p>Ok, the weapon shoots but looks kinda unnatural, to fix that we need to add a recoil. This is very simple to do, let's 
start by adding these fields in the <code>Weapon</code> struct:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>recoil_offset: Vector3&lt;f32&gt;,
recoil_target_offset: Vector3&lt;f32&gt;,
<span class="boring">}</span></code></pre></pre>
<p>Initialize these fields with default values (zero vector):</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>recoil_offset: Default::default(),
recoil_target_offset: Default::default(),
<span class="boring">}</span></code></pre></pre>
<p>First vector is the actual recoil offset that will be applied to the weapon model, second - target recoil value which
first vector will follow. Why do we need two vectors instead just one? The answer is very simple, we need to smoothly
change offset over time, and to do that offset will just &quot;follow&quot; target offset which will give us desired smooth 
movement. Let's add the code responsible for the recoil to the <code>Weapon::update</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Notice new `graph` parameter
pub fn update(&amp;mut self, dt: f32, graph: &amp;mut Graph) {  
    self.shot_timer = (self.shot_timer - dt).max(0.0);
    
    // v New code v
        
    // `follow` method defined in Vector3Ext trait and it just increases or
    // decreases vector's value in order to &quot;follow&quot; the target value with 
    // given speed.
    self.recoil_offset.follow(&amp;self.recoil_target_offset, 0.5);

    // Apply offset to weapon's model.
    graph[self.model]
        .local_transform_mut()
        .set_position(self.recoil_offset);

    // Check if we've reached target recoil offset.
    if self
        .recoil_offset
        .metric_distance(&amp;self.recoil_target_offset)
        &lt; 0.001
    {
        // And if so, reset offset to zero to return weapon at
        // its default position.
        self.recoil_target_offset = Default::default();
    }
}
<span class="boring">}</span></code></pre></pre>
<p>At first, in the first line we force the <code>recoil_offset</code> to follow <code>recoil_target_offset</code> with given speed. Next we're 
applying offset to weapon's model. Finally, we're checking if we've reached target offset and if so, just reset target
offset to return a weapon to its default position. Also we have to slightly modify <code>Weapon::shoot</code> to modify target
offset:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn shoot(&amp;mut self) {
    self.shot_timer = 0.1;

    // Set new offset after each shot.
    self.recoil_target_offset = Vector3::new(0.0, 0.0, -0.025); 
}
<span class="boring">}</span></code></pre></pre>
<p>The last thing we need to do is to slightly modify code at the <code>Game::update</code> to pass new parameter to <code>Weapon::update</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span> pub fn update(&amp;mut self, engine: &amp;mut GameEngine, dt: f32) {
    let scene = &amp;mut engine.scenes[self.scene];

    self.player.update(scene);

    for weapon in self.weapons.iter_mut() {
        weapon.update(dt, &amp;mut scene.graph);
    }
        
    ...
<span class="boring">}</span></code></pre></pre>
<p>Ok, run the game, and the weapon should feel more natural now. </p>
<h2 id="impact-effects"><a class="header" href="#impact-effects">Impact effects</a></h2>
<p>Shooting have become much better after we've added a recoil, but there is still no impact effects like sparks. Let's fix
that! This is the first time when we'll use particle systems. Let's add this function somewhere in <code>main.rs</code></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::{
</span><span class="boring">        algebra::{UnitQuaternion, Vector3},
</span><span class="boring">        color::Color,
</span><span class="boring">        color_gradient::{ColorGradient, GradientPoint},
</span><span class="boring">        pool::Handle,
</span><span class="boring">    },
</span><span class="boring">    asset::manager::ResourceManager, resource::texture::Texture,
</span><span class="boring">    scene::{
</span><span class="boring">        base::BaseBuilder,
</span><span class="boring">        graph::Graph,
</span><span class="boring">        node::Node,
</span><span class="boring">        particle_system::{
</span><span class="boring">            emitter::{base::BaseEmitterBuilder, sphere::SphereEmitterBuilder},
</span><span class="boring">            ParticleSystemBuilder,
</span><span class="boring">        },
</span><span class="boring">        transform::TransformBuilder,
</span><span class="boring">    },
</span><span class="boring">};
</span><span class="boring">use std::path::Path;
</span>fn create_bullet_impact(
    graph: &amp;mut Graph,
    resource_manager: ResourceManager,
    pos: Vector3&lt;f32&gt;,
    orientation: UnitQuaternion&lt;f32&gt;,
) -&gt; Handle&lt;Node&gt; {
    // Create sphere emitter first.
    let emitter = SphereEmitterBuilder::new(
        BaseEmitterBuilder::new()
            .with_max_particles(200)
            .with_spawn_rate(3000)
            .with_size_modifier_range(-0.01..-0.0125)
            .with_size_range(0.0075..0.015)
            .with_lifetime_range(0.05..0.2)
            .with_x_velocity_range(-0.0075..0.0075)
            .with_y_velocity_range(-0.0075..0.0075)
            .with_z_velocity_range(0.025..0.045)
            .resurrect_particles(false),
    )
    .with_radius(0.01)
    .build();

    // Color gradient will be used to modify color of each particle over its lifetime.
    let color_gradient = {
        let mut gradient = ColorGradient::new();
        gradient.add_point(GradientPoint::new(0.00, Color::from_rgba(255, 255, 0, 0)));
        gradient.add_point(GradientPoint::new(0.05, Color::from_rgba(255, 160, 0, 255)));
        gradient.add_point(GradientPoint::new(0.95, Color::from_rgba(255, 120, 0, 255)));
        gradient.add_point(GradientPoint::new(1.00, Color::from_rgba(255, 60, 0, 0)));
        gradient
    };

    // Create new transform to orient and position particle system.
    let transform = TransformBuilder::new()
        .with_local_position(pos)
        .with_local_rotation(orientation)
        .build();

    // Finally create particle system with limited lifetime.
    ParticleSystemBuilder::new(
        BaseBuilder::new()
            .with_lifetime(1.0)
            .with_local_transform(transform),
    )
    .with_acceleration(Vector3::new(0.0, 0.0, 0.0))
    .with_color_over_lifetime_gradient(color_gradient)
    .with_emitters(vec![emitter])
    // We'll use simple spark texture for each particle.
    .with_texture(resource_manager.request::&lt;Texture, _&gt;(Path::new(&quot;data/textures/spark.png&quot;)))
    .build(graph)
}
<span class="boring">}</span></code></pre></pre>
<p>Ok, again a heap of code... As usual, everything here is pretty straightforward. At first, we're creating spherical
emitter - it is a spherical volume that responsible for spawning particles. It has a radius, and a bunch of basic properties
such as spawn rate, maximum amount of particles, initial velocity range, etc. Next we're creating color gradient to make
particles fade over their lifetime. Next, we're creating simple transform that will orient and position particle system 
in world space. Finally, we're creating particle system itself, using pre-made parts. For each particle we'll use simple
<a href="fyrox/tutorials/fps/tutorial-2/./spark.png">spark texture</a>, it should be placed in <code>data/textures</code>. Now we need to find
correct place to create this particle system. It should be placed right after we're applying force to target we've hit 
in <code>Game::shoot_weapon</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Add bullet impact effect.
let effect_orientation = vector_to_quat(intersection.normal);

create_bullet_impact(
    &amp;mut scene.graph,
    engine.resource_manager.clone(),
    intersection.position.coords,
    effect_orientation,
);
<span class="boring">}</span></code></pre></pre>
<p>Ok, now run the game, and you should see something like this:</p>
<p><img src="fyrox/tutorials/fps/tutorial-2/./impact.jpg" alt="Weapon" /></p>
<p>One more thing that could be added is bullet shells that should come from a weapon when we're shooting, but I think the
tutorial is already pretty big already, and I'll leave this as a &quot;homework&quot;, but I'll just give some hints of how to do 
this. Make or download a shell model in FBX format, then write a function that will load it via resource manager, 
instantiate it and create a physical body for it (with cylinder collider for example), link a model with a body and call 
this function when shooting a weapon.</p>
<h2 id="conclusion-1"><a class="header" href="#conclusion-1">Conclusion</a></h2>
<p>In this tutorial we added weapon to the game, added recoil to make shooting more natural, and added impact effects. I 
hope you liked this tutorial, and if so, please consider supporting the project on
<a href="https://patreon.com/mrdimas">Patreon</a> or <a href="https://liberapay.com/mrDIMAS">LiberaPay</a>. Source code is available on
<a href="https://github.com/FyroxEngine/Fyrox-tutorials">GitHub</a>. In the next tutorial we'll add sounds to the game and something
special (let it be a surprise).</p>
<p>Discussion: <a href="https://www.reddit.com/r/rust/comments/m2055c/writing_a_3d_shooter_using_rg3d_2_adding_shooting/">Reddit</a>,
<a href="https://discord.gg/xENF5Uh">Discord</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fps-tutorial-part-1---bots-and-ai"><a class="header" href="#fps-tutorial-part-1---bots-and-ai">FPS Tutorial Part 1 - Bots and AI</a></h1>
<p><strong>WARNING: This tutorial is using obsolete engine features, which are subject to be removed in future versions!</strong></p>
<p><strong>Source code</strong>: <a href="https://github.com/FyroxEngine/Fyrox-tutorials/tree/main/tutorial3-character-controller">GitHub</a></p>
<h2 id="table-of-contents-2"><a class="header" href="#table-of-contents-2">Table of contents</a></h2>
<ul>
<li><a href="fyrox/tutorials/fps/tutorial-3/tutorial-part-3.html#introduction">Introduction</a></li>
<li><a href="fyrox/tutorials/fps/tutorial-3/tutorial-part-3.html#bots">Bots</a></li>
<li><a href="fyrox/tutorials/fps/tutorial-3/tutorial-part-3.html#animations">Animations</a></li>
<li><a href="fyrox/tutorials/fps/tutorial-3/tutorial-part-3.html#simple-ai">Simple AI</a></li>
<li><a href="fyrox/tutorials/fps/tutorial-3/tutorial-part-3.html#conclusion">Conclusion</a></li>
</ul>
<h2 id="introduction-3"><a class="header" href="#introduction-3">Introduction</a></h2>
<p>In the previous tutorial we've added weapons, but we still have no bots to shoot at. Let's fix that! In this tutorial
we'll add bots and a very simple AI. Bots will be a bit dumb, but it will be fixed in future tutorials. This is the
result we're aiming in the tutorial:</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/dtudhbRBIq0" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<h2 id="bots"><a class="header" href="#bots">Bots</a></h2>
<p>Previous tutorials were children's play in comparison to this, prepare for some advanced stuff. Let's begin by adding
a separate module for bots - add <code>bot.rs</code> and fill it with following code:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use fyrox::engine::resource_manager::MaterialSearchOptions;
use fyrox::{
    animation::{
        machine::{Machine, Parameter, PoseNode, State, Transition},
        Animation,
    },
    core::{
        algebra::{UnitQuaternion, Vector3},
        pool::Handle,
    },
    asset::manager::ResourceManager,
    physics3d::{
        rapier::dynamics::RigidBodyBuilder, rapier::geometry::ColliderBuilder, ColliderHandle,
        RigidBodyHandle,
    },
    resource::model::Model,
    scene::{base::BaseBuilder, node::Node, Scene},
};

pub struct Bot {
    rigid_body: Handle&lt;Node&gt;,
    collider: Handle&lt;Node&gt;,
}

impl Bot {
    pub async fn new(
        scene: &amp;mut Scene,
        position: Vector3&lt;f32&gt;,
        resource_manager: ResourceManager,
    ) -&gt; Self {
        // Load bot 3D model as usual.
        let model = resource_manager
            .request::&lt;Model, _&gt;(&quot;data/models/zombie.fbx&quot;)
            .await
            .unwrap()
            .instantiate(scene);

        scene.graph[model]
            .local_transform_mut()
            // Move the model a bit down to make sure bot's feet will be on ground.
            .set_position(Vector3::new(0.0, -0.45, 0.0))
            // Scale the model because it is too big.
            .set_scale(Vector3::new(0.0047, 0.0047, 0.0047));

        let collider;
        let rigid_body = RigidBodyBuilder::new(
            BaseBuilder::new()
                .with_local_transform(
                    TransformBuilder::new()
                        .with_local_position(Vector3::new(position.x, position.y, position.z))
                        .build(),
                )
                .with_children(&amp;[
                    // Attach model to the rigid body.
                    model,
                    // Add capsule collider for the rigid body.
                    {
                        collider = ColliderBuilder::new(BaseBuilder::new())
                            .with_shape(ColliderShape::capsule_y(0.25, 0.2))
                            .build(&amp;mut scene.graph);
                        collider
                    },
                ]),
        )
        // We don't want a bot to tilt.
        .with_locked_rotations(true)
        .with_can_sleep(false)
        .build(&amp;mut scene.graph);

        Self {
            rigid_body,
            collider,
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Ok, before we dive into the code, we need to add some more code in <code>main.rs</code>, let's begin by adding a container for
bots in <code>Game</code>: <code>bots: Pool&lt;Bot&gt;,</code>. Next we need to add some more code to <code>Game::new</code> where we'll add a bot instance in
the game. Also, you can add more than one bot at different positions if you want. Do not forget to download bot model
with textures from <a href="fyrox/tutorials/fps/tutorial-3/./zombie.zip">here</a> and unpack <code>fbx</code> file in <code>data/models</code> and other files
(textures), in <code>data/textures</code>.</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Add some bots.
let mut bots = Pool::new();

bots.spawn(
    Bot::new(
        &amp;mut scene,
        Vector3::new(-1.0, 1.0, -1.0),
        engine.resource_manager.clone(),
    )
    .await,
);

...

Self {
    ...
    bots
}
<span class="boring">}</span></code></pre></pre>
<p>As usual, let's disassemble the code line-by-line. Creation of bot begins from loading its 3D model in the scene:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let model = resource_manager
    .request::&lt;Model, _&gt;(&quot;data/models/zombie.fbx&quot;)
    .await
    .unwrap()
    .instantiate(scene);
<span class="boring">}</span></code></pre></pre>
<p>Nothing really new here, loading and instantiation of a 3D model of <em>any</em> complexity is the same as before. Next we have
to slightly modify the model, shift it a bit down and shrink:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>scene.graph[model]
    .local_transform_mut()
    // Move the model a bit down to make sure bot's feet will be on ground.
    .set_position(Vector3::new(0.0, -0.45, 0.0))
    // Scale the model because it is too big.
    .set_scale(Vector3::new(0.0047, 0.0047, 0.0047));
<span class="boring">}</span></code></pre></pre>
<p>Here we're borrow model in the scene graph, and modify its local transform. Next we're creating rigid body with a capsule
collider, and attaching the model to the rigid body:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let collider;
let rigid_body = RigidBodyBuilder::new(
    BaseBuilder::new()
        .with_local_transform(
            TransformBuilder::new()
                .with_local_position(Vector3::new(position.x, position.y, position.z))
                .build(),
        )
        .with_children(&amp;[
            // Attach model to the rigid body.
            model,
            // Add capsule collider for the rigid body.
            {
                collider = ColliderBuilder::new(BaseBuilder::new())
                    .with_shape(ColliderShape::capsule_y(0.25, 0.2))
                    .build(&amp;mut scene.graph);
                collider
            },
        ]),
)
// We don't want a bot to tilt.
.with_locked_rotations(true)
.with_can_sleep(false)
.build(&amp;mut scene.graph);
<span class="boring">}</span></code></pre></pre>
<p>Finally, we're returning bot's instance:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Self {
    pivot,
    rigid_body,
    collider,
}
<span class="boring">}</span></code></pre></pre>
<p>Ok, now for the bots instantiation, for simplicity we create a single bot in <code>Game::new</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut bots = Pool::new();

bots.spawn(
    Bot::new(
        &amp;mut scene,
        Vector3::new(-1.0, 1.0, 1.5),
        engine.resource_manager.clone(),
    )
    .await,
);
<span class="boring">}</span></code></pre></pre>
<p>As you can see, we'll store bots in a pool as many other game entities, this will allow us to borrow bots later on when 
we'll be adding AI. Ok, now run the game, and you should see something like this:</p>
<p><img src="fyrox/tutorials/fps/tutorial-3/./bot.jpg" alt="Weapon" /></p>
<p>Wow... a T-posing bot... Is this some kind of Cyberpunk 2077 reference? This is boring, let's add some animations to 
make it more &quot;alive&quot;.</p>
<h3 id="animations"><a class="header" href="#animations">Animations</a></h3>
<p>Let's start from definition of animation. Animation is a set of tracks, where each track responsible for animation
of a single node and contains key frames placed on a timeline with some transition rules between key frames. Animation
usually changes just position/rotation/scale of a node. When animation is playing it calculates intermediate values for
each parameter using interpolation techniques (linear and spherical interpolation). Animations in general is very simple
and powerful technique, but at many times it still does not enough. If you will just switch multiple animations from one
to one, it will look very bad and unnatural. This is where animation blending machines come into play.</p>
<p><img src="fyrox/tutorials/fps/tutorial-3/./animation.png" alt="Weapon" /></p>
<p>Fyrox provides very powerful mechanism for animations - animation blending machines. If you're already familiar with 
Mecanim in Unity game engine or similar thing in Unreal Engine, then you'll probably already understood what will be
in this paragraph. Animation blending machine (ABM) is a state machine that allows you to blend multiple animations
in one and apply it to a set of bones (or nodes in general). ABM is a graph where each node is a state, each state
has a source of animation pose which in its turn may be another subgraph of pose emitting nodes. States connected 
between each other using transition edges which have some parameters like transition time, a rule for transition, etc.
At each moment of time either state or transition can be active. In other words this means that ABM is either
transitioning from a state to state or hold a state. This leads to another fact - ABM cannot jump from a state to state
if they're not connected with transition edge. ABMs in general can be represented like this:</p>
<p><img src="fyrox/tutorials/fps/tutorial-3/./machine.png" alt="Weapon" /></p>
<p>States are marked yellow, animation nodes - blue, animations - green. As you can see there can be multiple transitions
between states, each transition has corresponding <code>Rule</code> parameter which is a simple boolean value which tells a machine
when it is possible to start transition. Each state is supplied with animation node (<code>PlayAnimation</code>, <code>BlendAnimations</code>,
<code>BlendAnimationsByIndex</code>, etc.) which does exactly what the name states. <code>PlayAnimation</code> just plays given animation, 
<code>BlendAnimations</code> - blends multiple animations with different weights into one, BlendAnimationsByIndex - blends multiple
animations as the BlendAnimations, but each animation has transition time, and the node uses an index parameter to switch
between attached animations. Please keep in mind that <code>BlendAnimations</code> node can have various sources of pose, as you can 
see in the picture, it uses two <code>PlayAnimation</code> nodes as source of poses, but nothing keeps you from adding new pose source
which will be yet another <code>BlendAnimations</code>. So everything depends on your needs and ABM just gives you enough flexibility.</p>
<p>Ok, back to the game. Let's create a simple ABM for bots. For simplicity, it will contain only three states - Idle, Walk,
Attack. Put this code somewhere at the end of <code>bot.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Simple helper method to create a state supplied with PlayAnimation node.
fn create_play_animation_state(
    animation_resource: Model,
    name: &amp;str,
    layer: &amp;mut MachineLayer,
    scene: &amp;mut Scene,
    model: Handle&lt;Node&gt;,
) -&gt; (Handle&lt;Animation&gt;, Handle&lt;State&gt;) {
    // Animations retargetting just makes an instance of animation and binds it to
    // given model using names of bones.
    let animation = *animation_resource
        .retarget_animations(model, &amp;mut scene.graph)
        .get(0)
        .unwrap();
    // Create new PlayAnimation node and add it to machine.
    let node = layer.add_node(PoseNode::make_play_animation(animation));
    // Make a state using the node we've made.
    let state = layer.add_state(State::new(name, node));
    (animation, state)
}

pub struct BotAnimationMachineInput {
    // Whether a bot is walking or not.
    pub walk: bool,
    // Whether a bot is attacking or not.
    pub attack: bool,
}

pub struct BotAnimationMachine {
    animation_player: Handle&lt;Node&gt;,
    machine: Machine,
}

impl BotAnimationMachine {
    // Names of parameters that will be used for transition rules in machine.
    const IDLE_TO_WALK: &amp;'static str = &quot;IdleToWalk&quot;;
    const WALK_TO_IDLE: &amp;'static str = &quot;WalkToIdle&quot;;
    const WALK_TO_ATTACK: &amp;'static str = &quot;WalkToAttack&quot;;
    const IDLE_TO_ATTACK: &amp;'static str = &quot;IdleToAttack&quot;;
    const ATTACK_TO_IDLE: &amp;'static str = &quot;AttackToIdle&quot;;
    const ATTACK_TO_WALK: &amp;'static str = &quot;AttackToWalk&quot;;

    pub async fn new(
        scene: &amp;mut Scene,
        model: Handle&lt;Node&gt;,
        resource_manager: ResourceManager,
    ) -&gt; Self {
        let animation_player =
            AnimationPlayerBuilder::new(BaseBuilder::new()).build(&amp;mut scene.graph);
        scene.graph.link_nodes(animation_player, model);

        let mut machine = Machine::new();

        let root = machine.layers_mut().first_mut().unwrap();

        // Load animations in parallel.
        let (walk_animation_resource, idle_animation_resource, attack_animation_resource) = fyrox::core::futures::join!(
            resource_manager.request::&lt;Model, _&gt;(&quot;data/animations/zombie_walk.fbx&quot;),
            resource_manager.request::&lt;Model, _&gt;(&quot;data/animations/zombie_idle.fbx&quot;),
            resource_manager.request::&lt;Model, _&gt;(&quot;data/animations/zombie_attack.fbx&quot;),
        );

        // Now create three states with different animations.
        let (_, idle_state) = create_play_animation_state(
            idle_animation_resource.unwrap(),
            &quot;Idle&quot;,
            root,
            scene,
            model,
        );

        let (walk_animation, walk_state) = create_play_animation_state(
            walk_animation_resource.unwrap(),
            &quot;Walk&quot;,
            root,
            scene,
            model,
        );

        let (attack_animation, attack_state) = create_play_animation_state(
            attack_animation_resource.unwrap(),
            &quot;Attack&quot;,
            root,
            scene,
            model,
        );

        // Next, define transitions between states.
        root.add_transition(Transition::new(
            // A name for debugging.
            &quot;Idle-&gt;Walk&quot;,
            // Source state.
            idle_state,
            // Target state.
            walk_state,
            // Transition time in seconds.
            0.4,
            // A name of transition rule parameter.
            Self::IDLE_TO_WALK,
        ));
        root.add_transition(Transition::new(
            &quot;Walk-&gt;Idle&quot;,
            walk_state,
            idle_state,
            0.4,
            Self::WALK_TO_IDLE,
        ));
        root.add_transition(Transition::new(
            &quot;Walk-&gt;Attack&quot;,
            walk_state,
            attack_state,
            0.4,
            Self::WALK_TO_ATTACK,
        ));
        root.add_transition(Transition::new(
            &quot;Idle-&gt;Attack&quot;,
            idle_state,
            attack_state,
            0.4,
            Self::IDLE_TO_ATTACK,
        ));
        root.add_transition(Transition::new(
            &quot;Attack-&gt;Idle&quot;,
            attack_state,
            idle_state,
            0.4,
            Self::ATTACK_TO_IDLE,
        ));
        root.add_transition(Transition::new(
            &quot;Attack-&gt;Walk&quot;,
            attack_state,
            walk_state,
            0.4,
            Self::ATTACK_TO_WALK,
        ));

        // Define entry state.
        root.set_entry_state(idle_state);

        Self {
            animation_player,
            machine,
        }
    }

    pub fn update(&amp;mut self, scene: &amp;mut Scene, dt: f32, input: BotAnimationMachineInput) {
        let animation_player = scene.graph[self.animation_player]
            .query_component_ref::&lt;AnimationPlayer&gt;()
            .unwrap();

        self.machine
            // Set transition parameters.
            .set_parameter(Self::WALK_TO_IDLE, Parameter::Rule(!input.walk))
            .set_parameter(Self::IDLE_TO_WALK, Parameter::Rule(input.walk))
            .set_parameter(Self::WALK_TO_ATTACK, Parameter::Rule(input.attack))
            .set_parameter(Self::IDLE_TO_ATTACK, Parameter::Rule(input.attack))
            .set_parameter(Self::ATTACK_TO_IDLE, Parameter::Rule(!input.attack))
            .set_parameter(Self::ATTACK_TO_WALK, Parameter::Rule(!input.attack))
            // Update machine and evaluate final pose.
            .evaluate_pose(animation_player.animations(), dt)
            // Apply the pose to the graph.
            .apply(&amp;mut scene.graph);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Ok, this might be the biggest heap of code we've ever been dealing with at once. There is lots of stuff happening, 
let's thoroughly &quot;scan&quot; this code. It starts from the simple helper method to create states:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Simple helper method to create a state supplied with PlayAnimation node.
fn create_play_animation_state(
    animation_resource: Model,
    name: &amp;str,
    layer: &amp;mut MachineLayer,
    scene: &amp;mut Scene,
    model: Handle&lt;Node&gt;,
) -&gt; (Handle&lt;Animation&gt;, Handle&lt;State&gt;) {
    // Animations retargetting just makes an instance of animation and binds it to
    // given model using names of bones.
    let animation = *animation_resource
        .retarget_animations(model, &amp;mut scene.graph)
        .get(0)
        .unwrap();
    // Create new PlayAnimation node and add it to machine.
    let node = layer.add_node(PoseNode::make_play_animation(animation));
    // Make a state using the node we've made.
    let state = layer.add_state(State::new(name, node));
    (animation, state)
}
<span class="boring">}</span></code></pre></pre>
<p>Here we're using new method of Model resource - <a href="https://github.com/FyroxEngine/Fyrox/blob/master/src/resource/model.rs#L110">retarget_animations</a>,
in short, it creates an instance of animation, and binds animations tracks to nodes in given sub graph that starts from
a node given as first parameter. Next we're adding a PlayAnimation node to machine and making a new state node. Now we're
adding a structure with input parameter for ABM:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct BotAnimationMachineInput {
    // Whether a bot is walking or not.
    pub walk: bool,
    // Whether a bot is attacking or not.
    pub attack: bool,
}
<span class="boring">}</span></code></pre></pre>
<p>This structure will contain more flags in the future, but now on to <code>BotAnimationMachine::new()</code>. At first, we're creating
new ABM instance, nothing fancy here. Next we're loading animations in parallel: </p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut machine = Machine::new();

// Load animations in parallel.
let (walk_animation_resource, idle_animation_resource, attack_animation_resource) = fyrox::core::futures::join!(
    resource_manager.request::&lt;Model, _&gt;(&quot;data/animations/zombie_walk.fbx&quot;),
    resource_manager.request::&lt;Model, _&gt;(&quot;data/animations/zombie_idle.fbx&quot;),
    resource_manager.request::&lt;Model, _&gt;(&quot;data/animations/zombie_attack.fbx&quot;),
);
<span class="boring">}</span></code></pre></pre>
<p>As you may have noticed, there is no difference between animation resource and model resource, this is because any 3D
model can have animations. The animations we're loading, contain only bones and key frames for them, but not mesh of a bot.
We simply don't need a mesh, because we've already created the mesh earlier. This separation of animations and mesh is 
very handy, because it saves CPU cycles and disk space. Ok, next we're creating states for ABM:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Now create three states with different animations.
let (_, idle_state) = create_play_animation_state(
    idle_animation_resource.unwrap(),
    &quot;Idle&quot;,
    root,
    scene,
    model,
);

let (walk_animation, walk_state) = create_play_animation_state(
    walk_animation_resource.unwrap(),
    &quot;Walk&quot;,
    root,
    scene,
    model,
);

let (attack_animation, attack_state) = create_play_animation_state(
    attack_animation_resource.unwrap(),
    &quot;Attack&quot;,
    root,
    scene,
    model,
);
<span class="boring">}</span></code></pre></pre>
<p>These states are those yellow-ish rectangles on diagram up above. As you can see we're creating three states: idle, walk,
attack. Next we need to connect states between each other. </p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Next, define transitions between states.
root.add_transition(Transition::new(
    // A name for debugging.
    &quot;Idle-&gt;Walk&quot;,
    // Source state.
    idle_state,
    // Target state.
    walk_state,
    // Transition time in seconds.
    0.4,
    // A name of transition rule parameter.
    Self::IDLE_TO_WALK,
));

... // Rest are intentionally omitted 
<span class="boring">}</span></code></pre></pre>
<p>Ok, comments should clarify what is going on here, but one thing I want to mention specifically. As you may have noticed,
transition is that black arrow on the diagram up above, and it is linked with a parameter. Parameter have a name, and as
you'll see later the name will be used to modify parameters. Finally, we're setting entry state to idle and return 
ABM instance:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Define entry state.
machine.set_entry_state(idle_state);

Self { machine }
<span class="boring">}</span></code></pre></pre>
<p>Now for another important part, we have to &quot;feed&quot; machine with actual parameters for each transition:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn update(&amp;mut self, scene: &amp;mut Scene, dt: f32, input: BotAnimationMachineInput) {
    let animation_player = scene.graph[self.animation_player]
        .query_component_ref::&lt;AnimationPlayer&gt;()
        .unwrap();

    self.machine
        // Set transition parameters.
        .set_parameter(Self::WALK_TO_IDLE, Parameter::Rule(!input.walk))
        .set_parameter(Self::IDLE_TO_WALK, Parameter::Rule(input.walk))
        .set_parameter(Self::WALK_TO_ATTACK, Parameter::Rule(input.attack))
        .set_parameter(Self::IDLE_TO_ATTACK, Parameter::Rule(input.attack))
        .set_parameter(Self::ATTACK_TO_IDLE, Parameter::Rule(!input.attack))
        .set_parameter(Self::ATTACK_TO_WALK, Parameter::Rule(!input.attack))
        // Update machine and evaluate final pose.
        .evaluate_pose(animation_player.animations(), dt)
        // Apply the pose to the graph.
        .apply(&amp;mut scene.graph);
}
<span class="boring">}</span></code></pre></pre>
<p>Here we're setting each transition rule one by one, then forcing machine to evaluate animation pose and apply it to 
the graph. You may ask how machine knows which nodes (bones) should be affected? Remember what was the definition of 
animation and its tracks? Right, each track knows about the node it affects, animation blending machine just combines
multiple sources of poses into one and animation for same node blends into a final pose and final pose contains animation
for each node that was used in all tracks used in ABM. </p>
<p>Next we need to use the machine we've made. Add a new field to <code>Bot</code>: <code>machine: BotAnimationMachine</code> and initialize it in
&quot;constructor&quot;:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Self {
    machine: BotAnimationMachine::new(scene, model, resource_manager).await,
    ...
}
<span class="boring">}</span></code></pre></pre>
<p>Next we need to update machine, add following method to <code>impl Bot</code>: </p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn update(&amp;mut self, scene: &amp;mut Scene, dt: f32) {
    // For now these are set to false which will force bot to be in idle state.
    let input = BotAnimationMachineInput {
        walk: false,
        attack: false,
    };

    self.machine.update(scene, dt, input);
}
<span class="boring">}</span></code></pre></pre>
<p>This method will update machine and &quot;feed&quot; it with actual state, for now the state has flags combination that forces
bot to be in idle state. This will be fixed when we'll add simple AI later in this tutorial. Finally, we need to update
each bot we have, go to <code>Game::update</code> and add following lines there (somewhere after update of weapons):</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for bot in self.bots.iter_mut() {
    bot.update(scene, dt);
}
<span class="boring">}</span></code></pre></pre>
<p>Now run the game, and you should see that bots now is in idle state and animation is playing, it should look like this:</p>
<p><img src="fyrox/tutorials/fps/tutorial-3/./animation.jpg" alt="Weapon" /></p>
<h2 id="simple-ai"><a class="header" href="#simple-ai">Simple AI</a></h2>
<p>Ok, now we have to use ABM we've made at full capacity, to do that we'll write simple AI - bot will just follow player
in a straight line and attack if they're close enough. Let's start by modifying <code>Bot::update</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn update(&amp;mut self, scene: &amp;mut Scene, dt: f32, target: Vector3&lt;f32&gt;) {
    let attack_distance = 0.6;

    // Simple AI - follow target by a straight line.
    let self_position = scene.graph[self.rigid_body].global_position();
    let direction = target - self_position;

    // Distance to target.
    let distance = direction.norm();

    if distance != 0.0 &amp;&amp; distance &lt; 1.5 {
        self.follow_target = true;
    }

    if self.follow_target &amp;&amp; distance != 0.0 {
        let rigid_body = scene.graph[self.rigid_body].as_rigid_body_mut();

        // Make sure bot is facing towards the target.
        rigid_body
            .local_transform_mut()
            .set_rotation(UnitQuaternion::face_towards(
                &amp;Vector3::new(direction.x, 0.0, direction.z),
                &amp;Vector3::y_axis(),
            ));

        // Move only if we're far enough from the target.
        if distance &gt; attack_distance {
            // Normalize direction vector and scale it by movement speed.
            let xz_velocity = direction.scale(1.0 / distance).scale(0.9);

            let new_velocity =
                Vector3::new(xz_velocity.x, rigid_body.lin_vel().y, xz_velocity.z);

            rigid_body.set_lin_vel(new_velocity);
        }
    }

    // For now these are set to false which will force bot to be in idle state.
    let input = BotAnimationMachineInput {
        walk: self.follow_target &amp;&amp; distance &gt; attack_distance,
        attack: distance &lt; attack_distance,
    };

    self.machine.update(scene, dt, input);
}
<span class="boring">}</span></code></pre></pre>
<p>Also add a new field to <code>Player</code>: <code>follow_target: bool</code> and initialize it in the constructor: </p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Self {
    follow_target: false,
    ...
}
<span class="boring">}</span></code></pre></pre>
<p>So, the AI algorithm is very simple - stand still until a target (player) come closer, once it's close enough, switch
<code>follow_target</code> flag to true and begin to follow the target. To do that, all we have to do is to find a vector between
target and position of a bot, make sure bots is facing towards the target and move it if it is far enough. So let's 
begin digging the code:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let attack_distance = 0.6;

// Simple AI - follow target by a straight line.
let self_position = scene.graph[self.pivot].global_position();
let direction = target - self_position;

// Distance to target.
let distance = direction.norm();

if distance != 0.0 &amp;&amp; distance &lt; 1.5 {
    self.follow_target = true;
}
<span class="boring">}</span></code></pre></pre>
<p>At the beginning we define a melee attack distance, bot will attack target only if it close enough. Next, we're 
building vector to from bot's position to target, calculate distance by taking length of the vector and check if 
we should switch <code>follow_target</code> flag. Next goes the most interesting parts of the AI:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if self.follow_target &amp;&amp; distance != 0.0 {
    let rigid_body = scene.graph[self.rigid_body].as_rigid_body_mut();

    // Make sure bot is facing towards the target.
    rigid_body
        .local_transform_mut()
        .set_rotation(UnitQuaternion::face_towards(
            &amp;Vector3::new(direction.x, 0.0, direction.z),
            &amp;Vector3::y_axis(),
        ));

    ...
<span class="boring">}</span></code></pre></pre>
<p>Here we just borrow rigid body a bot, and make sure it rotated towards the target. Next we're moving bot if it is
far enough from the target:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    ...

    // Move only if we're far enough from the target.
    if distance &gt; attack_distance {
        // Normalize direction vector and scale it by movement speed.
        let xz_velocity = direction.scale(1.0 / distance).scale(0.9);

        let new_velocity =
            Vector3::new(xz_velocity.x, rigid_body.lin_vel().y, xz_velocity.z);

        rigid_body.set_lin_vel(new_velocity);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This part is pretty simple too, all we have to do is to check how far the bot is, normalize direction vector, scale it
by movement speed and form new velocity vector using new XZ velocity + current Y velocity of a bot to preserve velocity
added by gravity (otherwise bot would just fly, you can experiment with this part to make flying zombies). One last
thing before we build and run the game, change lines of how we're updating bots to following lines:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let target = scene.graph[self.player.pivot].global_position();

for bot in self.bots.iter_mut() {
    bot.update(scene, dt, target);
}
<span class="boring">}</span></code></pre></pre>
<p>As you can see, here we're using player's position as target. In future tutorials we'll improve AI to be able to 
automatically select targets to attack. Also, we'll &quot;teach&quot; bots to use weapons. Now it's the time to build and run 
the game and you should see something like this (something like in the video at the beginning of the tutorial):</p>
<p><img src="fyrox/tutorials/fps/tutorial-3/./ai.jpg" alt="Weapon" /></p>
<h2 id="conclusion-2"><a class="header" href="#conclusion-2">Conclusion</a></h2>
<p>In this tutorial we've added bots, animations, and a simple AI. This was the most advanced tutorial so far, but I 
promise that this series is far from completion. I hope you liked this tutorial, and if so, please consider supporting 
the project on <a href="https://patreon.com/mrdimas">Patreon</a> or <a href="https://liberapay.com/mrDIMAS">LiberaPay</a>. Source code is 
available on <a href="https://github.com/FyroxEngine/Fyrox-tutorials">GitHub</a>.</p>
<p>Discussion: <a href="https://www.reddit.com/r/rust/comments/m2ydjc/bots_and_ai_writing_a_3d_shooter_using_rg3d_3/">Reddit</a>, 
<a href="https://discord.gg/xENF5Uh">Discord</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="role-playing-game-tutorial"><a class="header" href="#role-playing-game-tutorial">Role-Playing Game Tutorial</a></h1>
<p>This tutorial starts the series of tutorials about writing a role-playing game in Rust using Fyrox game engine. Strangely,
but Fyrox has a reputation of an engine for 3D shooters. In this series I'll try to prove that it is a general purpose
game engine.</p>
<h2 id="fyrox-and-fyroxed-version-1"><a class="header" href="#fyrox-and-fyroxed-version-1">Fyrox and Fyroxed version</a></h2>
<p>Fyrox changes rapidly and tutorial's code could not compile with the newest versions of the engine, to prevent that
and keep the code compilable over time the versions of both the engine and the editor are set to specific commits 
in the main repo.</p>
<p><strong>Fyrox version</strong>: 0.29
<strong>Source code</strong>: <a href="https://github.com/FyroxEngine/Fyrox-tutorials/">GitHub</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rpg-tutorial-part-1---character-controller"><a class="header" href="#rpg-tutorial-part-1---character-controller">RPG Tutorial Part 1 - Character Controller</a></h1>
<p><strong>Source code</strong>: <a href="https://github.com/FyroxEngine/Fyrox-tutorials/tree/main/rpg-tutorial1-character-controller">GitHub</a></p>
<h2 id="table-of-contents-3"><a class="header" href="#table-of-contents-3">Table of contents</a></h2>
<ul>
<li><a href="fyrox/tutorials/rpg/tutorial-1/tutorial-part-1.html#introduction">Introduction</a></li>
<li><a href="fyrox/tutorials/rpg/tutorial-1/tutorial-part-1.html#framework">Framework</a></li>
<li><a href="fyrox/tutorials/rpg/tutorial-1/tutorial-part-1.html#assets">Assets</a></li>
<li><a href="fyrox/tutorials/rpg/tutorial-1/tutorial-part-1.html#player-and-camera-controller">Player and camera controller</a></li>
<li><a href="fyrox/tutorials/rpg/tutorial-1/tutorial-part-1.html#camera-movement">Camera movement</a></li>
<li><a href="fyrox/tutorials/rpg/tutorial-1/tutorial-part-1.html#player-locomotion">Player locomotion</a></li>
<li><a href="fyrox/tutorials/rpg/tutorial-1/tutorial-part-1.html#animations">Animations</a></li>
<li><a href="fyrox/tutorials/rpg/tutorial-1/tutorial-part-1.html#conclusion">Conclusion</a></li>
</ul>
<h2 id="introduction-4"><a class="header" href="#introduction-4">Introduction</a></h2>
<p>In this series of tutorials we will make a game similar to The Elder Scrolls series (but much, much smaller indeed),
we'll have a main character, a simple world with intractable items and a few kind of enemies. I'll show you how to add an inventory,
a quests journal, and the quests itself. This series should have at least 5 tutorials, but this might change. At the end
of the series we'll have a playable RPG which you will be able to use to continue making your own game. It is very ambitious,
but totally doable with the current state of the engine.</p>
<p>Most of the role-playing games (RPGs for short) using 3rd person camera which allows you to see your character entirely.
In this tutorial we'll make something similar. Check the video with final result of the tutorial:</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/l2ZbDpoIdqk" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<p>As you can see, at the end of the tutorial we'll be able to walk and explore a small fantasy world. Let's start by creating
a new cargo project:</p>
<p><code>cargo init rpg-tutorial</code></p>
<p>Add <code>fyrox</code> as dependency:</p>
<pre><code class="language-toml">[dependencies]
fyrox = &quot;0.29.0&quot;
</code></pre>
<h2 id="framework"><a class="header" href="#framework">Framework</a></h2>
<p>Now let's create the window and initialize the engine. We'll skip most engine initialization by using new <code>Framework</code> helper
that hides most of the engine initialization and provides unified interface for your games allowing you to focus on
your game code. <code>Framework</code> is not mandatory, you may use the <a href="https://fyrox.rs/tutorials/2021/03/05/tutorial1.html#creating-a-window">previous</a>
variant with manual engine initialization and &quot;opened&quot; main loop.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">extern crate fyrox;
</span>use fyrox::{
    core::{color::Color, futures::executor::block_on, pool::Handle},
    engine::executor::Executor,
    event::{Event, WindowEvent},
    event_loop::ControlFlow,
    plugin::{Plugin, PluginConstructor, PluginContext},
    scene::{Scene},
};
use fyrox::window::WindowAttributes;
use fyrox::engine::GraphicsContextParams;

struct Game {
    scene: Handle&lt;Scene&gt;,
}

struct GameConstructor;

impl PluginConstructor for GameConstructor {
    fn create_instance(&amp;self, _: Handle&lt;Scene&gt;, context: PluginContext) -&gt; Box&lt;dyn Plugin&gt; {
        Box::new(Game::new(context))
    }
}

impl Game {
    fn new(context: PluginContext) -&gt; Self {
        let mut scene = Scene::new();

        scene.ambient_lighting_color = Color::opaque(150, 150, 150);
        
        Self {
            scene: context.scenes.add(scene),
        }
    }
}

impl Plugin for Game {
    fn update(&amp;mut self, context: &amp;mut PluginContext, _: &amp;mut ControlFlow) {
        
    }

    fn on_os_event(
        &amp;mut self,
        event: &amp;Event&lt;()&gt;,
        _context: PluginContext,
        _control_flow: &amp;mut ControlFlow,
    ) {
       
    }
}

fn main() {
    let mut executor = Executor::from_params(
        Default::default(),
        GraphicsContextParams {
            window_attributes: WindowAttributes {
                title: &quot;RPG&quot;.to_string(),
                ..Default::default()
            },
            vsync: true,
        },
    );
    executor.add_plugin_constructor(GameConstructor);
    executor.run();
}</code></pre></pre>
<p>It is much easier to initialize the engine now compared to the initialization described in the series of tutorials about
writing a 3D shooter. If you run it, you'll see a window with black background with an &quot;RPG&quot; title.</p>
<h2 id="assets-1"><a class="header" href="#assets-1">Assets</a></h2>
<p>For any kind of game you need a lot of various assets, in our case we need a 3D model for our character, a set of
animations, a level, a set of textures for terrain, trees and bushes, barrels, etc. I prepared all assets as a single
ZIP archive which can be downloaded <a href="fyrox/tutorials/rpg/tutorial-1/./data.zip">here</a>. Once you've downloaded it, unpack it in <code>./data</code> folder.</p>
<h2 id="player-and-camera-controller"><a class="header" href="#player-and-camera-controller">Player and camera controller</a></h2>
<p>Now we can start adding Player to our game. Create a folder <code>player</code> under your <code>src</code> directory and add <code>mod.rs</code> with
following content:</p>
<pre><pre class="playground"><code class="language-rust no_run edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span>
<span class="boring">#[cfg(test)]
</span>use crate::player::camera::CameraController;

// Import everything we need for the tutorial.
use fyrox::{
    animation::{
        machine::{Machine, MachineLayer, Parameter, PoseNode, State, Transition},
        Animation,
    },
    core::{
        algebra::{UnitQuaternion, Vector3},
        pool::Handle,
    },
    asset::manager::ResourceManager, 
    event::{DeviceEvent, ElementState, KeyboardInput, VirtualKeyCode},
    resource::model::{Model, ModelResourceExtension},
    scene::{
        animation::AnimationPlayer,
        base::BaseBuilder,
        collider::{ColliderBuilder, ColliderShape},
        graph::{Graph, physics::CoefficientCombineRule},
        node::Node,
        rigidbody::RigidBodyBuilder,
        transform::TransformBuilder,
        Scene,
    },
};

<span class="boring">#[cfg(test)]
</span>mod camera;

<span class="boring">struct CameraController;
</span><span class="boring">impl CameraController {
</span><span class="boring">    async fn new(_: &amp;mut Graph, _: ResourceManager) -&gt; Self { Self }
</span><span class="boring">}
</span>
pub struct Player {
    model: Handle&lt;Node&gt;,
    camera_controller: CameraController,
}

impl Player {
    pub async fn new(resource_manager: ResourceManager, scene: &amp;mut Scene) -&gt; Self {
        // Load paladin 3D model and create its instance in the scene.
        let model = resource_manager
            .request::&lt;Model, _&gt;(&quot;data/models/paladin/paladin.fbx&quot;)
            .await
            .unwrap()
            .instantiate(scene);

        scene.graph[model]
            .local_transform_mut()
            // Move the model a bit down because its center is at model's feet
            // and we'd get floating model without this offset.
            .set_position(Vector3::new(0.0, -0.75, 0.0))
            // Scale down paladin's model because it is too big. 
            .set_scale(Vector3::new(0.02, 0.02, 0.02));
        
        Self {
            model,

            // As a final stage create camera controller.
            camera_controller: CameraController::new(&amp;mut scene.graph, resource_manager).await,
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Let's disassemble this heap of code line by line. At first, we're creating pivot for our character, we'll use it as a
&quot;mounting point&quot; for character's 3D model, also it will have a physical body, but that will be added later in this
tutorial. Next, we're loading paladin 3D model and creating its instance in the scene, we need only geometry without
animations, so we use <code>instantiate_geometry</code> here, animations will be added later in this tutorial. Next we scale the
model a bit, because it is too big. Also, we're moving the model a bit down because its center is at paladin's feet so
when we're attaching the model to the pivot, it will &quot;stay&quot; on the pivot. We want it to stay on ground, so we're moving
it down by height of the model. Finally, we're attaching the model to the pivot, forcing the engine to move
the model together with pivot. In the end we're creating camera controller, it needs its own module, so add <code>camera.rs</code>
module under <code>src/player</code> with following content:</p>
<pre><pre class="playground"><code class="language-rust no_run edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span>// Import everything we need for the tutorial.
use fyrox::{
    core::{
        algebra::{UnitQuaternion, Vector3},
        pool::Handle,
    },
    asset::manager::ResourceManager,
    event::DeviceEvent,
    resource::texture::{Texture, TextureWrapMode},
    scene::{
        base::BaseBuilder,
        camera::{CameraBuilder, SkyBox, SkyBoxBuilder},
        graph::Graph,
        node::Node,
        transform::TransformBuilder,
        pivot::PivotBuilder
    },
};

async fn create_skybox(resource_manager: ResourceManager) -&gt; SkyBox {
    // Load skybox textures in parallel.
    let (front, back, left, right, top, bottom) = fyrox::core::futures::join!(
        resource_manager.request::&lt;Texture, _&gt;(&quot;data/textures/skybox/front.jpg&quot;),
        resource_manager.request::&lt;Texture, _&gt;(&quot;data/textures/skybox/back.jpg&quot;),
        resource_manager.request::&lt;Texture, _&gt;(&quot;data/textures/skybox/left.jpg&quot;),
        resource_manager.request::&lt;Texture, _&gt;(&quot;data/textures/skybox/right.jpg&quot;),
        resource_manager.request::&lt;Texture, _&gt;(&quot;data/textures/skybox/up.jpg&quot;),
        resource_manager.request::&lt;Texture, _&gt;(&quot;data/textures/skybox/down.jpg&quot;)
    );

    // Unwrap everything.
    let skybox = SkyBoxBuilder {
        front: Some(front.unwrap()),
        back: Some(back.unwrap()),
        left: Some(left.unwrap()),
        right: Some(right.unwrap()),
        top: Some(top.unwrap()),
        bottom: Some(bottom.unwrap()),
    }
        .build()
        .unwrap();

    // Set S and T coordinate wrap mode, ClampToEdge will remove any possible seams on edges
    // of the skybox.
    let cubemap = skybox.cubemap();
    let mut data = cubemap.as_ref().unwrap().data_ref();
    data.set_s_wrap_mode(TextureWrapMode::ClampToEdge);
    data.set_t_wrap_mode(TextureWrapMode::ClampToEdge);

    skybox
}

pub struct CameraController {
    pivot: Handle&lt;Node&gt;,
    hinge: Handle&lt;Node&gt;,
    camera: Handle&lt;Node&gt;,
}

impl CameraController {
    pub async fn new(graph: &amp;mut Graph, resource_manager: ResourceManager) -&gt; Self {
        let camera;
        let hinge;
        let pivot = PivotBuilder::new(BaseBuilder::new()
            .with_children(&amp;[{
                hinge = PivotBuilder::new(BaseBuilder::new()
                    .with_local_transform(
                        TransformBuilder::new()
                            .with_local_position(Vector3::new(0.0, 0.55, 0.0))
                            .build(),
                    )
                    .with_children(&amp;[{
                        camera = CameraBuilder::new(
                            BaseBuilder::new().with_local_transform(
                                TransformBuilder::new()
                                    .with_local_position(Vector3::new(0.0, 0.0, -2.0))
                                    .build(),
                            ),
                        )
                        .with_z_far(48.0)
                        .with_skybox(create_skybox(resource_manager).await)
                        .build(graph);
                        camera
                    }]))
                    .build(graph);
                hinge
            }]))
            .build(graph);

        Self {
            pivot,
            hinge,
            camera,
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>To understand what this code does let's look closely at this picture:</p>
<p><img src="fyrox/tutorials/rpg/tutorial-1/./camera-layout.png" alt="Camera Layout" /></p>
<p>The pivot is marked yellow here, the hinge - green, and finally the camera is just a trapeze. Lines with arrows shows
how the nodes linked together. As you can see we're attaching the hinge to the pivot and move it up slightly (usually to the
height of the character). Next we're attaching the camera to the hinge and move it back so in default position it will
be behind the character. To understand why we need such layout, let's find out how we need to move and rotate the
camera. We need to rotate the camera around imaginary axis that goes through hinge (&quot;in&quot; the screen on the picture) -
in this layout the camera will always look at character's head and rotate around <strong>local</strong> hinge's X axis. So to do that
we need to rotate the hinge around X axis, not the camera. Here's the picture to help your understanding this better.</p>
<p><img src="fyrox/tutorials/rpg/tutorial-1/./camera-layout-rotated.png" alt="Camera Layout" /></p>
<p>That was just one of the axes, now we need to understand how to rotate the camera around Y axis, but preserving the
rotation around X axis. This is very simple, we have the pivot for that. Remember that each of the nodes (pivot, hinge, camera)
are linked together, so if we'll rotate the pivot around Y axis the hinge will rotate too as well as the camera. Fow
now our camera controller does not have an ability to rotate, we'll add this later in the tutorial.</p>
<p>Now let's load a level where our character will &quot;live&quot;, add <code>level.rs</code> with following content:</p>
<pre><pre class="playground"><code class="language-rust no_run edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span>use fyrox::{
    core::pool::Handle,
    asset::manager::{ResourceManager}, resource::model::{Model, ModelResourceExtension},
    scene::{node::Node, Scene},
};

pub struct Level {
    root: Handle&lt;Node&gt;,
}

impl Level {
    pub async fn new(resource_manager: ResourceManager, scene: &amp;mut Scene) -&gt; Self {
        let root = resource_manager
            .request::&lt;Model, _&gt;(&quot;data/levels/level.rgs&quot;)
            .await
            .unwrap()
            .instantiate(scene);

        Self { root }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This small piece of code just loads the scene I made for this tutorial. It has a terrain and some decorations, including
houses, trees, bushes, barrels, etc. The scene was made in the Fyroxed and can be freely edited without any
problems. Just open the scene and modify it as you need.</p>
<p>Now we need to &quot;glue&quot; all the pieces (the player, and the level) together, let's go back to <code>main.rs</code> and change it to
the following code:</p>
<pre><pre class="playground"><code class="language-rust no_run edition2018"><span class="boring">extern crate fyrox;
</span><span class="boring">#[cfg(test)]
</span>use crate::{level::Level, player::Player};
use fyrox::{
    core::{color::Color, futures::executor::block_on, pool::Handle},
    engine::{executor::Executor},
    asset::manager::ResourceManager,
    event::{Event, WindowEvent},
    event_loop::ControlFlow,
    plugin::{Plugin, PluginConstructor, PluginContext},
    scene::{Scene},
};
use fyrox::window::WindowAttributes;
use fyrox::engine::GraphicsContextParams;

<span class="boring">#[cfg(test)]
</span>mod level;
<span class="boring">#[cfg(test)]
</span>mod player;

<span class="boring">struct Player;
</span><span class="boring">impl Player {
</span><span class="boring">   async fn new(_: ResourceManager, _: &amp;mut Scene) -&gt; Self { Self }
</span><span class="boring">}
</span>
<span class="boring">struct Level;
</span><span class="boring">impl Level {
</span><span class="boring">   async fn new(_: ResourceManager, _: &amp;mut Scene) -&gt; Self { Self }
</span><span class="boring">}
</span>
struct Game {
    scene: Handle&lt;Scene&gt;,
    level: Level,
    player: Player,
}

struct GameConstructor;

impl PluginConstructor for GameConstructor {
    fn create_instance(&amp;self, _: Handle&lt;Scene&gt;, context: PluginContext) -&gt; Box&lt;dyn Plugin&gt; {
        Box::new(Game::new(context))
    }
}

impl Game {
    fn new(context: PluginContext) -&gt; Self {
        let mut scene = Scene::new();

        scene.ambient_lighting_color = Color::opaque(150, 150, 150);

        let player = block_on(Player::new(context.resource_manager.clone(), &amp;mut scene));

        Self {
            player,
            level: block_on(Level::new(context.resource_manager.clone(), &amp;mut scene)),
            scene: context.scenes.add(scene),
        }
    }
}

impl Plugin for Game {
    fn update(&amp;mut self, context: &amp;mut PluginContext, _: &amp;mut ControlFlow) {

    }

    fn on_os_event(
        &amp;mut self,
        event: &amp;Event&lt;()&gt;,
        _context: PluginContext,
        _control_flow: &amp;mut ControlFlow,
    ) {
       
    }
}

fn main() {
    let mut executor = Executor::from_params(
        Default::default(),
        GraphicsContextParams {
            window_attributes: WindowAttributes {
                title: &quot;RPG&quot;.to_string(),
                ..Default::default()
            },
            vsync: true,
        },
    );
    executor.add_plugin_constructor(GameConstructor);
    executor.run();
}
</code></pre></pre>
<p>As you can see, everything is pretty straightforward: at first we're creating a new scene, set its ambient lighting to
&quot;daylight&quot;, next we're creating the player and the level. Finally, we're adding the scene to the engine and now if you
run the game you should see something like this:</p>
<p><img src="fyrox/tutorials/rpg/tutorial-1/./scene.jpg" alt="Scene" /></p>
<p>For now everything is static, let's fix that by adding the ability to move the character and rotate the camera.</p>
<h2 id="camera-movement"><a class="header" href="#camera-movement">Camera movement</a></h2>
<p>Let's start from the camera movement and rotation. We need two new fields in the <code>CameraController</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Stub {
</span>// An angle around local Y axis of the pivot.
yaw: f32,
// An angle around local X axis of the hinge.
pitch: f32,
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>Do not forget to initialize them with zeros:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Self {
    ...,
    yaw: 0.0,
    pitch: 0.0,
}
<span class="boring">}</span></code></pre></pre>
<p>Now we need to handle device events coming from the OS to rotate the camera. Add following method to the <code>impl CameraController</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn handle_device_event(&amp;mut self, device_event: &amp;DeviceEvent) {
    if let DeviceEvent::MouseMotion { delta } = device_event {
        const MOUSE_SENSITIVITY: f32 = 0.015;

        self.yaw -= (delta.0 as f32) * MOUSE_SENSITIVITY;
        self.pitch = (self.pitch + (delta.1 as f32) * MOUSE_SENSITIVITY)
            // Limit vertical angle to [-90; 90] degrees range
            .max(-90.0f32.to_radians())
            .min(90.0f32.to_radians());
    }
}
<span class="boring">}</span></code></pre></pre>
<p>In this method we use only <code>MouseMotion</code> events, because CameraController does not move - it can only rotate. The method
is pretty straightforward. We're changing yaw and pitch using mouse offsets in two axes. X axis changes yaw, Y axis changes
pitch. Pitch should be limited in specific range to prevent camera to rotate 360 degrees around object, we need angle
to be in <code>[-90; 90]</code> range.</p>
<p>Once we've changed yaw and pitch, we need to apply rotations to the hinge and the camera. To do that, we need to add
a new method to the <code>impl CameraController</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn update(&amp;mut self, graph: &amp;mut Graph) {
    // Apply rotation to the pivot.
    graph[self.pivot]
        .local_transform_mut()
        .set_rotation(UnitQuaternion::from_axis_angle(
            &amp;Vector3::y_axis(),
            self.yaw,
        ));

    // Apply rotation to the hinge.
    graph[self.hinge]
        .local_transform_mut()
        .set_rotation(UnitQuaternion::from_axis_angle(
            &amp;Vector3::x_axis(),
            self.pitch,
        ));
}
<span class="boring">}</span></code></pre></pre>
<p>It is a very simple method, it borrows nodes, and applies rotations around specific axes. Now we need to call those two
methods from somewhere. The most suitable place is <code>impl Player</code>, because <code>Player</code> owns an instance of <code>CameraController</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn handle_device_event(&amp;mut self, device_event: &amp;DeviceEvent) {
    self.camera_controller.handle_device_event(device_event)
}

pub fn update(&amp;mut self, scene: &amp;mut Scene) {
    self.camera_controller.update(&amp;mut scene.graph);
}
<span class="boring">}</span></code></pre></pre>
<p>For now both methods are just proxies, but it will be changed pretty soon. Now we need to call the proxies, but from where?
The most suitable place is <code>on_tick</code> and <code>on_device_event</code> of the <code>GameState</code> trait implementation for our <code>Game</code> structure:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn on_tick(&amp;mut self, engine: &amp;mut Engine, dt: f32, _control_flow: &amp;mut ControlFlow) {
    let scene = &amp;mut engine.scenes[self.scene];

    self.player.update(scene);
}

fn on_device_event(
    &amp;mut self,
    _engine: &amp;mut Engine,
    _device_id: DeviceId,
    event: DeviceEvent,
) {
    self.player.handle_device_event(&amp;event);
}
<span class="boring">}</span></code></pre></pre>
<p>Now you can run the game, and the camera should rotate when you're moving your mouse. Now it's the time to add an ability
to walk for our character.</p>
<h2 id="player-locomotion"><a class="header" href="#player-locomotion">Player locomotion</a></h2>
<p>Our player still can't move, in this section we'll fix it. Player's movement for third person camera differs from the
movement of first person. For the third person camera we must move the player either where the camera looks or according
to pressed keys on the keyboard. Let's start by adding input controller, it will hold info about needed movement:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Default)]
struct InputController {
    walk_forward: bool,
    walk_backward: bool,
    walk_left: bool,
    walk_right: bool,
}
<span class="boring">}</span></code></pre></pre>
<p>Add new field to the <code>Player</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>input_controller: InputController,
<span class="boring">}</span></code></pre></pre>
<p>And initialize it with <code>Default::default</code> in the <code>Player::new</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Self {
    ...,
    input_controller: Default::default(),
}
<span class="boring">}</span></code></pre></pre>
<p>Now we need to change the state of the input controller, to do that we'll use keyboard events. Add following method to
the <code>impl Player</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn handle_key_event(&amp;mut self, key: &amp;KeyboardInput) {
    if let Some(key_code) = key.virtual_keycode {
        match key_code {
            VirtualKeyCode::W =&gt; {
                self.input_controller.walk_forward = key.state == ElementState::Pressed
            }
            VirtualKeyCode::S =&gt; {
                self.input_controller.walk_backward = key.state == ElementState::Pressed
            }
            VirtualKeyCode::A =&gt; {
                self.input_controller.walk_left = key.state == ElementState::Pressed
            }
            VirtualKeyCode::D =&gt; {
                self.input_controller.walk_right = key.state == ElementState::Pressed
            }
            _ =&gt; (),
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Now we need to call this method, we'll do it from <code>on_window_event</code> in the <code>GameState</code> trait implementation for our
<code>Game</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn on_window_event(&amp;mut self, _engine: &amp;mut Engine, event: WindowEvent) {
    match event {
        WindowEvent::KeyboardInput { input, .. } =&gt; {
            self.player.handle_key_event(&amp;input);
        }
        _ =&gt; (),
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Ok, now we have input controller functioning. Now we can start adding movement logic to the player. Let's start by adding
a physical body to the player. We'll use a capsule rigid body with locked rotations for that. Add these lines somewhere
in <code>Player::new</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::algebra::Vector3,
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    scene::{
</span><span class="boring">        Scene,
</span><span class="boring">        base::BaseBuilder,
</span><span class="boring">        collider::{ColliderBuilder, ColliderShape},
</span><span class="boring">        graph::physics::CoefficientCombineRule,
</span><span class="boring">        rigidbody::RigidBodyBuilder,
</span><span class="boring">        transform::TransformBuilder,
</span><span class="boring">    },
</span><span class="boring">};
</span><span class="boring">fn f(scene: &amp;mut Scene) {
</span><span class="boring">let model = Handle::NONE;
</span>let collider;
let body = RigidBodyBuilder::new(
    BaseBuilder::new()
        .with_local_transform(
            TransformBuilder::new()
                .with_local_position(Vector3::new(0.0, 2.0, 0.0))
                .build(),
        )
        .with_children(&amp;[
            {
                // Attach the model to the pivot. This will force model to move together with the pivot.
                model
            },
            {
                // Create capsule collider with friction disabled. We need to disable friction because linear
                // velocity will be set manually, but the physics engine will reduce it using friction so it
                // won't let us to set linear velocity precisely.
                collider = ColliderBuilder::new(BaseBuilder::new())
                    .with_shape(ColliderShape::capsule_y(0.55, 0.15))
                    .with_friction_combine_rule(CoefficientCombineRule::Min)
                    .with_friction(0.0)
                    .build(&amp;mut scene.graph);
                collider
            },
        ]),
)
.with_locked_rotations(true)
.with_can_sleep(false)
.build(&amp;mut scene.graph);
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>Now, once our character has physical body, we can move it. Add these lines to the end of <code>Player::update</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let body = scene.graph[self.body].as_rigid_body_mut();

let look_vector = body
    .look_vector()
    .try_normalize(f32::EPSILON)
    .unwrap_or(Vector3::z());

let side_vector = body
    .side_vector()
    .try_normalize(f32::EPSILON)
    .unwrap_or(Vector3::x());

let position = **body.local_transform().position();

let mut velocity = Vector3::default();

if self.input_controller.walk_right {
    velocity -= side_vector;
}
if self.input_controller.walk_left {
    velocity += side_vector;
}
if self.input_controller.walk_forward {
    velocity += look_vector;
}
if self.input_controller.walk_backward {
    velocity -= look_vector;
}

let speed = 1.35 * dt;
let velocity = velocity
    .try_normalize(f32::EPSILON)
    .and_then(|v| Some(v.scale(speed)))
    .unwrap_or(Vector3::default());

// Apply linear velocity.
body.set_lin_vel(Vector3::new(
    velocity.x / dt,
    body.lin_vel().y,
    velocity.z / dt,
));

let is_moving = velocity.norm_squared() &gt; 0.0;
if is_moving {
    // Since we have free camera while not moving, we have to sync rotation of pivot
    // with rotation of camera so character will start moving in look direction.
    body.local_transform_mut()
        .set_rotation(UnitQuaternion::from_axis_angle(
            &amp;Vector3::y_axis(),
            self.camera_controller.yaw,
        ));

    // Apply additional rotation to model - it will turn in front of walking direction.
    let angle: f32 = if self.input_controller.walk_left {
        if self.input_controller.walk_forward {
            45.0
        } else if self.input_controller.walk_backward {
            135.0
        } else {
            90.0
        }
    } else if self.input_controller.walk_right {
        if self.input_controller.walk_forward {
            -45.0
        } else if self.input_controller.walk_backward {
            -135.0
        } else {
            -90.0
        }
    } else if self.input_controller.walk_backward {
        180.0
    } else {
        0.0
    };

    scene.graph[self.model].local_transform_mut().set_rotation(
        UnitQuaternion::from_axis_angle(&amp;Vector3::y_axis(), angle.to_radians()),
    );
}

// Sync camera controller position with player's position.
scene.graph[self.camera_controller.pivot]
    .local_transform_mut()
    .set_position(position + velocity);
<span class="boring">}</span></code></pre></pre>
<p>There is lots of code, let's thoroughly go through. At first, we're getting two vectors from the pivot: X and Z axes of
the global transform of the pivot. We'll use them to move the character. Next we're using the state of the input
controller to form a new velocity vector. Then we're normalizing velocity vector and multiply it with desired speed of
movement. Normalization is needed to make the vector unit length to prevent speed variations in various directions. Next
we're applying the velocity to the rigid body, also we're locking any angular movement to prevent player's capsule
from tilting.</p>
<p>If the player is not moving, we're not syncing its rotation with camera's rotation - this allows us to look at the
character from any side while not moving. However, if the player is moving, we must sync its rotation with the rotation
of the camera controller. If we'd do this straightforward (by just syncing rotations) it would look very unnatural,
especially in case of side movements. To fix this we have this large chain of <code>if..else</code> that selects appropriate
additional rotation for the player's model. This rotation allows us, for example, look forward and move the character
backwards.</p>
<p>As the final step we're syncing position of the camera controller with the position of the pivot. Now if you run the game
you'll be able to walk around using <code>[W][S][A][D]</code> keys. However, it looks very ugly - the character's model is in T-pose,
let's fix this.</p>
<h2 id="animations-1"><a class="header" href="#animations-1">Animations</a></h2>
<p>At this point our character can move, and we can rotate the camera around it, but the character is still in T-pose and
does not have any animation. In this section we'll animate it. To keep this tutorial at reasonable length, we'll
add just an idle and walk animations and smooth transitions between them. Add following code at the end of <code>player.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    animation::{
</span><span class="boring">        machine::{Machine, MachineLayer, Parameter, PoseNode, State, Transition},
</span><span class="boring">        Animation,
</span><span class="boring">    },
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    asset::manager::ResourceManager,
</span><span class="boring">    resource::model::{Model, ModelResource, ModelResourceExtension},
</span><span class="boring">    scene::{node::Node, animation::AnimationPlayer, Scene},
</span><span class="boring">};
</span>
// Simple helper method to create a state supplied with PlayAnimation node.
fn create_play_animation_state(
    animation_resource: ModelResource,
    name: &amp;str,
    layer: &amp;mut MachineLayer,
    scene: &amp;mut Scene,
    model: Handle&lt;Node&gt;,
) -&gt; (Handle&lt;Animation&gt;, Handle&lt;State&gt;) {
    // Animations retargetting just makes an instance of animation and binds it to
    // given model using names of bones.
    let animation = *animation_resource
        .retarget_animations(model, &amp;mut scene.graph)
        .get(0)
        .unwrap();
    // Create new PlayAnimation node and add it to machine.
    let node = layer.add_node(PoseNode::make_play_animation(animation));
    // Make a state using the node we've made.
    let state = layer.add_state(State::new(name, node));
    (animation, state)
}

pub struct AnimationMachineInput {
    // Whether a bot is walking or not.
    pub walk: bool,
}

pub struct AnimationMachine {
    machine: Machine,
    animation_player: Handle&lt;Node&gt;,
}

impl AnimationMachine {
    // Names of parameters that will be used for transition rules in machine.
    const IDLE_TO_WALK: &amp;'static str = &quot;IdleToWalk&quot;;
    const WALK_TO_IDLE: &amp;'static str = &quot;WalkToIdle&quot;;

    pub async fn new(
        scene: &amp;mut Scene,
        model: Handle&lt;Node&gt;,
        resource_manager: ResourceManager,
    ) -&gt; Self {
        let animation_player = scene.graph.find(model, &amp;mut |n| {
            n.query_component_ref::&lt;AnimationPlayer&gt;().is_some()
        }).unwrap().0;

        let mut machine = Machine::new();

        let root = machine.layers_mut().first_mut().unwrap();

        // Load animations in parallel.
        let (walk_animation_resource, idle_animation_resource) = fyrox::core::futures::join!(
            resource_manager.request::&lt;Model, _&gt;(&quot;data/models/paladin/walk.fbx&quot;),
            resource_manager.request::&lt;Model, _&gt;(&quot;data/models/paladin/idle.fbx&quot;),
        );

        // Now create two states with different animations.
        let (_, idle_state) = create_play_animation_state(
            idle_animation_resource.unwrap(),
            &quot;Idle&quot;,
            root,
            scene,
            model,
        );

        let (walk_animation, walk_state) = create_play_animation_state(
            walk_animation_resource.unwrap(),
            &quot;Walk&quot;,
            root,
            scene,
            model,
        );

        // Next, define transitions between states.
        root.add_transition(Transition::new(
            // A name for debugging.
            &quot;Idle-&gt;Walk&quot;,
            // Source state.
            idle_state,
            // Target state.
            walk_state,
            // Transition time in seconds.
            0.4,
            // A name of transition rule parameter.
            Self::IDLE_TO_WALK,
        ));
        root.add_transition(Transition::new(
            &quot;Walk-&gt;Idle&quot;,
            walk_state,
            idle_state,
            0.4,
            Self::WALK_TO_IDLE,
        ));

        // Define entry state.
        root.set_entry_state(idle_state);

        Self {
            machine,
            animation_player,
        }
    }

    pub fn update(&amp;mut self, scene: &amp;mut Scene, dt: f32, input: AnimationMachineInput) {
        let animation_player = scene.graph[self.animation_player]
            .query_component_mut::&lt;AnimationPlayer&gt;()
            .unwrap();

        self.machine
            // Set transition parameters.
            .set_parameter(Self::WALK_TO_IDLE, Parameter::Rule(!input.walk))
            .set_parameter(Self::IDLE_TO_WALK, Parameter::Rule(input.walk))
            // Update machine and evaluate final pose.
            .evaluate_pose(animation_player.animations_mut().get_value_mut_silent(), dt)
            // Apply the pose to the graph.
            .apply(&amp;mut scene.graph);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This is a simple animation blending machine, for more info check
<a href="https://fyrox.rs/tutorials/2021/03/11/tutorial3.html#animations">&quot;Animations&quot; section of &quot;Writing a 3D shooter using Fyrox #3&quot;</a>
tutorial, it has detailed explanation how animation blending machines work. In short, here we're loading two animations,
and create two transitions between them and then applying final pose to the character.</p>
<p>Now we need to create an instance of the <code>AnimationMachine</code>, add a field to the <code>Player</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>...,
animation_machine: AnimationMachine,
<span class="boring">}</span></code></pre></pre>
<p>And initialize it in the <code>Player::new</code>, before <code>camera_controller</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>...,
animation_machine: AnimationMachine::new(scene, model, resource_manager.clone()).await,
...
<span class="boring">}</span></code></pre></pre>
<p>The last thing we need to do is to update animation machine each frame, we'll do this in <code>Player::update</code>, at the end
of the method:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>self.animation_machine
        .update(scene, dt, AnimationMachineInput { walk: is_moving });
<span class="boring">}</span></code></pre></pre>
<p>Now if you run the game, you should see the character idling if not moving, and it should play &quot;walking&quot; animation if
moving. That's it for this tutorial, in the next tutorial we'll &quot;teach&quot; the character to use swords.</p>
<h2 id="conclusion-3"><a class="header" href="#conclusion-3">Conclusion</a></h2>
<p>In this tutorial we've learned how create a walking character. Created simple character controller and walked on
the scene. I hope you liked this tutorial, and if so, please consider supporting the project on
<a href="https://patreon.com/mrdimas">Patreon</a> or do a one-time donation via <a href="https://www.buymeacoffee.com/mrDIMAS">BuyMeACoffee</a>.
The source code for this tutorial is available on <a href="https://github.com/FyroxEngine/Fyrox-tutorials">GitHub</a>.</p>
<p>Discussion: <a href="https://www.reddit.com/r/rust/comments/ois776/media_writing_a_roleplaying_game_using_rg3d_game/">Reddit</a>,
<a href="https://discord.gg/xENF5Uh">Discord</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="2d-platformer-tutorial"><a class="header" href="#2d-platformer-tutorial">2D Platformer Tutorial</a></h1>
<h2 id="table-of-contents-4"><a class="header" href="#table-of-contents-4">Table of Contents</a></h2>
<ul>
<li><a href="fyrox/tutorials/platformer/part1.html#2d-platformer-tutorial">2D Platformer Tutorial</a>
<ul>
<li><a href="fyrox/tutorials/platformer/part1.html#table-of-contents">Table of Contents</a></li>
<li><a href="fyrox/tutorials/platformer/part1.html#introduction">Introduction</a></li>
<li><a href="fyrox/tutorials/platformer/part1.html#project">Project</a></li>
<li><a href="fyrox/tutorials/platformer/part1.html#using-the-editor">Using the Editor</a></li>
<li><a href="fyrox/tutorials/platformer/part1.html#scripts---player">Scripts - Player</a></li>
<li><a href="fyrox/tutorials/platformer/part1.html#animation">Animation</a></li>
<li><a href="fyrox/tutorials/platformer/part1.html#final-steps">Final Steps</a></li>
<li><a href="fyrox/tutorials/platformer/part1.html#standalone-game">Standalone Game</a></li>
<li><a href="fyrox/tutorials/platformer/part1.html#conclusion">Conclusion</a></li>
</ul>
</li>
</ul>
<h2 id="introduction-5"><a class="header" href="#introduction-5">Introduction</a></h2>
<p>In this tutorial, we'll make a 2D platformer using the new plugin and scripting system that has become available in Fyrox 0.25 and
improved in Fyrox 0.26. Here's what you'll get after finishing the tutorial:</p>
<iframe width="560" height="315" src="https://youtube.com/embed/EcvtwEkBxNU" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<p>You can find the source code of the tutorial <a href="https://github.com/FyroxEngine/Fyrox-tutorials/tree/main/platformer">here</a>, you can
test it yourself by cloning the repository and <code>cargo run --package editor --release</code> in the <code>platformer</code> directory.</p>
<h2 id="project"><a class="header" href="#project">Project</a></h2>
<p>Let's start by making a new project using the special tiny tool - <code>fyrox-template</code> - it allows you to generate all boilerplate
parts in a single call. Install it using the following command:</p>
<pre><code class="language-shell">cargo install fyrox-template
</code></pre>
<p>Navigate to a folder where you want the project to be created and do the following command:</p>
<pre><code class="language-shell">fyrox-template init --name platformer --style 2d
</code></pre>
<p>The tool accepts two arguments - project name and a style, we're interested in 2D game so the style is set to 2D. After
the project is generated, you should memorize two commands:</p>
<ul>
<li><code>cargo run --package editor --release</code> - launches the editor with your game attached, the editor allows you to run your game
inside it and edit game entities. It is intended to be used only for development.</li>
<li><code>cargo run --package executor --release</code> - creates and runs the production binary of your game that can be shipped (for
example - to a store).</li>
</ul>
<p>Navigate to the <code>platformer</code> directory and run <code>cargo run --package editor --release</code>, after some time you should see the editor:</p>
<p><img src="fyrox/tutorials/platformer/editor.png" alt="editor" /></p>
<p>Great! Now we can start making our game. Go to <code>game/src/lib.rs</code> - it is where your game logic is located, as you can see
the <code>fyrox-template</code> generate quite some code for you. There are tiny comments about which place is for what. For more info
about each method, please refer <a href="https://docs.rs/fyrox/latest/fyrox/plugin/trait.Plugin.html">to the docs</a>.</p>
<h2 id="using-the-editor-1"><a class="header" href="#using-the-editor-1">Using the Editor</a></h2>
<p>For now, we don't even need to write a single line of code, we can create a scene entirely in the editor. This section will guide
you through the process of scene creation, as a final result we'll get something similar to this:</p>
<p><img src="fyrox/tutorials/platformer/editor_with_scene.png" alt="editor with scene" /></p>
<p>At first, we need some assets, I prepared all required (and some more) in a separate zip archive, so you don't need to search
assets all over the internet. Download assets from <a href="fyrox/tutorials/platformer/assets.zip">here</a> and unpack them in a <code>data</code> folder in the root folder of
your project.</p>
<p>Let's start filling the scene. Run the editor and remove all content from the generated scene. Since we're making a 2D game, switch the editor's
camera mode to <code>Orthographic</code> at the right top corner of the scene preview window. Now we need to populate the scene with some objects,
we'll start by adding a simple ground block. Right-click on <code>__ROOT__</code> of the scene in <code>World Viewer</code> and select
<code>Add Child -&gt; Physics2D -&gt; Rigid Body</code>. This will create a rigid body for the ground block, select the rigid body, and
set <code>Body Type</code> to <code>Static</code> in <code>Inspector</code>, by doing this we're telling the physics engine that our ground block should not move
and be rock-solid. Every rigid body requires a collider, otherwise, the physics engine will not know how to handle collisions, 
right-click on the rigid body in <code>Inspector</code> and click <code>Add Child -&gt; Physics2D -&gt; Collider</code>. We've just added a new collider to the rigid
body, by default it has a <code>Cuboid</code> shape with a <code>1.0</code> meter in height and width. Finally, we need to add some graphics to the rigid body,
right-click on the rigid body and click <code>Add Child -&gt; 2D -&gt; Rectangle</code>. This adds a simple 2D sprite, select it and set a texture
to it by drag'n'dropping it from the asset browser on the white field of the <code>Texture</code> field in the <code>Inspector</code>. For my scene, I'm gonna
be using three sprites.</p>
<ul>
<li><code>data/tiles/13.png</code> - left ground block</li>
<li><code>data/tiles/14.png</code> - center ground block</li>
<li><code>data/tiles/15.png</code> - right ground block</li>
</ul>
<p>You can use any other textures and build your level as you like. After doing all these steps you should get something like this:</p>
<p><img src="fyrox/tutorials/platformer/editor_step1.png" alt="editor_step1" /></p>
<p>Clone the block by selecting its rigid body and pressing <code>Ctrl+C</code> followed by <code>Ctrl+V</code>, navigate to sprite in the copy and change its
texture to either the left or right end of the block. Use <code>Move Tool</code> to move the block somewhere you like (you can also use grid-snapping
by going to <code>File -&gt; Setting</code> and setting <code>Snap To Grid</code> for <code>Move Interaction Mode</code>). Do this one more time for the opposite end and you
should get something like this:</p>
<p><img src="fyrox/tutorials/platformer/editor_step2.png" alt="editor_step2" /></p>
<p>Repeat these steps if you like, to add more platforms. You can also add some background objects, by creating a new sprite
(right click <code>__ROOT__</code> and click <code>Add Child -&gt; 2D -&gt; Rectangle</code>) and assigning a texture to it:</p>
<p><img src="fyrox/tutorials/platformer/editor_step3.png" alt="editor_step3" /></p>
<p>As the last step of world editing, let's add some dynamic objects, like boxes. Pick some random ground block, select its rigid body, and
clone it. Switch body type of the copy to <code>Dynamic</code>. Now change its sprite texture to a box (drag'n'drop <code>data/objects/Crate.png</code> to
<code>Texture</code> field) and clone the box a few times, you should get something like this:</p>
<p><img src="fyrox/tutorials/platformer/editor_step4.png" alt="editor_step4" /></p>
<p>Now for the player. As always, let's start by creating a new rigid body, adding a 2D collider to it, and setting its shape to capsule with the following
parameters - <code>Begin = 0.0, 0.0</code> and <code>End = 0.0, 0.3</code>. Add a 2D sprite (rectangle) to the rigid body and set its texture to
<code>data/characters/adventurer/adventurer-Sheet.png</code>. Set its uv rect to <code>(0.0, 0.0, 0.143, 0.091)</code> to see only one frame.
We also need a camera, otherwise, we won't see anything. Add it as a child to a player's rigid body. By default, our 
camera will have no background, there'll be a black &quot;void&quot;, this is not great and let's fix that. Select the camera
and set the <code>Skybox</code> property to <code>Some</code>. Now go to asset browser and find <code>data/background/BG.png</code>, drag'n'drop it to 
the <code>Front</code> field of the <code>Skybox</code> property. Don't forget to adjust the far plane distance to something like <code>20.0</code>, 
otherwise, you'll see just a portion of the background image. If everything is done correctly, you should get something like this:</p>
<p><img src="fyrox/tutorials/platformer/editor_step5.png" alt="editor_step5" /></p>
<p>Save your scene by goint to <code>File -&gt; Save Scene</code>. Now we can run the game using the <code>Play/Stop</code> button at the top of the 
scene previewer. You should see pretty much the same as in the scene preview, except
for service graphics, such as rigid body shapes, node bounds, and so on. Now we can start writing scripts.</p>
<p>As the last preparation step, let's import all entities at the beginning, so you don't need to find them manually, add the following code
at the beginning of the <code>game/src/lib.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span>use fyrox::plugin::PluginConstructor;
use fyrox::{
    core::{
        algebra::{Vector2, Vector3},
        futures::executor::block_on,
        pool::Handle,
        reflect::prelude::*,
        uuid::{uuid, Uuid},
        visitor::prelude::*, TypeUuidProvider
    },
    asset::manager::ResourceManager,
    event::{ElementState, Event, VirtualKeyCode, WindowEvent},
    impl_component_provider,
    plugin::{Plugin, PluginContext, PluginRegistrationContext},
    resource::texture::Texture,
    scene::{
        dim2::{rectangle::Rectangle, rigidbody::RigidBody},
        node::{Node},
        Scene, SceneLoader,
    },
    script::{ScriptContext, ScriptTrait},
};
<span class="boring">}</span></code></pre></pre>
<h2 id="scripts---player"><a class="header" href="#scripts---player">Scripts - Player</a></h2>
<p>Our scene has pretty much everything we need to start adding scripts, we'll start from the <code>Player</code> script and make our character
move. Navigate to <code>game/src/lib.rs</code> and at the end of the file add the following code snippet:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::{
</span><span class="boring">        uuid::{uuid, Uuid},
</span><span class="boring">        reflect::prelude::*,
</span><span class="boring">        visitor::prelude::*, TypeUuidProvider
</span><span class="boring">    },
</span><span class="boring">    event::Event,
</span><span class="boring">    impl_component_provider,
</span><span class="boring">    gui::inspector::PropertyChanged,
</span><span class="boring">    script::{ScriptContext, ScriptTrait},
</span><span class="boring">};
</span>#[derive(Visit, Reflect, Debug, Clone, Default)]
struct Player;

impl_component_provider!(Player,);

impl TypeUuidProvider for Player {
    // Returns unique script id for serialization needs.
    fn type_uuid() -&gt; Uuid {
        uuid!(&quot;c5671d19-9f1a-4286-8486-add4ebaadaec&quot;)
    }
}

impl ScriptTrait for Player {
    // Called once at initialization.
    fn on_init(&amp;mut self, context: &amp;mut ScriptContext) {}
    
    // Put start logic - it is called when every other script is already initialized.
    fn on_start(&amp;mut self, context: &amp;mut ScriptContext) { }

    // Called whenever there is an event from OS (mouse click, keypress, etc.)
    fn on_os_event(&amp;mut self, event: &amp;Event&lt;()&gt;, context: &amp;mut ScriptContext) {}

    // Called every frame at fixed rate of 60 FPS.
    fn on_update(&amp;mut self, context: &amp;mut ScriptContext) {}

    // Returns unique script ID for serialization needs.
    fn id(&amp;self) -&gt; Uuid {
        Self::type_uuid()
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This is a typical &quot;skeleton&quot; of any script, for now, its methods are pretty much empty, we'll fill it with actual code very soon.
Let's go over the most important parts. The snippet starts from the <code>Player</code> structure definition which has <code>#[derive(Visit, Inspect, Debug, Clone, Default)]</code>
attributes:</p>
<ul>
<li><code>Visit</code> - implements serialization/deserialization functionality, it is used by the editor to save your object to a scene file.</li>
<li><code>Inspect</code> - generates metadata for the fields of your type - in other words, it allows the editor to &quot;see&quot; what's inside
your structure and show additional information attached to the fields via proc-macro attributes.</li>
<li><code>Reflect</code> - implements compile-time reflection that allows the editor to mutate your objects.</li>
<li><code>Debug</code> - provides debugging functionality, it is mostly for the editor to let it print stuff into the console.</li>
<li><code>Clone</code> - makes your structure clone-able, why do we need this? We can clone objects, and we also want the script instance to be
copied.</li>
<li><code>Default</code> implementation is very important - the scripting system uses it to create your scripts in the default state.
This is necessary to set some data to it and so on. If it's a special case, you can always implement your own <code>Default</code>'s
implementation if it's necessary for your script.</li>
<li><code>TypeUuidProvider</code> is used to attach some unique id for your type, every script *<em>must</em> have a unique ID, otherwise, the engine will
not be able to save and load your scripts. To generate a new UUID, use <a href="https://www.uuidgenerator.net/">Online UUID Generator</a> or
any other tool that can generate UUIDs.</li>
</ul>
<p>Finally, we implement <code>ScriptTrait</code> for the <code>Player</code>. It has a bunch of methods, their names speak for themselves. Learn more about
every method in <a href="https://docs.rs/fyrox/latest/fyrox/script/trait.ScriptTrait.html">documentation</a></p>
<p>Before we can use the script in the editor, we must tell the engine that our script exists - we must register it. Remember that
<code>register</code> method in the <code>PluginConstructor</code> trait implementation? It is exactly for script registration, replace its implementation with the following
code snippet:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn register(&amp;mut self, context: PluginRegistrationContext) {
    let script_constructors = &amp;context.serialization_context.script_constructors;
    script_constructors.add::&lt;Player&gt;(&quot;Player&quot;);
}
<span class="boring">}</span></code></pre></pre>
<p>Now the engine knows about our script and will be able to use it. It is pretty much useless in the current state, but we can already
assign it to the player. Select the player's rigid body node and find <code>Script</code> in the <code>Inspector</code>, select <code>Player</code> from the respective
drop-down list and that's pretty much it - now the script is assigned:</p>
<p><img src="fyrox/tutorials/platformer/script_selection.png" alt="script_selection" /></p>
<p>Let's learn how to edit script properties from the editor. In the next section, we'll be adding keyframe animation for your character,
it is a perfect opportunity to learn how the engine and the editor operate with user-defined properties in scripts. To animate the player
we need to get its sprite first. Let's start by adding the required field in the <code>Player</code> structure:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Visit, Reflect, Inspect, Debug, Clone, Default)]
struct Player {
    sprite: Handle&lt;Node&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>After adding this, the editor will be able to see the field and give you the ability to edit it in the Inspector. 
To assign the correct handle of the sprite to the respective field in script properties, hold <code>Alt</code> and start dragging
the sprite node from the world viewer to the respective field in the player script. Release the mouse button and if 
everything is ok, the field should &quot;say&quot; something different than &quot;Unassigned&quot;.</p>
<p>Alright, at this point we know how to work with script properties, now we can start adding basic movement for the player.
Go to the <code>Player</code> structure and add the following fields:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Foo {
</span>move_left: bool,
move_right: bool,
jump: bool,
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>These fields will store the state of keyboard keys responsible for player movement. Now for <code>on_os_event</code>, add the following code there:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let Event::WindowEvent { event, .. } = event {
    if let WindowEvent::KeyboardInput { input, .. } = event {
        if let Some(keycode) = input.virtual_keycode {
            let is_pressed = input.state == ElementState::Pressed;

            match keycode {
                VirtualKeyCode::A =&gt; self.move_left = is_pressed,
                VirtualKeyCode::D =&gt; self.move_right = is_pressed,
                VirtualKeyCode::Space =&gt; self.jump = is_pressed,
                _ =&gt; (),
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The code responds to OS events and modifies internal movement flags accordingly. Now we need to use the flags somehow, it's time for
<code>on_update</code>. The method is called each frame and allows you to put game logic there:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{core::algebra::Vector2, scene::dim2::rigidbody::RigidBody, script::ScriptContext};
</span><span class="boring">
</span><span class="boring">struct Foo {
</span><span class="boring">    move_left: bool,
</span><span class="boring">    move_right: bool,
</span><span class="boring">    jump: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Foo {
</span>// Called every frame at fixed rate of 60 FPS.
fn on_update(&amp;mut self, context: &amp;mut ScriptContext) {
    // The script can be assigned to any scene node, but we assert that it will work only with
    // 2d rigid body nodes.
    if let Some(rigid_body) = context.scene.graph[context.handle].cast_mut::&lt;RigidBody&gt;() {
        let x_speed = match (self.move_left, self.move_right) {
            (true, false) =&gt; 3.0,
            (false, true) =&gt; -3.0,
            _ =&gt; 0.0,
        };

        if self.jump {
            rigid_body.set_lin_vel(Vector2::new(x_speed, 4.0));
        } else {
            rigid_body.set_lin_vel(Vector2::new(x_speed, rigid_body.lin_vel().y));
        }
    }
}
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>Finally, some interesting code. At first, we check if the node to which the script is assigned is a 2d rigid body, next
we're checking movement flags and form horizontal speed, and applying velocity to the body. Velocity is applied in two ways: if
the jump button was pressed - apply horizontal velocity and some vertical velocity for jumping. If the jump button wasn't pressed -
just change horizontal velocity - this will allow the player to free fall.</p>
<p>Run the editor and enter play mode, press <code>[A][D][Space]</code> buttons to check if everything works correctly - the player should move
horizontally and be able to jump. You can jump to the boxes on the right and push them off the ledge.</p>
<p>The movement is working, but the player does not change orientation, if we'll go to the left - it looks ok (despite the lack of animation),
but if we'll move to the right - it looks like the player moves backward. Let's fix that by changing the horizontal scaling of the player's
sprite. Add the following code at the end of the <code>if let ...</code> block of the code above:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// It is always a good practice to check whether the handles are valid, at this point we don't know
// for sure what's the value of the `sprite` field. It can be unassigned and the following code won't
// execute. A simple `context.scene.graph[self.sprite]` would just panicked in this case.
if let Some(sprite) = context.scene.graph.try_get_mut(self.sprite) {
    // We want to change player orientation only if he's moving.
    if x_speed != 0.0 {
        let local_transform = sprite.local_transform_mut();
        let current_scale = **local_transform.scale();

        local_transform.set_scale(Vector3::new(
            // Just change X scaling to mirror player's sprite.
            current_scale.x.copysign(-x_speed),
            current_scale.y,
            current_scale.z,
        ));
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The comments should clarify what's going on here, but in short, we're changing the horizontal scaling of the player's sprite if the player is
moving. The line <code>current_scale.x.copysign(-x_speed)</code> could be confusing, what it does? It replaces the sign of current horizontal scaling
using the opposite sign of <code>x_speed</code>.</p>
<p>Now if you run the game, the player will &quot;look&quot; in correct direction depending on the velocity vector.</p>
<h2 id="animation-2"><a class="header" href="#animation-2">Animation</a></h2>
<p>Since we're making a 2D game, we'll be using simple animations based on the continuous change of keyframes. In other words, we'll be changing
the texture of the player's body sprite. Luckily for us, the engine has built-in sprite sheet animations. Just add the 
following fields to the <code>Player</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::animation::spritesheet::SpriteSheetAnimation;
</span><span class="boring">struct Animation;
</span><span class="boring">struct Player {
</span>animations: Vec&lt;SpriteSheetAnimation&gt;,
current_animation: u32,
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>Currently, we just pass default values.</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>..Default::default()
<span class="boring">}</span></code></pre></pre>
<p>The Player will use multiple animations in future tutorials, but for now, it will use only two - idle and run.
Now we need to somehow switch animations. Go to <code>on_update</code> in <code>Player</code> and add the following lines after
the <code>x_speed</code> declaration:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Player {
</span><span class="boring">    current_animation: usize,
</span><span class="boring">}
</span><span class="boring">impl Player {
</span><span class="boring">    pub fn on_update(&amp;mut self) {
</span><span class="boring">      let x_speed = 0.0;
</span>if x_speed != 0.0 {
    self.current_animation = 1;
} else {
    self.current_animation = 0;
}
<span class="boring">   }
</span><span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>Here we assume that the run animation will be at index <code>1</code> and the idle animation at index <code>0</code>. We also need to
apply the texture from the current animation to the player's sprite, and add the following lines at the end of <code>on_update</code></p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let Some(current_animation) = self.animations.get_mut(self.current_animation as usize) {
    current_animation.update(context.dt);

    if let Some(sprite) = context
        .scene
        .graph
        .try_get_mut(self.sprite)
        .and_then(|n| n.cast_mut::&lt;Rectangle&gt;())
    {
        // Set new frame to the sprite.
        sprite.set_uv_rect(
            current_animation
                .current_frame_uv_rect()
                .cloned()
                .unwrap_or_default()
                .0,
        );
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The code is pretty straightforward - we start by trying to get a reference to the current animation by its index,
and if we're succeeded, we update it. At the next step, we're getting sprite and assigning a current frame of
the current animation.</p>
<p>Now we need to go to the editor again and add the animations to the <code>Player</code>, select the player's rigid body, and
find the <code>Script</code> section in the <code>Inspector</code>. Add two animations there like so:</p>
<p><img src="fyrox/tutorials/platformer/editor_step6.png" alt="editor_step6" /></p>
<p>After filling in the animations and turning them on, you can run the game and your character should play animations
correctly.</p>
<h2 id="conclusion-4"><a class="header" href="#conclusion-4">Conclusion</a></h2>
<p>In this tutorial, we've learned the basics of the new scripting system of the engine. The game we've built it very 
simple, but it is just the beginning. It is easy to add more scripts for enemies, weapons, collectible items, and so on.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="performance-10"><a class="header" href="#performance-10">Performance</a></h1>
<p>This section of the book covers very specific cases of extreme performance, that is suitable for some exceptional cases.
For the vast majority of cases, standard engine approaches are perfectly fine. </p>
<h2 id="ecs"><a class="header" href="#ecs">ECS</a></h2>
<p>Theoretically, the ECS approach <em>can</em> give you better performance, but lets at first see where ECS is beneficial,
and why classic approach is still viable. The ECS is beneficial <em>only</em> in cases where you have to process
<strong>ten or hundreds thousands</strong> objects every frame, the performance gain of cache friendliness can be significant
in such cases. But let's stop for a second and ask ourselves again: how <em>often</em> games have such huge amount of objects
that has to be processed every frame? There are very few examples of such games:</p>
<ul>
<li>Strategy games - at some extent, because there are very few games that allows you to control tens of thousands
units at the same time. More often you have a range from five hundreds up to few thousands.</li>
<li>Sandboxes - there could be lots of tiny objects that has to be processed every frame.</li>
<li>Specific genres - games with destructible environment and so on.</li>
</ul>
<p>Note that the list does not include games with vast worlds, why so? The reason is that such games does <strong>not</strong>
process every tiny object in the world at once, instead they split the world in small chunks and process only
few chunks at once, those where the player is present.</p>
<p>The rest of genres operate on a tiny amount of object compared to those up above, maybe a few hundreds at max.
One might say - hey, each object could contain lots of tiny &quot;moving parts&quot;, what's about them? Usually each
object contains up to 10-15 sub-parts, which leads us to few thousands of &quot;atomic&quot; object. Is it much? Not really.</p>
<h3 id="architecture"><a class="header" href="#architecture">Architecture</a></h3>
<p>One might also think that ECS is a silver bullet for borrow checker in Rust, which &quot;shuts its noisy mouth&quot; once
and for all leaving you only with your game code. That's not quite true, it somewhat solves the problem of unique
mutable access to data, but interaction between systems can still be painful. Standard OOP-approach is always being
criticized by allowing you to create spaghetti-code for which borrow checker will yell at you (which is indeed
reasonable). We should consider borrow checker not as our enemy, that prevents us from writing code, but as
our friend that tells us - &quot;dude, this won't work without potential crashes, memory issues, etc.&quot;. What borrow
checker tries to tell us is that we need to re-think the architecture of our game.</p>
<p>So how does Fyrox solve the problem of unique mutable access? It forces you to use a &quot;top-down&quot; flow in your game.
What does that mean? In short, you have to change the data only by going from top to bottom on a call tree. But
isn't that too restrictive, what if I want to call some higher-level function while being in lower-level function?
This is a very good question, and a short answer for it: <em>no</em>. It isn't restrictive at all, because you can always
invert the &quot;bottom-to-top&quot; flow to &quot;top-down&quot;. The &quot;bottom-to-top&quot; calls are prohibited, because they're violating
unique mutable borrow rules.</p>
<p>The flow can be easily inverted by <em>deferring</em> actions for later, not for a next frame, but for a moment after
the place where &quot;bottom-to-top&quot; call was required. How this can be achieved? All you should do is to collect the
info that is needed to perform inverted &quot;bottom-to-top&quot; call and do a call right after that place where it was
required, but starting from the top level of your game. One of the most common approaches for this is to use
message passing with Rust's channels (MPSC queue). The receiver should be polled at the top level of your game
and every other place that needs &quot;bottom-to-top&quot; call should just queue desired actions by providing required info
in respective message.</p>
<p>This is a very simple, yet powerful mechanism to satisfy make your code clearer and satisfy borrow checker. One
may argue that such approach has some performance impact. It is indeed has performance impact, but it is tiny, in
most cases it can't be even measured.</p>
<p>Borrowing issues cannot be fully prevented, even the right architecture can't help borrow checker to prove that
your code is safe in some cases (graph data structure for example). To solve this problem, the engine uses
generational arenas (<em>pool</em> in Fyrox's terminology) and handles. Instead of storing the objects in various places,
you put all your objects in a pool, and it gives you handles which can later be used to borrow a reference to
that object. This approach allows you to build any data structures that may hold &quot;references&quot; to other objects.
The references replaced with handles, which can be treated (very roughly) as just an index. See
<a href="fyrox/performance/./beginning/data_management.html">separate chapter</a> in the book for more info.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="obsolete-features"><a class="header" href="#obsolete-features">Obsolete Features</a></h1>
<p>The following chapters contains information about obsolete features that should not be used.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="installation-obsolete"><a class="header" href="#installation-obsolete">Installation (Obsolete)</a></h2>
<p><strong>WARNING: This section considered obsolete - Fyrox 0.25+ has project generator that handles installation for you.
This section is intended to be used only if you're using the engine as a framework!</strong></p>
<p>Since the engine is distributed as a library, it has to be added to <code>[dependecies]</code> section of <code>Cargo.toml</code> of
your project to start using it, there is no pre-built executables or library files. If you don't know what is
<code>Cargo.toml</code> or <code>cargo</code>, please <a href="https://doc.rust-lang.org/cargo/">read this</a> before continue.</p>
<h3 id="using-stable-version"><a class="header" href="#using-stable-version">Using stable version</a></h3>
<p>To begin using the engine, just add following lines to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
fyrox = &quot;^0.27&quot;
</code></pre>
<p>This will force Cargo to use the latest <strong>stable</strong> version of the engine.</p>
<h3 id="using-latest-unstable-version"><a class="header" href="#using-latest-unstable-version">Using latest unstable version</a></h3>
<p>Sometimes you want to use the latest features that are not yet released in a stable version, then you can use
the engine directly from its repository, simply add the following line to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
fyrox = { git = &quot;https://github.com/FyroxEngine/Fyrox&quot; } 
</code></pre>
<p>This will update your build files fairly often. If you don't want game breaking changes to occur because of engine updates or want to not compile daily,
change <code>fyrox = { git = &quot;https://github.com/FyroxEngine/Fyrox&quot; }</code> to <code>fyrox = { git = &quot;https://github.com/FyroxEngine/Fyrox&quot;, rev = &quot;&quot; }</code> with the commit
hash in the quotes.</p>
<h2 id="editor-installation"><a class="header" href="#editor-installation">Editor installation</a></h2>
<p>The engine offers an editor, to install a standalone version it, use <code>cargo install</code>:</p>
<pre><code class="language-shell">cargo install fyroxed
</code></pre>
<p>Standalone version does not allow you to run your game inside it, but only allows you to edit scenes.</p>
<p>After that you can run the editor with a single command:</p>
<pre><code class="language-shell">fyroxed
</code></pre>
<p>Check the next chapter to create a simple application.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-game-loop"><a class="header" href="#custom-game-loop">Custom game loop</a></h1>
<p><strong>WARNING: Manual engine initialization considered obsolete, use plugins and scripts instead.</strong></p>
<p>The plugin might be limiting for some cases, in such situations the engine could be initialized manually. It
requires some decent amount of code and could error-prone for beginners. You should use custom game loop only if
you're experienced game developer!</p>
<p>Here is an example of custom game loop with comments that will guide your through all aspects of it:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::{instant::Instant, log::{Log, MessageKind}},
</span><span class="boring">    engine::{GraphicsContextParams, Engine, EngineInitParams, GraphicsContext, SerializationContext},
</span><span class="boring">    asset::manager::ResourceManager, 
</span><span class="boring">    event::{Event, WindowEvent},
</span><span class="boring">    event_loop::{ControlFlow, EventLoop},
</span><span class="boring">    window::WindowAttributes,  
</span><span class="boring">    utils::{
</span><span class="boring">        translate_event,
</span><span class="boring">    },
</span><span class="boring">};
</span><span class="boring">use std::{sync::Arc};
</span>
fn main() {
    let event_loop = EventLoop::new();

    // Then initialize the engine.
    let graphics_context_params = GraphicsContextParams {
        window_attributes: WindowAttributes {
            title: &quot;Custom Game Loop&quot;.to_string(),
            resizable: true,
            ..Default::default()
        },
        vsync: true,
    };

    let serialization_context = Arc::new(SerializationContext::new());
    let mut engine = Engine::new(EngineInitParams {
        graphics_context_params,
        resource_manager: ResourceManager::new(),
        serialization_context,
    })
    .unwrap();

    // Define game loop variables.
    let mut previous = Instant::now();
    let fixed_timestep = 1.0 / 60.0;
    let mut lag = 0.0;

    // Finally run our event loop which will respond to OS and window events and update
    // engine state accordingly. Engine lets you to decide which event should be handled,
    // this is minimal working example if how it should be.
    event_loop.run(move |event, window_target, control_flow| {
        match event {
            Event::MainEventsCleared =&gt; {
                // This main game loop - it has fixed time step which means that game
                // code will run at fixed speed even if renderer can't give you desired
                // 60 fps.
                let elapsed = previous.elapsed();
                previous = Instant::now();
                lag += elapsed.as_secs_f32();
                while lag &gt;= fixed_timestep {
                    lag -= fixed_timestep;

                    // ************************
                    // ************************
                    // Put your game logic here.
                    // ************************
                    // ************************

                    // It is very important to update the engine every frame!
                    engine.update(fixed_timestep, control_flow, &amp;mut lag, Default::default());
                }

                // It is very important to &quot;pump&quot; messages from UI. Even if don't need to
                // respond to such message, you should call this method, otherwise UI
                // might behave very weird.
                while let Some(_ui_event) = engine.user_interface.poll_message() {
                    // ************************
                    // ************************
                    // Put your data model synchronization code here. It should
                    // take message and update data in your game according to
                    // changes in UI.
                    // ************************
                    // ************************
                }

                // Rendering must be explicitly requested and handled after RedrawRequested event is received.
                if let GraphicsContext::Initialized(ref ctx) = engine.graphics_context {
                    ctx.window.request_redraw();
                }
            }
            Event::RedrawRequested(_) =&gt; {
                // Run renderer at max speed - it is not tied to game code.
                engine.render().unwrap();
            }
            Event::Resumed =&gt; {
                engine.initialize_graphics_context(window_target).unwrap();
            }
            Event::Suspended =&gt; {
                engine.destroy_graphics_context().unwrap();
            }
            Event::WindowEvent { event, .. } =&gt; {
                match event {
                    WindowEvent::CloseRequested =&gt; *control_flow = ControlFlow::Exit,
                    WindowEvent::Resized(size) =&gt; {
                        // It is very important to handle Resized event from window, because
                        // renderer knows nothing about window size - it must be notified
                        // directly when window size has changed.
                        if let Err(e) = engine.set_frame_size(size.into()) {
                            Log::writeln(
                                MessageKind::Error,
                                format!(&quot;Unable to set frame size: {:?}&quot;, e),
                            );
                        }
                    }
                    // Handle rest of events here if necessary.
                    _ =&gt; (),
                }

                // It is very important to &quot;feed&quot; user interface (UI) with events coming
                // from main window, otherwise UI won't respond to mouse, keyboard, or any
                // other event.
                if let Some(os_event) = translate_event(&amp;event) {
                    engine.user_interface.process_os_event(&amp;os_event);
                }
            }
            // Continue polling messages from OS.
            _ =&gt; *control_flow = ControlFlow::Poll,
        }
    });
}</code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
