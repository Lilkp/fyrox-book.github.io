<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Fyrox Book</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="fyrox/introduction.html"><strong aria-hidden="true">2.</strong> Fyrox</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="fyrox/beginning/getting_started.html"><strong aria-hidden="true">2.1.</strong> Getting started</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="fyrox/beginning/scripting.html"><strong aria-hidden="true">2.1.1.</strong> Editor, Plugins and Scripts</a></li><li class="chapter-item expanded "><a href="fyrox/beginning/editor_overview.html"><strong aria-hidden="true">2.1.2.</strong> Editor Overview</a></li><li class="chapter-item expanded "><a href="fyrox/beginning/scene_and_scene_graph.html"><strong aria-hidden="true">2.1.3.</strong> Scene and scene graph</a></li><li class="chapter-item expanded "><a href="fyrox/beginning/assets.html"><strong aria-hidden="true">2.1.4.</strong> Assets</a></li><li class="chapter-item expanded "><a href="fyrox/beginning/data_management.html"><strong aria-hidden="true">2.1.5.</strong> Data management</a></li></ol></li><li class="chapter-item expanded "><a href="fyrox/scripting/scripting.html"><strong aria-hidden="true">2.2.</strong> Scripting</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="fyrox/scripting/plugin.html"><strong aria-hidden="true">2.2.1.</strong> Plugins</a></li><li class="chapter-item expanded "><a href="fyrox/scripting/executor.html"><strong aria-hidden="true">2.2.2.</strong> Executor</a></li><li class="chapter-item expanded "><a href="fyrox/scripting/script.html"><strong aria-hidden="true">2.2.3.</strong> Scripts</a></li></ol></li><li class="chapter-item expanded "><a href="fyrox/scene/scene.html"><strong aria-hidden="true">2.3.</strong> Scene</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="fyrox/scene/graph.html"><strong aria-hidden="true">2.3.1.</strong> Graph</a></li><li class="chapter-item expanded "><a href="fyrox/scene/prefab.html"><strong aria-hidden="true">2.3.2.</strong> Prefabs</a></li><li class="chapter-item expanded "><a href="fyrox/scene/base_node.html"><strong aria-hidden="true">2.3.3.</strong> Base node</a></li><li class="chapter-item expanded "><a href="fyrox/scene/mesh_node.html"><strong aria-hidden="true">2.3.4.</strong> Mesh node</a></li><li class="chapter-item expanded "><a href="fyrox/scene/light_node.html"><strong aria-hidden="true">2.3.5.</strong> Light node</a></li><li class="chapter-item expanded "><a href="fyrox/scene/sprite_node.html"><strong aria-hidden="true">2.3.6.</strong> Sprite node</a></li><li class="chapter-item expanded "><a href="fyrox/scene/particle_system_node.html"><strong aria-hidden="true">2.3.7.</strong> Particle system node (WIP)</a></li><li class="chapter-item expanded "><a href="fyrox/scene/terrain_node.html"><strong aria-hidden="true">2.3.8.</strong> Terrain node (WIP)</a></li><li class="chapter-item expanded "><a href="fyrox/scene/camera_node.html"><strong aria-hidden="true">2.3.9.</strong> Camera node</a></li><li class="chapter-item expanded "><a href="fyrox/scene/decal_node.html"><strong aria-hidden="true">2.3.10.</strong> Decal node</a></li><li class="chapter-item expanded "><a href="fyrox/scene/rectangle.html"><strong aria-hidden="true">2.3.11.</strong> Rectangle node</a></li><li class="chapter-item expanded "><a href="fyrox/scene/custom_node.html"><strong aria-hidden="true">2.3.12.</strong> Custom node</a></li><li class="chapter-item expanded "><a href="fyrox/physics/physics.html"><strong aria-hidden="true">2.3.13.</strong> Physics</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="fyrox/physics/rigid_body.html"><strong aria-hidden="true">2.3.13.1.</strong> Rigid body</a></li><li class="chapter-item expanded "><a href="fyrox/physics/collider.html"><strong aria-hidden="true">2.3.13.2.</strong> Collider</a></li><li class="chapter-item expanded "><a href="fyrox/physics/joint.html"><strong aria-hidden="true">2.3.13.3.</strong> Joint</a></li><li class="chapter-item expanded "><a href="fyrox/physics/ray.html"><strong aria-hidden="true">2.3.13.4.</strong> Ray Casting</a></li></ol></li><li class="chapter-item expanded "><a href="fyrox/sound/sound.html"><strong aria-hidden="true">2.3.14.</strong> Sound</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="fyrox/sound/hrtf.html"><strong aria-hidden="true">2.3.14.1.</strong> HRTF (WIP)</a></li><li class="chapter-item expanded "><a href="fyrox/sound/effects.html"><strong aria-hidden="true">2.3.14.2.</strong> Effects (WIP)</a></li></ol></li><li class="chapter-item expanded "><a href="fyrox/animation/animation.html"><strong aria-hidden="true">2.3.15.</strong> Animation</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="fyrox/animation/blending.html"><strong aria-hidden="true">2.3.15.1.</strong> Blending</a></li><li class="chapter-item expanded "><a href="fyrox/animation/editor.html"><strong aria-hidden="true">2.3.15.2.</strong> ABSM Editor</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="fyrox/ai/ai.html"><strong aria-hidden="true">2.4.</strong> Artificial Intelligence (WIP)</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="fyrox/ai/beh_tree.html"><strong aria-hidden="true">2.4.1.</strong> Behaviour Trees (WIP)</a></li><li class="chapter-item expanded "><a href="fyrox/ai/pathfinding.html"><strong aria-hidden="true">2.4.2.</strong> Path Finding (WIP)</a></li><li class="chapter-item expanded "><a href="fyrox/ai/navmesh.html"><strong aria-hidden="true">2.4.3.</strong> Navigational Meshes (WIP)</a></li></ol></li><li class="chapter-item expanded "><a href="fyrox/rendering/rendering.html"><strong aria-hidden="true">2.5.</strong> Rendering</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="fyrox/rendering/shaders.html"><strong aria-hidden="true">2.5.1.</strong> Shaders</a></li><li class="chapter-item expanded "><a href="fyrox/rendering/materials.html"><strong aria-hidden="true">2.5.2.</strong> Materials</a></li><li class="chapter-item expanded "><a href="fyrox/rendering/lightmaps.html"><strong aria-hidden="true">2.5.3.</strong> Light Maps (WIP)</a></li><li class="chapter-item expanded "><a href="fyrox/rendering/settings.html"><strong aria-hidden="true">2.5.4.</strong> Settings</a></li><li class="chapter-item expanded "><a href="fyrox/rendering/render_pass.html"><strong aria-hidden="true">2.5.5.</strong> Render Pass</a></li></ol></li><li class="chapter-item expanded "><a href="fyrox/resources/resources.html"><strong aria-hidden="true">2.6.</strong> Resource Management</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="fyrox/resources/model.html"><strong aria-hidden="true">2.6.1.</strong> Models</a></li><li class="chapter-item expanded "><a href="fyrox/resources/texture.html"><strong aria-hidden="true">2.6.2.</strong> Textures</a></li><li class="chapter-item expanded "><a href="fyrox/resources/sound.html"><strong aria-hidden="true">2.6.3.</strong> Sound Buffers (WIP)</a></li><li class="chapter-item expanded "><a href="fyrox/resources/curve.html"><strong aria-hidden="true">2.6.4.</strong> Curves (WIP)</a></li><li class="chapter-item expanded "><a href="fyrox/resources/absm.html"><strong aria-hidden="true">2.6.5.</strong> Animation Machines (WIP)</a></li></ol></li><li class="chapter-item expanded "><a href="fyrox/ui/ui.html"><strong aria-hidden="true">2.7.</strong> User Interface</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="fyrox/ui/basic_concepts/basic_concepts.html"><strong aria-hidden="true">2.7.1.</strong> Basic concepts</a></li><li class="chapter-item expanded "><a href="fyrox/ui/general_rules.html"><strong aria-hidden="true">2.7.2.</strong> General rules</a></li><li class="chapter-item expanded "><a href="fyrox/ui/font.html"><strong aria-hidden="true">2.7.3.</strong> Fonts</a></li><li class="chapter-item expanded "><a href="fyrox/ui/theme.html"><strong aria-hidden="true">2.7.4.</strong> Theme</a></li><li class="chapter-item expanded "><a href="fyrox/ui/widgets.html"><strong aria-hidden="true">2.7.5.</strong> Widgets</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="fyrox/ui/button.html"><strong aria-hidden="true">2.7.5.1.</strong> Button</a></li><li class="chapter-item expanded "><a href="fyrox/ui/border.html"><strong aria-hidden="true">2.7.5.2.</strong> Border</a></li><li class="chapter-item expanded "><a href="fyrox/ui/canvas.html"><strong aria-hidden="true">2.7.5.3.</strong> Canvas</a></li><li class="chapter-item expanded "><a href="fyrox/ui/checkbox/check_box.html"><strong aria-hidden="true">2.7.5.4.</strong> Check box</a></li><li class="chapter-item expanded "><a href="fyrox/ui/curve_editor.html"><strong aria-hidden="true">2.7.5.5.</strong> Curve editor (WIP)</a></li><li class="chapter-item expanded "><a href="fyrox/ui/decorator.html"><strong aria-hidden="true">2.7.5.6.</strong> Decorator (WIP)</a></li><li class="chapter-item expanded "><a href="fyrox/ui/dock.html"><strong aria-hidden="true">2.7.5.7.</strong> Docking manager (WIP)</a></li><li class="chapter-item expanded "><a href="fyrox/ui/dropdown_list.html"><strong aria-hidden="true">2.7.5.8.</strong> Dropdown list (WIP)</a></li><li class="chapter-item expanded "><a href="fyrox/ui/expander.html"><strong aria-hidden="true">2.7.5.9.</strong> Expander (WIP)</a></li><li class="chapter-item expanded "><a href="fyrox/ui/file_browser.html"><strong aria-hidden="true">2.7.5.10.</strong> File browser (WIP)</a></li><li class="chapter-item expanded "><a href="fyrox/ui/grid.html"><strong aria-hidden="true">2.7.5.11.</strong> Grid</a></li><li class="chapter-item expanded "><a href="fyrox/ui/image.html"><strong aria-hidden="true">2.7.5.12.</strong> Image</a></li><li class="chapter-item expanded "><a href="fyrox/ui/inspector.html"><strong aria-hidden="true">2.7.5.13.</strong> Inspector (WIP)</a></li><li class="chapter-item expanded "><a href="fyrox/ui/list_view.html"><strong aria-hidden="true">2.7.5.14.</strong> List view (WIP)</a></li><li class="chapter-item expanded "><a href="fyrox/ui/menu.html"><strong aria-hidden="true">2.7.5.15.</strong> Menu (WIP)</a></li><li class="chapter-item expanded "><a href="fyrox/ui/message_box.html"><strong aria-hidden="true">2.7.5.16.</strong> Message box (WIP)</a></li><li class="chapter-item expanded "><a href="fyrox/ui/numeric.html"><strong aria-hidden="true">2.7.5.17.</strong> Numeric field (WIP)</a></li><li class="chapter-item expanded "><a href="fyrox/ui/popup.html"><strong aria-hidden="true">2.7.5.18.</strong> Popup (WIP)</a></li><li class="chapter-item expanded "><a href="fyrox/ui/progress_bar.html"><strong aria-hidden="true">2.7.5.19.</strong> Progress bar (WIP)</a></li><li class="chapter-item expanded "><a href="fyrox/ui/range.html"><strong aria-hidden="true">2.7.5.20.</strong> Range (WIP)</a></li><li class="chapter-item expanded "><a href="fyrox/ui/rect.html"><strong aria-hidden="true">2.7.5.21.</strong> Rect (WIP)</a></li><li class="chapter-item expanded "><a href="fyrox/ui/scroll_bar.html"><strong aria-hidden="true">2.7.5.22.</strong> Scroll bar (WIP)</a></li><li class="chapter-item expanded "><a href="fyrox/ui/scroll_panel.html"><strong aria-hidden="true">2.7.5.23.</strong> Scroll panel (WIP)</a></li><li class="chapter-item expanded "><a href="fyrox/ui/scroll_viewer.html"><strong aria-hidden="true">2.7.5.24.</strong> Scroll viewer (WIP)</a></li><li class="chapter-item expanded "><a href="fyrox/ui/stack_panel.html"><strong aria-hidden="true">2.7.5.25.</strong> Stack panel</a></li><li class="chapter-item expanded "><a href="fyrox/ui/tab_control.html"><strong aria-hidden="true">2.7.5.26.</strong> Tab Control</a></li><li class="chapter-item expanded "><a href="fyrox/ui/text.html"><strong aria-hidden="true">2.7.5.27.</strong> Text</a></li><li class="chapter-item expanded "><a href="fyrox/ui/text_box.html"><strong aria-hidden="true">2.7.5.28.</strong> Text box</a></li><li class="chapter-item expanded "><a href="fyrox/ui/tree.html"><strong aria-hidden="true">2.7.5.29.</strong> Tree (WIP)</a></li><li class="chapter-item expanded "><a href="fyrox/ui/vector_image.html"><strong aria-hidden="true">2.7.5.30.</strong> Vector image (WIP)</a></li><li class="chapter-item expanded "><a href="fyrox/ui/window.html"><strong aria-hidden="true">2.7.5.31.</strong> Window</a></li><li class="chapter-item expanded "><a href="fyrox/ui/wrap_panel.html"><strong aria-hidden="true">2.7.5.32.</strong> Wrap panel</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="fyrox/serialization/serialization.html"><strong aria-hidden="true">2.8.</strong> Serialization (WIP)</a></li><li class="chapter-item expanded "><a href="fyrox/misc/misc.html"><strong aria-hidden="true">2.9.</strong> Miscellaneous</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="fyrox/misc/log.html"><strong aria-hidden="true">2.9.1.</strong> Log</a></li></ol></li><li class="chapter-item expanded "><a href="fyrox/tutorials/tutorials.html"><strong aria-hidden="true">2.10.</strong> Tutorials</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="fyrox/tutorials/fps/intro.html"><strong aria-hidden="true">2.10.1.</strong> FPS Tutorial</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="fyrox/tutorials/fps/tutorial-1/tutorial-part-1.html"><strong aria-hidden="true">2.10.1.1.</strong> Character controller</a></li><li class="chapter-item expanded "><a href="fyrox/tutorials/fps/tutorial-2/tutorial-part-2.html"><strong aria-hidden="true">2.10.1.2.</strong> Weapons</a></li><li class="chapter-item expanded "><a href="fyrox/tutorials/fps/tutorial-3/tutorial-part-3.html"><strong aria-hidden="true">2.10.1.3.</strong> Bots and AI</a></li></ol></li><li class="chapter-item expanded "><a href="fyrox/tutorials/rpg/intro.html"><strong aria-hidden="true">2.10.2.</strong> RPG Tutorial</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="fyrox/tutorials/rpg/tutorial-1/tutorial-part-1.html"><strong aria-hidden="true">2.10.2.1.</strong> Character controller</a></li></ol></li><li class="chapter-item expanded "><a href="fyrox/tutorials/platformer/part1.html"><strong aria-hidden="true">2.10.3.</strong> 2D Platformer tutorial</a></li></ol></li><li class="chapter-item expanded "><a href="fyrox/obsolete/obsolete.html"><strong aria-hidden="true">2.11.</strong> Obsolete</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="fyrox/obsolete/installation.html"><strong aria-hidden="true">2.11.1.</strong> Installation (Obsolete)</a></li><li class="chapter-item expanded "><a href="fyrox/obsolete/custom_game_loop.html"><strong aria-hidden="true">2.11.2.</strong> Custom game loop (Obsolete)</a></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Fyrox Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/fyrox-book/fyrox-book.github.io" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="fyrox-game-engine-book"><a class="header" href="#fyrox-game-engine-book">Fyrox Game Engine Book</a></h1>
<p>Practical reference and user guides for <a href="https://github.com/FyroxEngine/Fyrox">Fyrox Game Engine</a> and its 
editor <a href="https://github.com/FyroxEngine/Fyrox/tree/master/editor">Fyroxed</a>.</p>
<p><strong>Warning:</strong> The book is in early development stage, you can help to improve it by making a contribution in its
<a href="https://github.com/fyrox-book/fyrox-book.github.io">repository</a>. Don't be shy, every tip is helpful!</p>
<h2 id="how-to-read-the-book"><a class="header" href="#how-to-read-the-book">How to read the book</a></h2>
<p>Almost every chapter in this book can be read in any order, but we recommend reading Chapter 1 and then going
through <a href="fyrox/tutorials/platformer/part1.html">Platformer Tutorial (2D)</a> while learning more about specific areas that
interest you from the other chapters. </p>
<p>There is also a <a href="fyrox/tutorials/fps/intro.html">First-Person Shooter Tutorial (3D)</a>, but it is based on framework which
considered obsolete, yet it is still very helpful. </p>
<h2 id="required-knowledge"><a class="header" href="#required-knowledge">Required knowledge</a></h2>
<p>We're expecting that you know basics of Rust programming language, its package manager Cargo. It is also necessary
to know the <em>basics</em> of the game development, linear algebra, principles of software development and patterns, 
otherwise the book will probably be very hard for you. </p>
<h2 id="support-the-development"><a class="header" href="#support-the-development">Support the development</a></h2>
<p>The future of the project fully depends on community support, every bit is important!</p>
<p><a href="https://www.patreon.com/mrdimas"><img src="https://c5.patreon.com/external/logo/become_a_patron_button.png" alt="Become a patron!" /></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fyrox"><a class="header" href="#fyrox">Fyrox</a></h1>
<p>Fyrox is a feature-rich, general purpose game engine that is suitable for any kind of games. It is capable to power
games with small- or medium-sized worlds, large-sized world most likely will require some manual work. This chapter
of the book will help you to get familiar with core engine concepts and will help you start writing your first game!</p>
<p>Let's briefly get over some basic concepts of the engine, there's not much, but all of them are crucial to understand
design decisions made in the engine.</p>
<h2 id="ecs-and-classic-oop"><a class="header" href="#ecs-and-classic-oop">ECS and classic OOP</a></h2>
<p>The engine <strong>does not</strong> use ECS, instead it uses <strong>classic OOP</strong> with composition over inheritance. More specifically,
complex objects in the engine can be constructed using simpler objects. As a very simple example of this, let's 
check the scene node. The base object for every scene node is a <code>Base</code> node, it contains a transform, a list
of children, etc. The more complex object, that <em>extends</em> functionality of the <code>Base</code> node stores an instance of
<code>Base</code> inside of them. For example, a <code>Mesh</code> node is a <code>Base</code> node <em>plus</em> some specific info (a list of surfaces,
material, etc.). The &quot;hierarchy&quot; depth is unlimited - a <code>Light</code> node in the engine is an enumeration of three 
possible types of light source. <code>Directional</code>, <code>Point</code>, and <code>Spot</code> light sources both use <code>BaseLight</code> node, 
which in its turn contains <code>Base</code> node inside. Graphically it can be represented like so:</p>
<pre><code class="language-text">`Point`
|__ Point Light Properties (radius, etc.)
|__`BaseLight`
   |__ Base Light Properties (color, etc.)
   |__`Base`
      |__ Base Node Properties (transform, children nodes, etc.)
</code></pre>
<p>As you can see, this forms the nice tree that shows what the object contains. This is very natural way of describing
scene nodes, it gives you the full power of building an object of any complexity. On the other hand, in ECS, all
you have is just a set of components that you have to query in your systems, the structure becomes flat, and you lose
all &quot;relationships&quot; between object parts.</p>
<h3 id="performance"><a class="header" href="#performance">Performance</a></h3>
<p>Theoretically, the ECS approach <em>can</em> give you better performance, but let's at first see where ECS is beneficial,
and why classic approach is still viable. The ECS is beneficial <em>only</em> in cases where you have to process 
<strong>ten or hundreds thousands</strong> objects every frame, the performance gain of cache friendliness can be significant
in such cases. But let's stop for a second and ask ourselves again: how <em>often</em> games have such huge amount of objects 
that has to be processed every frame? There are very few examples of such games:</p>
<ul>
<li>Strategy games - at some extent, because there are very few games that allows you to control tens of thousands
units at the same time. More often you have a range from five hundreds up to few thousands.</li>
<li>Sandboxes - there could be lots of tiny objects that has to be processed every frame.</li>
<li>Specific genres - games with destructible environment and so on.</li>
</ul>
<p>Note that the list does not include games with vast worlds, why so? The reason is that such games does <strong>not</strong>
process every tiny object in the world at once, instead they split the world in small chunks and process only
few chunks at once, those where the player is present. </p>
<p>The rest of genres operate on a tiny amount of object compared to those up above, maybe a few hundreds at max.
One might say - hey, each object could contain lots of tiny &quot;moving parts&quot;, what's about them? Usually each 
object contains up to 10-15 sub-parts, which leads us to few thousands of &quot;atomic&quot; object. Is it much? Not really.</p>
<h3 id="architecture"><a class="header" href="#architecture">Architecture</a></h3>
<p>One might also think that ECS is a silver bullet for borrow checker in Rust, which &quot;shuts its noisy mouth&quot; once
and for all leaving you only with your game code. That's not quite true, it somewhat solves the problem of unique
mutable access to data, but interaction between systems can still be painful. Standard OOP-approach is always being
criticized by allowing you to create spaghetti-code for which borrow checker will yell at you (which is indeed 
reasonable). We should consider borrow checker not as our enemy, that prevents us from writing code, but as 
our friend that tells us - &quot;dude, this won't work without potential crashes, memory issues, etc.&quot;. What borrow
checker tries to tell us is that we need to re-think the architecture of our game. </p>
<p>So how the engine solves the problem of unique mutable access? It forces you to use a &quot;top-down&quot; flow in your game.
What does that mean? In short, you have to change the data only by going from top to bottom on a call tree. But 
isn't that too restrictive, what if I want to call some higher-level function while being in lower-level function?
This is a very good question, and a short answer for it: <em>no</em>. It isn't restrictive at all, because you can always
invert the &quot;bottom-to-top&quot; flow to &quot;top-down&quot;. The &quot;bottom-to-top&quot; calls are prohibited, because they're violating
unique mutable borrow rules.</p>
<p>The flow can be easily inverted by <em>deferring</em> actions for later, not for a next frame, but for a moment after 
the place where &quot;bottom-to-top&quot; call was required. How this can be achieved? All you should do is to collect the
info that is needed to perform inverted &quot;bottom-to-top&quot; call and do a call right after that place where it was 
required, but starting from the top level of your game. One of the most common approaches for this is to use 
message passing with Rust's channels (MPSC queue). The receiver should be polled at the top level of your game
and every other place that needs &quot;bottom-to-top&quot; call should just queue desired actions by providing required info
in respective message. </p>
<p>This is a very simple, yet powerful mechanism to satisfy make your code clearer and satisfy borrow checker. One
may argue that such approach has some performance impact. It is indeed has performance impact, but it is tiny, in
most cases it can't be even measured.</p>
<p>Borrowing issues cannot be fully prevented, even the right architecture can't help borrow checker to prove that 
your code is safe in some cases (graph data structure for example). To solve this problem, the engine uses
generational arenas (<em>pool</em> in fyrox's terminology) and handles. Instead of storing the objects in various places,
you put all your objects in a pool, and it gives you handles which can later be used to borrow a reference to
that object. This approach allows you to build any data structures that may hold &quot;references&quot; to other objects.
The references replaced with handles, which can be treated (very roughly) as just an index. See
<a href="fyrox/./beginning/data_management.html">separate chapter</a> in the book for more info.</p>
<h3 id="can-i-use-ecs-anyways"><a class="header" href="#can-i-use-ecs-anyways">Can I use ECS anyways?</a></h3>
<p>Indeed, you can! You can use it for your game code with no problems, all you should do is to write some glue
code that will provide the engine with required information. Please check examples for your favourite ECS crate
to understand how to do that.</p>
<h3 id="afterword"><a class="header" href="#afterword">Afterword</a></h3>
<p>ECS and classic OOP are <em>just tools</em>, pick one which suits you the most, don't be a blind zealot, choose wisely!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting started</a></h1>
<p>Despite the look of it, the engine is quite friendly to newcomers, especially with some good guides. This section
of the book will guide you through the basics of the engine. Fyrox 0.25+ changed game development paradigm - you
should use the editor (FyroxEd) to make your game, like in many other game engines.</p>
<h2 id="engine-vs-framework"><a class="header" href="#engine-vs-framework">Engine vs Framework</a></h2>
<p>There are two distinct concepts in game development - engine and framework, but they're often &quot;mixes&quot; and people gets
confused what is framework and what is engine. Fyrox is full-featured game <strong>engine</strong>, what does that mean and why it
is not a framework? Key features that allow you to understand that you're looking at game engine are following:</p>
<ul>
<li>Editor - true game engine provides integrated game development environment, that allows you to run your game from
it, tweak parameters of your game entities, etc.</li>
<li>Assets pipeline - engine has pretty rigid assets processing pipeline. </li>
<li>Standard programming patterns - engine &quot;forces&quot; you to use it in almost single way, there is pretty much no space 
for maneuver.</li>
</ul>
<h2 id="obsolete-fyrox-as-framework"><a class="header" href="#obsolete-fyrox-as-framework">Obsolete &quot;Fyrox as Framework&quot;</a></h2>
<p>Before 0.25, Fyrox was just a framework (yet it still had an editor), you can still use it in old way (do manual
initialization, do not use editor, etc.), but it is considered obsolete and eventually &quot;framework mode&quot; won't be 
supported. The book has few chapters that are marked <code>Obsolete</code>, this means that they're not advised to be used.</p>
<p>Read next chapter to learn how to use the engine in a &quot;modern&quot; way. </p>
<h2 id="api-documentation"><a class="header" href="#api-documentation">API Documentation</a></h2>
<p>The book is primarily focused on game development with Fyrox, not on its API. You can find API docs 
<a href="https://docs.rs/fyrox/latest/fyrox/">here</a>. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="editor-plugins-and-scripts"><a class="header" href="#editor-plugins-and-scripts">Editor, Plugins and Scripts</a></h1>
<p>Every Fyrox game is just a plugin for both the engine and the editor, such approach allows you to run your game from the 
editor and be able to edit game entities in it. Your game can define any number of scripts, which can be assigned 
to scene objects to run custom game logic on them. In this chapter you'll learn basics of plugins and scripting system,
also you'll learn how to run the editor.</p>
<h2 id="project-generator"><a class="header" href="#project-generator">Project Generator</a></h2>
<p>Fyrox plugins are static, this means that you must re-compile your game or editor if you change source code of your game,
such architecture requires some boilerplate code that is generic for every game. Fyrox offers special tiny tool - 
<code>fyrox-template</code> - it helps you to generate all boilerplate parts in a single command. Install it using the following 
command:</p>
<pre><code class="language-shell">cargo install fyrox-template
</code></pre>
<p>For Linux, you may need to specify installation directory explicitly, because <code>cargo</code> puts binaries into <code>/usr/.cargo/bin</code>
which may not be in <code>PATH</code>. You can either register the previous path in <code>PATH</code> environment variable, or directly
specify the location that is already in path:</p>
<pre><code class="language-shell">cargo install fyrox-template --root /usr/bin
</code></pre>
<p>Navigate to a folder where you want the project to be created and do the following command:</p>
<pre><code class="language-shell">fyrox-template init --name my_game --style 3d
</code></pre>
<p>The tool accepts two arguments - a project name (<code>--name</code>) and a style (<code>--style</code>) which defines the contents of default
scene. Once you initialized your project, go to <code>game/src/lib.rs</code> - it is where your game logic is located, as you can 
see the <code>fyrox-template</code> generated quite some code for you. There are tiny comments about which place is for what. For 
more info about each method, please refer <a href="https://docs.rs/fyrox/latest/fyrox/plugin/trait.Plugin.html">to the docs</a>.</p>
<p>After the project is generated, you should memorize two commands that will help you to run your game in different modes:</p>
<ul>
<li><code>cargo run --package editor --release</code> - launches the editor with your game attached, the editor allows you to run your game
from it and edit game entities. It is intended to be used only for development.</li>
<li><code>cargo run --package executor --release</code> - creates and runs the production binary of your game that can be shipped (for
example - to a store).</li>
</ul>
<p>Navigate to your project's directory and run <code>cargo run --package editor --release</code>, after some time you should see the 
editor:</p>
<p><img src="fyrox/beginning/editor.png" alt="editor" /></p>
<p>In the editor you can start making your game scene. <strong>Important note:</strong> your scene must have at least one camera,
otherwise you won't see anything. Read the next chapter to learn how to use the editor.</p>
<h2 id="using-latest-engine-version"><a class="header" href="#using-latest-engine-version">Using Latest Engine Version</a></h2>
<p>Due to the nature of the software development, some bugs are inevitably sneak in the major releases. Due to this fact, 
you may want to use the latest engine version from its repository on GitHub, because it most likely has some bugs fixed
(you can also help fixing any bugs you find or at least <a href="https://github.com/FyroxEngine/Fyrox/issues">file an issue</a>).
To do this, you need to specify paths for <code>fyrox</code> and <code>fyroxed_base</code> dependencies to point them on remote repository.
There are three places where you need to do this: <code>game</code>, <code>executor</code>, <code>editor</code> projects. At first open <code>game/Cargo.toml</code> 
and change <code>fyrox</code> dependency to this:</p>
<pre><code class="language-toml">[dependencies]
fyrox = { git = &quot;https://github.com/FyroxEngine/Fyrox&quot; }
</code></pre>
<p>Do the same for <code>executor/Cargo.toml</code>. The <code>editor</code> has two dependencies we need to change <code>fyrox</code> and <code>fyroxed_base</code>.
Open the <code>editor/Cargo.toml</code> and set both <code>fyrox</code> and <code>fyroxed_base</code> dependencies to the following:</p>
<pre><code class="language-toml">[dependencies]
fyrox = { git = &quot;https://github.com/FyroxEngine/Fyrox&quot; }
fyroxed_base = { git = &quot;https://github.com/FyroxEngine/Fyrox&quot; }
</code></pre>
<p>Now your game will use the latest engine and editor, but beware - there could be some API breaks. You can avoid this by 
specifying a particular commit, just add <code>rev = &quot;desired_commit_hash&quot;</code> to every dependency like so:</p>
<pre><code class="language-toml">[dependencies]
fyrox = { git = &quot;https://github.com/FyroxEngine/Fyrox&quot;, rev = &quot;0195666b30562c1961a9808be38b5e5715da43af&quot; }
fyroxed_base = { git = &quot;https://github.com/FyroxEngine/Fyrox&quot;, rev = &quot;0195666b30562c1961a9808be38b5e5715da43af&quot; }
</code></pre>
<p>To keep local git repository of the engine up-to-date, you just need to call <code>cargo update</code> in the root of project's
workspace. This will pull the latest changes from remote (unless there is no <code>rev</code> specified).</p>
<p>Learn more about dependency paths in the official <code>cargo</code> documentation 
<a href="https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#specifying-dependencies-from-git-repositories">here</a>.</p>
<h2 id="adding-game-logic"><a class="header" href="#adding-game-logic">Adding Game Logic</a></h2>
<p>Any object-specific game logic should be added using scripts. Script is a &quot;container&quot; for data and code, that will be
executed by the engine. Read <a href="fyrox/beginning/../scripting/script.html">Scripts</a> chapter to learn how to create, edit, and use scripts in
your game.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fyroxed-overview"><a class="header" href="#fyroxed-overview">FyroxEd Overview</a></h1>
<p>FyroxEd - is the native editor of Fyrox, it is made for one purpose - be integrated game development environment,
that allows you to build your game from start to finish with relatively low effort.</p>
<p>You'll be spending a lot of time in the editor (FyroxEd), so you should get familiar with it and learn how to use its 
basic functionality. This chapter will guide you through basics, advanced topics will be covered in respective chapters.</p>
<h2 id="windows"><a class="header" href="#windows">Windows</a></h2>
<p>Once the editor is open for the first time, it will confuse you by amount of windows, buttons, lists, etc. Each window
serves for different purpose, but all of them works together to help you make your game. Let's look at the editor's
screenshot and learn what parts of it responsible for what (please note that it can change over time, because the 
development is quite rapid and image can become outdated pretty easily):</p>
<p><img src="fyrox/beginning/./overview.png" alt="Windows" /></p>
<ol>
<li><strong>World viewer</strong> - shows every object in the scene and their relations. It allows you to inspect and edit the 
contents of the scene in hierarchical form.</li>
<li><strong>Scene preview</strong> - renders your scene with debug info and various editor-specific objects (like gizmos and
stuff). Allows you to select, move, rotate, scale, delete, etc. various entities.</li>
<li><strong>Toolbar</strong> - shows available context-dependent tools.</li>
<li><strong>Inspector</strong> - allows you to modify various properties of selected object.</li>
<li><strong>Message log</strong> - shows the important messages from the editor.</li>
<li><strong>Navmesh panel</strong> - allows you to create/delete and edit navigational meshes.</li>
<li><strong>Command stack</strong> - shows the most recent actions you've done, allows you to undo and redo the changes on demand.</li>
<li><strong>Asset browser</strong> - inspects the assets of your game, allows you to instantiate resources in the scene and so on.</li>
</ol>
<h2 id="creating-loading-a-scene"><a class="header" href="#creating-loading-a-scene">Creating (Loading) a Scene</a></h2>
<p>FyroxEd works with scenes - scene is a container for game entities, you can create and edit one scene at a time. You
must have a scene created (or loaded) to begin working with the editor. To create a scene click <code>File -&gt; New Scene</code>.</p>
<p>To load existing scene, go to <code>File -&gt; Load</code> and select desired scene using file browser.</p>
<h2 id="populating-your-scene"><a class="header" href="#populating-your-scene">Populating Your Scene</a></h2>
<p>Scene can be filled with various objects, there are two equivalent ways of creating game entities:</p>
<ul>
<li>By clicking <code>Create</code> main menu item and selecting desired entity.</li>
<li>By right-clicking on a game entity in <code>World Viewer</code> and selecting desired entity from <code>Add Child</code> sub-menu.</li>
</ul>
<h2 id="saving-scene"><a class="header" href="#saving-scene">Saving Scene</a></h2>
<p>To save your work, go to <code>File -&gt; Save</code>. For the first time (for unsaved scene), the editor will ask you to specify 
file name and path to a folder where the scene will be saved. A scene loaded from a file will be automatically saved 
to the path it was loaded from.</p>
<h2 id="undoredo"><a class="header" href="#undoredo">Undo/redo</a></h2>
<p>FyroxEd remembers your actions, and it is possible to undo (or redo undone) your changes to fix some stuff in the scene.
You can undo or redo your changes either by clicking <code>Edit -&gt; Undo/Redo</code> or by standard shortcuts: <code>Ctrl+Z</code> - undo,
<code>Ctrl+Y</code> - redo.</p>
<h2 id="controls"><a class="header" href="#controls">Controls</a></h2>
<p>There are number of control keys that you'll be using most of the time, pretty much all of them works in <code>Scene Preview</code>
window:</p>
<ul>
<li><code>[Left Mouse Button]</code> - Select</li>
<li><code>[W][S][A][D]</code> - Move camera forward/backward/left/right</li>
<li><code>[Space][Q]/[E]</code> - Raise/Lower Camera</li>
<li><code>[Ctrl]</code> - speed up</li>
<li><code>[Shift]</code>- slowdown</li>
<li><code>[Middle Mouse Button]</code> to pan camera in viewing plane</li>
<li><code>[1]</code> - Select interaction mode</li>
<li><code>[2]</code> - Move interaction mode</li>
<li><code>[3]</code> - Scale interaction mode</li>
<li><code>[4]</code> - Rotate interaction mode</li>
<li><code>[Ctrl]+[Z]</code> - Undo</li>
<li><code>[Ctrl]+[Y]</code> - Redo</li>
<li><code>[Delete]</code> - deletes current selection.</li>
</ul>
<h2 id="play-mode"><a class="header" href="#play-mode">Play Mode</a></h2>
<p>One of the key features of the editor is that it allows you to run your game from it. Use <code>Play/Stop</code> button at the
top of <code>Scene Preview</code> window to enter (or leave) Play Mode. Keep in mind, that editor UI will be locked while you're
in the Play Mode. </p>
<p>Play Mode can be activated only for projects that made with <code>fyrox-template</code> (or have similar structure). The editor
calls <code>cargo</code> commands to build and run your game in a separate process. Running the game in a separate process ensures
that the editor won't crash if the game does, it also provides excellent isolation between the game and the editor, not
giving a chance to break the editor by running the game.</p>
<h2 id="additional-utilities"><a class="header" href="#additional-utilities">Additional Utilities</a></h2>
<p>There are also number of powerful utilities that will make your life easier, which works without any scene, they can be
found under <code>Utils</code> section of main menu: </p>
<ul>
<li>Animation Editor - allows you to create and editor animation blending state machines which are responsible for 
animation mixing.</li>
<li>Curve Editor - create and edit curve resources to make complex laws for game parameters.</li>
<li>Path Fixer - helps you fix incorrect resource references in your scenes.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scene-and-scene-graph"><a class="header" href="#scene-and-scene-graph">Scene and scene graph</a></h1>
<p>When you're playing a game, you often see various objects scattered around on screen, all of them forming a
<em>scene</em>. Scene is just a set of various objects, as in many other game engines, Fyrox allows you to create multiple
scenes for various purposes. For example, one scene could be used for menu, a bunch could be used for game levels,
and one for ending screen. Scenes also could be used to create a source of data for other scenes, such scenes called
<em>prefabs</em>. A scene could also be rendered in a texture, and the texture can be used in other scene - this way you
can create interactive screens that showing some other places.</p>
<p>While playing games, you could've noticed that some objects behaves like they're linked to other objects, for example
your character in a role-playing game could carry a sword. While the character holds the sword, it is linked to his
arm. Such relations between the objects could be presented by a graph structure.</p>
<p>Simply speaking, graph is a set of objects with hierarchical relationships between each object. Each object in the
graph is called <em>node</em>. In the example with the sword and the character, the sword is a <em>child</em> node of a character,
which in its turn is a <em>parent</em> node of a character. (Here we intentionally omit the fact that usually character
model contains complex skeleton with multiple bones and the sword is actually attached to one of hand's bones.)</p>
<p>You can change hierarchy of the nodes in the editor using simple drag'n'drop functionality in <code>World Viewer</code> - drag a 
node onto some other node, and it will be attached to it.</p>
<h2 id="building-blocks-or-scene-nodes"><a class="header" href="#building-blocks-or-scene-nodes">Building blocks or scene nodes</a></h2>
<p>The engine offers various types of &quot;building blocks&quot; for your scene, each such block is called <em>scene node</em>.</p>
<ul>
<li><a href="fyrox/beginning/../scene/base_node.html">Base</a> - a node that stores hierarchical information (a handle to the parent node and a set of handles
to children nodes), local and global transform, name, tag, lifetime, etc. It has self-describing name - it
is used as a base node for every other scene node (via composition).</li>
<li><a href="fyrox/beginning/../scene/mesh_node.html">Mesh</a> - a node that represents a 3D model. This one of the most commonly used nodes in almost every game.
Meshes could be easily created either programmatically, or be made in some 3D modelling software (like Blender)
and loaded in your scene.</li>
<li><a href="fyrox/beginning/../scene/light_node.html">Light</a> - a node that represents a light source. There are three types of light sources:
<ul>
<li><strong>Directional</strong> - a light source that does not have position, only direction. The closest real-world example
is our Sun.</li>
<li><strong>Point</strong> - a light source that emits light in every direction. Real-world example: light bulb.</li>
<li><strong>Spot</strong> - a light source that emits light in a particular direction with a cone-like shape. Real-world example:
flashlight.</li>
</ul>
</li>
<li><a href="fyrox/beginning/../scene/camera_node.html">Camera</a> - a node that allows you to see the world. You must have at least one camera in your scene to be
able to see anything.</li>
<li><a href="fyrox/beginning/../scene/sprite_node.html">Sprite</a> - a node that represents a quad that always faced towards a camera. It can have a texture, size, it
also can be rotated around the &quot;look&quot; axis.</li>
<li><a href="fyrox/beginning/../scene/particle_system_node.html">Particle system</a> - a node that allows you to build visual effects using a huge set of small particles, it
can be used to create smoke, sparks, blood splatters, etc. effects.</li>
<li><a href="fyrox/beginning/../scene/terrain_node.html">Terrain</a> - a node that allows you to create complex landscapes with minimal effort.</li>
<li><a href="fyrox/beginning/../scene/decal_node.html">Decal</a> - a node that paints on other nodes using a texture. It is used to simulate cracks in concrete walls,
damaged parts of the road, blood splatters, bullet holes, etc.</li>
<li><a href="fyrox/beginning/../physics/rigid_body.html">Rigid Body</a> - a physical entity that is responsible for dynamic of the rigid. There is a special variant
for 2D - <code>RigidBody2D</code>.</li>
<li><a href="fyrox/beginning/../physics/collider.html">Collider</a> - a physical shape for a rigid body, it is responsible for contact manifold generation, 
without it any rigid body will not participate in simulation correctly, so every rigid body must have at least
one collider. There is a special variant for 2D - <code>Collider2D</code>.</li>
<li><a href="fyrox/beginning/../physics/joint.html">Joint</a> - a physical entity that restricts motion between two rigid bodies, it has various amounts
of degrees of freedom depending on the type of the joint. There is a special variant for 2D - <code>Joint2D</code>.</li>
<li><a href="fyrox/beginning/../scene/rectangle.html">Rectangle</a> - a simple rectangle mesh that can have a texture and a color, it is a very simple version of 
a Mesh node, yet it uses very optimized renderer, that allows you to render dozens of rectangles simultaneously.
This node is intended to be used for <strong>2D games</strong> only.</li>
<li><a href="fyrox/beginning/../sound/sound.html">Sound</a> - a sound source, it is universal for 2D and 3D. Spatial blend factor allows you to select
a proportion between 2D and 3D.</li>
</ul>
<p>Each of the node could be created either from the editor (<code>Create</code> on main menu) or programmatically via respective
node builder. These scene nodes allow you to build almost any kind of game. It is also possible to create your own 
types of nodes, but this is advanced topic, and it will be covered in <a href="fyrox/beginning/../scene/custom_node.html">next chapters</a>.</p>
<h2 id="local-and-global-coordinates"><a class="header" href="#local-and-global-coordinates">Local and global coordinates</a></h2>
<p>Graph describes your scene in a very natural way, allowing you think in terms of relative and absolute coordinates
when working with <em>scene nodes</em>.</p>
<p>Scene node has two kinds of transform - local and global. Local transform defines where the node is located
(translation) relative to origin, how much it is scaled (in percent) and rotated (around any arbitrary axis).
Global transform is almost the same, but it also includes the whole chain of transforms of parent nodes. In the
previous example with the character, the sword has its own local transform which tells how much it should be
moved from origin to be exactly on a hand of the character. But global transform of the swords includes transform
of the entire character. So if you move the character, the local transform of the sword will remain the same, but
global transform will include the transform of the character.</p>
<p>This mechanism is very simple, yet powerful. The full grace of it unfolds when you're working with 3D models with
skeleton, each bone in the skeleton has its parent and a set of children. You can rotate/translate/scale bones to
animate your character.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="assets"><a class="header" href="#assets">Assets</a></h1>
<p>Pretty much every game depends on various assets such as 3D models, textures, sounds, etc. The engine has its own 
assets pipeline that is made to make your life easier. </p>
<h2 id="asset-types"><a class="header" href="#asset-types">Asset Types</a></h2>
<p>The engine offers a fixed set of assets that should cover all your needs:</p>
<ul>
<li><a href="fyrox/beginning/../resources/model.html">Models</a> - model is a set of objects, it can be a simple 3D model (like barrel, bush, weapon, 
etc.) or complex scene with lots of object and possibly other model instances. There are two main formats supported:
FBX - could be used to import 3D models, RGS - a scene that is made in Fyroxed. RGS models are special, they can be 
used as <em>hierarchical prefabs</em>.</li>
<li><a href="fyrox/beginning/../resources/texture.html">Textures</a> - texture is an image that is used to add graphical details to objects. The
engine supports various texture formats such as PNG, JPG, BMP, etc. There is also support for compressed textures in
DDS format.</li>
<li><a href="fyrox/beginning/../resources/sound.html">Sound buffers</a> - a data buffer for sound sources. The engine supports WAV and OGG formats. </li>
<li><a href="fyrox/beginning/../resources/curve.html">Curves</a> - parametric curve. It is used to create complex functions for numeric parameters.
Curves can be made in <code>Curve Editor</code> (<code>Utils -&gt; Curve Editor</code>)</li>
<li><a href="fyrox/beginning/../resources/absm.html">Animation Machines</a> - animation blending state machines (ABSM) - allows you to blend multiple 
animations into one to create complex animations. ABSM can be made in <code>Animation Editor</code> (<code>Utils -&gt; Animation Editor</code>)</li>
</ul>
<h2 id="asset-management"><a class="header" href="#asset-management">Asset Management</a></h2>
<p>Asset management is performed from <code>Asset Browser</code> window in the editor, you can select an asset, preview it and edit
its import options. Here's the asset browser with a texture selected:</p>
<p><img src="fyrox/beginning/assets.png" alt="asset browser" /></p>
<p>The most interesting part here is import options section under previewer, it allows to set asset-specific import options
and apply it. Every asset has its own set of import options. Check respective asset page from above section to learn
what import options is for what.</p>
<h2 id="asset-instantiation"><a class="header" href="#asset-instantiation">Asset Instantiation</a></h2>
<p>Some asset types can be instantiated in scene, for now you can create direct instance only from models. This
is done by simple drag'n'drop - find a model you want to instantiate and drag it <code>Scene Preview</code>. The instance should
appear in the <code>Scene Preview</code> once you release left mouse button. The amount of asset instance is not limited, it 
only depends on capabilities of your PC, each instance takes some memory (the engine tries to re-use data across
instance as much as possible) and CPU resources.</p>
<p>You can also instantiate assets dynamically from your code, here's an example for Model:</p>
<pre><pre class="playground"><code class="language-rust no_run edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    engine::resource_manager::ResourceManager,
</span><span class="boring">    scene::{node::Node, Scene},
</span><span class="boring">};
</span><span class="boring">use std::path::Path;
</span>async fn instantiate_model(
    path: &amp;Path,
    resource_manager: ResourceManager,
    scene: &amp;mut Scene,
) -&gt; Handle&lt;Node&gt; {
    // Load model first. Alternatively, you can store resource handle somewhere and use it for
    // instantiation.
    let model = resource_manager.request_model(path).await.unwrap();

    model.instantiate(scene).root
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="loading-assets"><a class="header" href="#loading-assets">Loading Assets</a></h2>
<p>Usually there is no need to manually handle assets loading, since you have the editor that can help you with that - create
a scene with all required assets. However, sometimes you need to instantiate an asset dynamically - for example a
bot prefab. In this case you can use <code>ResourceManager</code> and respective set of methods (like <code>request_model</code>, 
<code>request_texture</code>, etc.). See respective asset page for more info.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="data-management"><a class="header" href="#data-management">Data management</a></h1>
<p>The engine uses generation arenas (pools in engine's terminology) for efficient data management. Pool is a
vector with entries that can be either vacant or occupied. Each entry, no matter occupied or vacant, also
stores a special number called <em>generation</em>. The generation number is used to understand whether an entry has
been changed over time or not. When an entry is reused, its generation number is increased leaving all previously
created handle leading to the entry invalid. This is a very simple and efficient algorithm for tracking the
&quot;lifetime&quot; of the objects.</p>
<p>To access the data in entries, the engine uses <em>handles</em>. The handle is a pair of index of an entry and a
<em>generation</em> number. When you put an object in the pool, it gives you the handle that &quot;leads&quot; to the object.
At this moment the generation of the handle matches the generation of the corresponding entry so the handle
is valid. It will remain valid until you &quot;free&quot; the object, which will make the entry vacant again.</p>
<h2 id="advantages"><a class="header" href="#advantages">Advantages</a></h2>
<p>Since the pool is just a contiguous memory block, it is much more CPU cache-friendly. This means that in most
cases the data portions will be loaded in CPU caches, making the access to the data blazing fast.</p>
<p>Almost every entity in the engine &quot;lives&quot; in its own pool, this make it easy to create such data structures
like graphs, where a node refers to other nodes. In this case scene nodes stores just handles (which is just
8 bytes of memory) to other nodes.</p>
<h2 id="borrowing"><a class="header" href="#borrowing">Borrowing</a></h2>
<p>Once an object was placed in a pool, you have to use respective handle to get a reference to it. This could 
be done either with <code>.borrow[_mut](handle)</code> or by using <code>Index</code> trait: <code>pool[handle]</code>. These methods panic
when handle is invalid, if you want to prevent that, use <code>try_borrow[_mut](handle)</code> method.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::core::pool::Pool;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>let mut pool = Pool::&lt;u32&gt;::new();
let handle = pool.spawn(1);

let obj = pool.borrow_mut(handle);
*obj = 11;

let obj = pool.borrow(handle);
assert_eq!(*obj, 11);
<span class="boring">}
</span></code></pre></pre>
<h2 id="freeing"><a class="header" href="#freeing">Freeing</a></h2>
<p>You can extract an object from a pool by calling <code>pool.free(handle)</code>, it will give you the object back, making
all handles to the object invalid.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::core::pool::Pool;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>let mut pool = Pool::&lt;u32&gt;::new();
let handle = pool.spawn(1);

pool.free(handle);

let obj = pool.try_borrow(handle);
assert_eq!(obj, None);
<span class="boring">}
</span></code></pre></pre>
<h2 id="take--reserve"><a class="header" href="#take--reserve">Take &amp; reserve</a></h2>
<p>Sometimes you may need to temporarily extract an object from a pool, do something with it and then put it back
while preserving handles to that object. There are three special methods for that:</p>
<ol>
<li><code>take_reserve</code> + <code>try_take_reserve</code> - moves object out of the pool, but leaves the entry in &quot;occupied&quot; state. This function returns
a tuple with two values <code>(Ticket&lt;T&gt;, T)</code>. The latter value is obviously your object, but the former is 
more interesting. It is a special wrapper over object index that allows you to return the object back. It is used
in <code>put_back</code> method. <strong>Caveat:</strong> an attempt to borrow moved object in the pool will cause panic! </li>
<li><code>put_back</code> - moves the object back in the pool using given ticket. Ticket says where to put the object in the 
pool. </li>
<li><code>forget_ticket</code> - makes the entry of the pool vacant again. It is useful in situations when you've moved object
out of the pool, but for some reason you don't want to return it back in pool, in this case you <strong>must</strong> call
this method, otherwise the corresponding entry will be unusable.</li>
</ol>
<p>Reservation example:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::core::pool::Pool;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>let mut pool = Pool::&lt;u32&gt;::new();
let handle = pool.spawn(1);

let (ticket, ref mut obj) = pool.take_reserve(handle);

*obj = 123;

// Attempting to fetch while there is an existing reservation, will fail.

let attempt_obj = pool.try_borrow(handle);
assert_eq!(attempt_obj, None);

// Put back, allowing borrowing again.

pool.put_back(ticket, *obj);

let obj = pool.borrow(handle);

assert_eq!(obj, &amp;123);
<span class="boring">}
</span></code></pre></pre>
<p>Forget example:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::core::pool::Pool;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>let mut pool = Pool::&lt;u32&gt;::new();
let handle = pool.spawn(1);

let (ticket, _obj) = pool.take_reserve(handle);

pool.forget_ticket(ticket);

let obj = pool.try_borrow(handle);

assert_eq!(obj, None);
<span class="boring">}
</span></code></pre></pre>
<h2 id="iterators"><a class="header" href="#iterators">Iterators</a></h2>
<p>There are few possible iterators, each one is useful for a particular purpose:</p>
<ol>
<li><code>iter/iter_mut</code> - creates an iterator that iterates over occupied pool entries returning references to an 
object associated with an entry.</li>
<li><code>pair_iter/pair_iter_mut</code> - creates an iterator that iterates over occupied pool entries returning tuples with
two elements <code>(handle, reference)</code>. </li>
</ol>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::core::pool::Pool;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>let mut pool = Pool::&lt;u32&gt;::new();
let _handle = pool.spawn(1);

let mut iter = pool.iter_mut();

let next_obj = iter.next().unwrap();

assert_eq!(next_obj, &amp;1);

let next_obj = iter.next();

assert_eq!(next_obj, None);
<span class="boring">}
</span></code></pre></pre>
<h2 id="direct-access"><a class="header" href="#direct-access">Direct access</a></h2>
<p>There is ability to get an object from a pool using only indices, there are two methods for that <code>at</code> and <code>at_mut</code>.</p>
<h2 id="validation"><a class="header" href="#validation">Validation</a></h2>
<p>Sometimes you may need to check if a handle is valid, to do that use <code>is_valid_handle</code> method.</p>
<h2 id="type-erased-handles"><a class="header" href="#type-erased-handles">Type-erased handles</a></h2>
<p>The pool module offers type-erased handles that could be useful for some situations. Try to avoid using type-erased
handles, because they may introduce hardly-reproducible bugs. Type safety is always good :)</p>
<p>Type-erased handle is called <code>ErasedHandle</code> and it can be created either manually, or from strongly-typed handles.
Both handle types are interchangeable, you can use <code>From</code> and <code>Into</code> traits to convert them one into another.</p>
<h2 id="special"><a class="header" href="#special">Special</a></h2>
<p>Uncategorized stuff.</p>
<h3 id="getting-a-handle-of-an-object-by-its-reference"><a class="header" href="#getting-a-handle-of-an-object-by-its-reference">Getting a handle of an object by its reference</a></h3>
<p>Sometimes you may need to get a handle of an object having only a reference to it, there is a <code>handle_of</code> method
exactly for that.</p>
<h3 id="iterate-over-and-discard-unnecessary-objects"><a class="header" href="#iterate-over-and-discard-unnecessary-objects">Iterate over and discard unnecessary objects</a></h3>
<p>There is a <code>retain</code> method for that, it allows you to &quot;filter&quot; your pool using a closure with custom filtering
logic.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scripting"><a class="header" href="#scripting">Scripting</a></h1>
<p>A game based on Fyrox is a plugin to the engine and the editor. Plugin defines global application logic and can provide
a set of scripts, that can be used to assign custom logic to scene nodes. Every script can be attached to only one 
plugin.</p>
<p>Fyrox uses scripts to create custom game logic, scripts can be written only in Rust which ensures that your game will
be crash-free, fast and easy to refactor.</p>
<p>Next chapters will cover all parts and will help you to learn how to use plugins + scripts correctly.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="plugins"><a class="header" href="#plugins">Plugins</a></h1>
<p>A game based on Fyrox is a plugin to the engine and the editor. Plugin defines global application logic and provides
a set of scripts, that can be used to assign custom logic to scene nodes. Every script belongs to only one plugin.</p>
<p>Plugin is an &quot;entry point&quot; of your game, it has a fixed set of methods that can be used for initialization, update,
OS event handling, etc. Every plugin is statically linked to the engine (editor), there is no support for hot-reloading
due to lack of stable ABI in Rust.</p>
<p>The main purpose of the plugins is to hold and operate on some global application data, that can be used in scripts and
provide a set of scripts to the engine.</p>
<h2 id="structure"><a class="header" href="#structure">Structure</a></h2>
<p>Plugin structure is defined by <a href="https://docs.rs/fyrox/latest/fyrox/plugin/trait.Plugin.html">Plugin</a> trait. Typical
implementation can be generated by <code>fyrox-template</code> tool, and it looks something like this:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span>use fyrox::{
    core::{
        futures::executor::block_on,
        pool::Handle,
        uuid::{uuid, Uuid},
    },
    event::Event,
    event_loop::ControlFlow,
    gui::message::UiMessage,
    plugin::{Plugin, PluginConstructor, PluginContext, PluginRegistrationContext},
    scene::{node::TypeUuidProvider, Scene, SceneLoader},
};

pub struct GameConstructor;

impl TypeUuidProvider for GameConstructor {
    fn type_uuid() -&gt; Uuid {
        uuid!(&quot;f615ac42-b259-4a23-bb44-407d753ac178&quot;)
    }
}

impl PluginConstructor for GameConstructor {
    fn register(&amp;self, _context: PluginRegistrationContext) {
        // Register your scripts here.
    }

    fn create_instance(
        &amp;self,
        override_scene: Handle&lt;Scene&gt;,
        context: PluginContext,
    ) -&gt; Box&lt;dyn Plugin&gt; {
        Box::new(Game::new(override_scene, context))
    }
}

pub struct Game {
    scene: Handle&lt;Scene&gt;,
}

impl Game {
    pub fn new(override_scene: Handle&lt;Scene&gt;, context: PluginContext) -&gt; Self {
        let scene = if override_scene.is_some() {
            override_scene
        } else {
            // Load a scene from file if there is no override scene specified.
            let scene = block_on(
                block_on(SceneLoader::from_file(
                    &quot;data/scene.rgs&quot;,
                    context.serialization_context.clone(),
                ))
                    .unwrap()
                    .finish(context.resource_manager.clone()),
            );

            context.scenes.add(scene)
        };

        Self { scene }
    }
}

impl Plugin for Game {
    fn on_deinit(&amp;mut self, _context: PluginContext) {
        // Do a cleanup here.
    }

    fn update(&amp;mut self, _context: &amp;mut PluginContext, _control_flow: &amp;mut ControlFlow) {
        // Add your global update code here.
    }

    fn id(&amp;self) -&gt; Uuid {
        GameConstructor::type_uuid()
    }

    fn on_os_event(
        &amp;mut self,
        _event: &amp;Event&lt;()&gt;,
        _context: PluginContext,
        _control_flow: &amp;mut ControlFlow,
    ) {
        // Do something on OS event here.
    }

    fn on_ui_message(
        &amp;mut self,
        _context: &amp;mut PluginContext,
        _message: &amp;UiMessage,
        _control_flow: &amp;mut ControlFlow,
    ) {
        // Handle UI events here.
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>There are two major parts - <code>GameConstructor</code> and <code>Game</code> itself. <code>GameConstructor</code> implements <code>PluginConstructor</code> and it
is responsible for script registration (<code>fn register</code>) and creating the actual game instance (<code>fn create_instance</code>).</p>
<ul>
<li><code>register</code> - called once on start allowing you to register your scripts. Please note that you must register all your
scripts here, otherwise the engine will know nothing about them.</li>
<li><code>create_instance</code> - called once, allowing you to create actual game instance. It is guaranteed to be called once, but 
<em>where</em> it is called is implementation-defined. For example, the editor will <strong>not</strong> call this method, it does not 
create any game instance. The method has <code>override_scene</code> parameter, in short it is a handle to a scene that must be 
used by your game instead of any other scenes. It is described in <code>Editor and Plugins</code> section down below.</li>
</ul>
<p>The game instance (<code>struct Game</code>) implements a <code>Plugin</code> trait which can execute actual game logic in one of its methods:</p>
<ul>
<li><code>on_deinit</code> - it is called when the game is about to shut down. Can be used for any clean up, for example logging that
the game has closed.</li>
<li><code>update</code> - it is called each frame at a stable rate (usually 60 Hz) after the plugin is created and fully initialized.
It is the main place where you should put <em>object-independent</em> game logic, any other logic should be added via scripts.</li>
<li><code>on_os_event</code> - it is called when the main application window receives an event from operating system, it can be 
any event such as keyboard, mouse, game pad events or any other events. Please note that as for <code>update</code> method, you
should put here only <em>object-independent</em> logic. Scripts can catch window events too.</li>
<li><code>on_ui_message</code> - it is called when there is a message from the user interface, it should be used to react to user
actions (like pressed buttons, etc.)</li>
<li><code>id</code> - utility method that should return stable id of the plugin.</li>
</ul>
<h2 id="control-flow"><a class="header" href="#control-flow">Control Flow</a></h2>
<p>Some plugin methods provide access to <code>ControlFlow</code> variable, its main usage in the plugin is to give you ability to
stop the game by some conditions. All you need to do is to set it to <code>ControlFlow::Exit</code> and the game will be closed.
It also has other variants, but they don't have any particular usage in the plugins.</p>
<pre><pre class="playground"><code class="language-rust compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn update(&amp;mut self, _context: &amp;mut PluginContext, control_flow: &amp;mut ControlFlow) {
    if self.some_exit_condition {
        control_flow = ControlFlow::Exit;
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="plugin-context"><a class="header" href="#plugin-context">Plugin Context</a></h2>
<p>Vast majority of methods accept <code>PluginContext</code> - it provides almost full access to engine entities, it has access
to the renderer, scenes container, resource manager, user interface, main application window. Typical content of the
context is something like this:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    engine::{resource_manager::ResourceManager, SerializationContext},
</span><span class="boring">    gui::UserInterface,
</span><span class="boring">    renderer::Renderer,
</span><span class="boring">    scene::SceneContainer,
</span><span class="boring">    window::Window,
</span><span class="boring">};
</span><span class="boring">use std::sync::Arc;
</span>pub struct PluginContext&lt;'a&gt; {
    pub scenes: &amp;'a mut SceneContainer,
    pub resource_manager: &amp;'a ResourceManager,
    pub user_interface: &amp;'a mut UserInterface,
    pub renderer: &amp;'a mut Renderer,
    pub dt: f32,
    pub serialization_context: &amp;'a Arc&lt;SerializationContext&gt;,
    pub window: &amp;'a Window,
}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li><code>scenes</code> - should be used to manage game scenes, an example of scene loading is given in the previous code snipped in
<code>Game::new()</code> method.</li>
<li><code>resource_manager</code> - is used to load external resources (scenes, models, textures, animations, source, etc.) from
different sources (disk, network storage, etc.)</li>
<li><code>user_interface</code> - use it to create user interface for your game, the interface is scene-independent and will remain
the same even if there are multiple scenes created.</li>
<li><code>renderer</code> - can be used to add custom rendering techniques, change quality settings, etc.</li>
<li><code>dt</code> - a time passed since last frame. The actual value is implementation-defined, but on current implementation it
is equal to 1/60 of second and does not change event if the frame rate is changing.</li>
<li><code>serialization_context</code> - it can be used to register script and custom scene nodes constructors and at runtime.</li>
<li><code>window</code> - main application window, you can use it to change title, resolution, etc.</li>
</ul>
<h2 id="editor-and-plugins"><a class="header" href="#editor-and-plugins">Editor and Plugins</a></h2>
<p>When you're running your game from the editor, it starts the game as a separate process and if there's a scene opened
in the editor, it tells the game instance to load it on startup. Let's look closely at <code>Game::new</code> method:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::{futures::executor::block_on, pool::Handle},
</span><span class="boring">    plugin::PluginContext,
</span><span class="boring">    scene::{Scene, SceneLoader},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">struct Foo {
</span><span class="boring">    scene: Handle&lt;Scene&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Foo {
</span>pub fn new(override_scene: Handle&lt;Scene&gt;, context: PluginContext) -&gt; Self {
    let scene = if override_scene.is_some() {
        override_scene
    } else {
        // Load a scene from file if there is no override scene specified.
        let scene = block_on(
            block_on(SceneLoader::from_file(
                &quot;data/scene.rgs&quot;,
                context.serialization_context.clone(),
            ))
                .unwrap()
                .finish(context.resource_manager.clone()),
        );

        context.scenes.add(scene)
    };

    Self { scene }
}
<span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p>The <code>override_scene</code> parameter is a handle to another scene instances that is currently opened in the editor, your game
plugin must handle this parameter and use provided scene, otherwise the run from the editor will not have the edited
scene. If the parameter is undefined (equals to <code>Handle::NONE</code>), then there is no scene loaded in the editor or the
game was run outside the editor.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="executor"><a class="header" href="#executor">Executor</a></h1>
<p>Executor is a simple wrapper that drives your game plugins, it is intended to be used for production builds of your game.
The editor runs the executor in separate process when you entering play mode. Basically, there is no significant 
difference between running the game from the editor, or running it as a separate application. The main difference is that
the editor passes <code>override_scene</code> parameter for the executor when entering the play mode.</p>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<p>Executor is meant to be a part of your project's workspace, its typical look could something like this:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::{pool::Handle, uuid::Uuid},
</span><span class="boring">    engine::executor::Executor,
</span><span class="boring">    plugin::{Plugin, PluginConstructor, PluginContext},
</span><span class="boring">    scene::{node::TypeUuidProvider, Scene},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">struct GameConstructor;
</span><span class="boring">impl PluginConstructor for GameConstructor {
</span><span class="boring">    fn create_instance(
</span><span class="boring">        &amp;self,
</span><span class="boring">        _override_scene: Handle&lt;Scene&gt;,
</span><span class="boring">        _context: PluginContext,
</span><span class="boring">    ) -&gt; Box&lt;dyn Plugin&gt; {
</span><span class="boring">        todo!()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl TypeUuidProvider for GameConstructor {
</span><span class="boring">    fn type_uuid() -&gt; Uuid {
</span><span class="boring">        todo!()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let mut executor = Executor::new();
    // Register your game constructor here.
    executor.add_plugin_constructor(GameConstructor);
    executor.run()
}
</code></pre></pre>
<p>Executor has full access to the engine, and through it to the main application window. You can freely change desired
parts, <code>Executor</code> implements <code>Deref&lt;Target = Engine&gt; + DerefMut</code> traits, so you can use its instance as an &quot;alias&quot;
to engine instance. </p>
<p>To add a plugin to the executor, just use <code>add_plugin_constructor</code> method, it accepts any entity that implements
<code>PluginConstructor</code> + <code>TypeUuidProvider</code> traits.</p>
<h2 id="typical-use-cases"><a class="header" href="#typical-use-cases">Typical Use Cases</a></h2>
<p>This section covers typical use cases for the <code>Executor</code>.</p>
<h3 id="setting-window-title"><a class="header" href="#setting-window-title">Setting Window Title</a></h3>
<p>You can set window title by accessing window instance and calling <code>set_title</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::engine::executor::Executor;
</span><span class="boring">let mut executor = Executor::new();
</span>executor.get_window().set_title(&quot;My Game&quot;);
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scripts"><a class="header" href="#scripts">Scripts</a></h1>
<p>Script - is a container for game data and logic that can be assigned to a scene node. Fyrox uses Rust for scripting, 
so scripts are as fast as native code. </p>
<h2 id="script-structure"><a class="header" href="#script-structure">Script Structure</a></h2>
<p>Typical script structure could be like this:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::{inspect::prelude::*, uuid::{Uuid, uuid}, visitor::prelude::*, reflect::Reflect},
</span><span class="boring">    engine::resource_manager::ResourceManager,
</span><span class="boring">    event::Event, impl_component_provider,
</span><span class="boring">    scene::{graph::map::NodeHandleMap, node::TypeUuidProvider},
</span><span class="boring">    script::{ScriptContext, ScriptDeinitContext, ScriptTrait},
</span><span class="boring">};
</span><span class="boring">struct GameConstructor;
</span><span class="boring">impl GameConstructor {
</span><span class="boring">    fn type_uuid() -&gt; Uuid { todo!() } 
</span><span class="boring">}
</span>#[derive(Visit, Reflect, Inspect, Default, Debug, Clone)]
struct MyScript {
    // Add fields here.
}

impl_component_provider!(MyScript);

impl TypeUuidProvider for MyScript {
    fn type_uuid() -&gt; Uuid {
        uuid!(&quot;bf0f9804-56cb-4a2e-beba-93d75371a568&quot;)
    }
}

impl ScriptTrait for MyScript {
    fn on_init(&amp;mut self, context: ScriptContext) {
        // Put initialization logic here.
    }

    fn on_deinit(&amp;mut self, context: ScriptDeinitContext) {
        // Put de-initialization logic here.
    }

    fn on_os_event(&amp;mut self, event: &amp;Event&lt;()&gt;, context: ScriptContext) {
        // Respond to OS events here.
    }

    fn on_update(&amp;mut self, context: ScriptContext) {
        // Put object logic here.
    }

    fn remap_handles(&amp;mut self, old_new_mapping: &amp;NodeHandleMap) {
        // Remap handles to other scene nodes here.
    }

    fn restore_resources(&amp;mut self, resource_manager: ResourceManager) {
        // Restore resource handles here.
    }

    fn id(&amp;self) -&gt; Uuid {
        Self::type_uuid()
    }

    fn plugin_uuid(&amp;self) -&gt; Uuid {
        GameConstructor::type_uuid()
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Each script must implement following traits:</p>
<ul>
<li><code>Visit</code> implements serialization/deserialization functionality, it is used by the editor to save your object to a 
scene file.</li>
<li><code>Inspect</code> implements read-only static reflection that provides introspection for your type - in other words, it allows
the editor to &quot;see&quot; what's inside your structures.</li>
<li><code>Debug</code> - provides debugging functionality, it is mostly for the editor to let it print stuff into the console.</li>
<li><code>Clone</code> - makes your structure clone-able, since we can clone objects, we also want the script instance to be 
cloned.</li>
<li><code>Default</code> implementation is very important - the scripting system uses it to create your scripts in the default state.
This is necessary to set some data to it and so on. If it's a special case, you can always implement your own <code>Default</code>'s
implementation if it's necessary for your script.</li>
<li><code>TypeUuidProvider</code> is used to attach some unique id for your type, every script *<em>must</em> have a unique ID, otherwise, the engine will
not be able to save and load your scripts. To generate a new UUID, use <a href="https://www.uuidgenerator.net/">Online UUID Generator</a> or
any other tool that can generate UUIDs.</li>
</ul>
<h2 id="script-template-generator"><a class="header" href="#script-template-generator">Script Template Generator</a></h2>
<p>You can use <code>fyrox-template</code> tool to generate all required boilerplate code for a new script, it makes adding new scripts
much less frustrating. To generate a new script use <code>script</code> command:</p>
<pre><code class="language-shell">fyrox-template script --name MyScript
</code></pre>
<p>It will create a new file in <code>game/src</code> directory with <code>my_script.rs</code> name and fill with required code. Comments should
help you to figure out which code should be placed where.</p>
<h2 id="script-registration"><a class="header" href="#script-registration">Script Registration</a></h2>
<p>Every script must be registered before use, otherwise the engine won't &quot;see&quot; your script and won't let you assign it
to an object. <code>PluginConstructor</code> trait has <code>register</code> method exactly for script registration, to register a script
you need to register it in the list of script constructors like so:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">        scene::Scene,
</span><span class="boring">        plugin::{Plugin, PluginConstructor, PluginContext, PluginRegistrationContext},
</span><span class="boring">        core::{
</span><span class="boring">            visitor::prelude::*,
</span><span class="boring">            inspect::prelude::*,
</span><span class="boring">            reflect::Reflect,  
</span><span class="boring">            pool::Handle,
</span><span class="boring">            uuid::Uuid
</span><span class="boring">        },
</span><span class="boring">        impl_component_provider,
</span><span class="boring">        scene::node::TypeUuidProvider,
</span><span class="boring">        script::ScriptTrait,
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    #[derive(Inspect, Reflect, Visit, Default, Copy, Clone, Debug)]
</span><span class="boring">    struct MyScript;
</span><span class="boring">
</span><span class="boring">    impl TypeUuidProvider for MyScript {
</span><span class="boring">        fn type_uuid() -&gt; Uuid {
</span><span class="boring">            todo!()
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl_component_provider!(MyScript);
</span><span class="boring">
</span><span class="boring">    impl ScriptTrait for MyScript {
</span><span class="boring">        fn id(&amp;self) -&gt; Uuid {
</span><span class="boring">            todo!()
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        fn plugin_uuid(&amp;self) -&gt; Uuid {
</span><span class="boring">            todo!()
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    struct Constructor;
</span><span class="boring">
</span><span class="boring">    impl PluginConstructor for Constructor {
</span>fn register(&amp;self, context: PluginRegistrationContext) {
    context.serialization_context.script_constructors.add::&lt;MyScript&gt;(&quot;My Script&quot;);
}
<span class="boring">
</span><span class="boring">        fn create_instance(&amp;self, _override_scene: Handle&lt;Scene&gt;, _context: PluginContext) -&gt; Box&lt;dyn Plugin&gt; {
</span><span class="boring">            todo!()
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="script-attachment"><a class="header" href="#script-attachment">Script Attachment</a></h2>
<p>To assign a script and see it in action, run the editor, select an object and find <code>Script</code> property in the Inspector.
Select your script from the drop-down list. To see the script in action, click &quot;Play/Stop&quot; button. The editor will run
your game in separate process with the scene active in the editor.</p>
<p>The script can be attached to a scene node from code:</p>
<pre><pre class="playground"><code class="language-rust  no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::{inspect::prelude::*, uuid::Uuid, visitor::prelude::*, reflect::Reflect},
</span><span class="boring">    impl_component_provider,
</span><span class="boring">    scene::node::{Node, TypeUuidProvider},
</span><span class="boring">    script::{Script, ScriptTrait},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">#[derive(Inspect, Reflect, Visit, Default, Copy, Clone, Debug)]
</span><span class="boring">struct MyScript;
</span><span class="boring">
</span><span class="boring">impl TypeUuidProvider for MyScript {
</span><span class="boring">    fn type_uuid() -&gt; Uuid {
</span><span class="boring">        todo!()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl_component_provider!(MyScript);
</span><span class="boring">
</span><span class="boring">impl ScriptTrait for MyScript {
</span><span class="boring">    fn id(&amp;self) -&gt; Uuid {
</span><span class="boring">        todo!()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn plugin_uuid(&amp;self) -&gt; Uuid {
</span><span class="boring">        todo!()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn set_script&lt;T: ScriptTrait&gt;(node: &amp;mut Node, script: T) {
    node.set_script(Some(Script::new(script)))
}
<span class="boring">}
</span></code></pre></pre>
<p>Initialization as well as update of newly assigned script will happen on next update tick of the engine.</p>
<h2 id="script-context"><a class="header" href="#script-context">Script Context</a></h2>
<p>Script context provides access to the environment that can be used to modify engine and game state from scripts. Typical
content of the context is something like this:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    engine::resource_manager::ResourceManager,
</span><span class="boring">    plugin::Plugin,
</span><span class="boring">    scene::{node::Node, Scene},
</span><span class="boring">};
</span>pub struct ScriptContext&lt;'a, 'b&gt; {
    pub dt: f32,
    pub plugin: &amp;'a mut dyn Plugin,
    pub handle: Handle&lt;Node&gt;,
    pub scene: &amp;'b mut Scene,
    pub resource_manager: &amp;'a ResourceManager,
}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li><code>dt</code> - amount of time passed since last frame. The value of the variable is implementation-defined, usually it is
something like 1/60 (0.016) of a second.</li>
<li><code>plugin</code> - a reference to parent plugin, it allows you to access some &quot;global&quot; game data that does not belong to any
object. For example, the plugin could store key mapping used for player controls, you can access it using <code>plugin</code> field.
You just need to cast the reference to a particular type using <code>context.plugin.cast::&lt;MyPlugin&gt;().unwrap()</code> call.</li>
<li><code>handle</code> - a handle of the node to which the script is assigned to (parent node). You can borrow the node using
<code>context.scene.graph[handle]</code> call. Typecasting can be used to obtain a reference to a particular node type.</li>
<li><code>scene</code> - a reference to parent scene of the script, it provides you full access to scene content, allowing you to
add/modify/remove scene nodes.</li>
<li><code>resource_manager</code> - a reference to resource manager, you can use it to load and instantiate assets. </li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scene"><a class="header" href="#scene">Scene</a></h1>
<p>Scene is a container for game entities. Currently, scenes in the engine manage following entities:</p>
<ol>
<li>Graph</li>
<li>Animations</li>
<li>Physics (rigid bodies, colliders, joints)</li>
<li>Sound </li>
</ol>
<p>Scene allows you to create isolated &quot;world&quot; which won't interact with other scenes, it is very useful for many
more or less complex games.</p>
<h2 id="how-to-create"><a class="header" href="#how-to-create">How to create</a></h2>
<p>A scene could be created either in Fyroxed or programmatically. You can also combine both approaches, where
you build all &quot;static&quot; content in the editor and adding rest of the entities (bots, interactive objects, etc.)
manually.</p>
<h3 id="using-fyroxed"><a class="header" href="#using-fyroxed">Using Fyroxed</a></h3>
<p>There is a <a href="fyrox/scene/../../fyrox/introduction.html">separate chapter</a> in the book that should help you to create a scene.</p>
<p>After a scene is created, you can load it as any other 3D model using the resource manager:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::{futures::executor::block_on, pool::Handle},
</span><span class="boring">    engine::resource_manager::{ResourceManager},
</span><span class="boring">    scene::{node::Node, Scene},
</span><span class="boring">};
</span><span class="boring">use std::path::Path;
</span>
fn load_scene(resource_manager: ResourceManager) -&gt; Scene {
    // Create parent scene.
    let mut scene = Scene::new();

    // Request child scene and block until it loading.
    let scene_resource = block_on(
        resource_manager
            .request_model(&quot;path/to/your/scene.rgs&quot;),
    )
        .unwrap();

    // Create an instance of the scene in the parent scene.
    let child_scene = scene_resource.instantiate_geometry(&amp;mut scene);

    scene
}
<span class="boring">}
</span></code></pre></pre>
<p>Please note that here we're creating an empty scene and only then instantiating another scene into it. Why is this
needed? </p>
<p>Child scene is considered as <a href="fyrox/scene/./prefab.html">prefab</a>, and it is &quot;instantiated&quot; in the parent scene. Considering 
it as prefab allows you modifying your scene separately and serialization/deserialization will be able to correctly
apply any changes in the scene.</p>
<h3 id="create-scene-manually"><a class="header" href="#create-scene-manually">Create scene manually</a></h3>
<p>A scene could also be created manually:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{core::pool::Handle, engine::Engine, scene::Scene};
</span>
fn create_scene(engine: &amp;mut Engine) -&gt; Handle&lt;Scene&gt; {
    let mut scene = Scene::new();

    // Use node builders, create sounds, add physics, etc. here to fill the scene.

    engine.scenes.add(scene)
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="where-all-my-scenes-located"><a class="header" href="#where-all-my-scenes-located">Where all my scenes located?</a></h2>
<p>All scenes &quot;lives&quot; in the engine, the engine has single ownership over your scene after you've added it in the engine.
You can borrow a scene at any time using its handle and do some changes.</p>
<h2 id="building-scene-asynchronously"><a class="header" href="#building-scene-asynchronously">Building scene asynchronously</a></h2>
<p>You can create your scene in separate thread and then pass it to main thread to insert it in the engine. Why this 
is needed? Remember the last time you've played a relatively large game, you've probably noticed that it have 
loading screens and loading screen has some fancy interactive stuff with progress bar. Loading screen is fully 
responsive while the game doing hard job loading the world for you. Got it already? Asynchronous scene loading is
needed to create/load large scenes with tons of resources without blocking main thread, thus leaving the game 
fully responsive. </p>
<p>There is comprehensive example of asynchronous scene loading, it can be found 
<a href="https://github.com/FyroxEngine/Fyrox/blob/master/examples/async.rs">here</a></p>
<h2 id="managing-multiple-scenes"><a class="header" href="#managing-multiple-scenes">Managing multiple scenes</a></h2>
<p>Usually you should have only one scene active (unless you're making something very special), you should use 
<code>.enabled</code> flag of a scene to turn it off or on. Deactivated scenes won't be rendered, the physics won't be
updated, the sound will stop, and so on. In other words the scene will be frozen. This is useful for situations
when you often need to switch between scenes, leaving other scene in frozen state. One of the examples where this
can be useful is menus. In most games when you're entering the menu, game world is paused. </p>
<h2 id="ambient-lighting"><a class="header" href="#ambient-lighting">Ambient lighting</a></h2>
<p>Every scene has default ambient lighting, it is defined by a single RGB color. By default, every scene has 
some pre-defined ambient lighting, it is bright enough, so you can see your objects. In some cases you may 
need to adjust it or even make it black (for horror games for instance), this can be achieved by a single
line of code:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::scene::Scene;
</span><span class="boring">use fyrox::core::color::Color;
</span><span class="boring">let mut scene = Scene::default();
</span><span class="boring">
</span>scene.ambient_lighting_color = Color::opaque(30, 30, 30); 
<span class="boring">}
</span></code></pre></pre>
<p>Please keep in mind that ambient lighting does not mean global illumination, it is a different lighting technique
which is not available in the engine yet.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="graph"><a class="header" href="#graph">Graph</a></h1>
<p>Graph is a set of objects with hierarchical relationships between each object. It is one of the most important 
entities in the engine. Graph takes care of your scene objects and does many different things for you.</p>
<h2 id="how-to-create-1"><a class="header" href="#how-to-create-1">How to create</a></h2>
<p>You don't need to create a graph manually, every scene has its own instance of the graph. It can be accessed pretty
easily: <code>scene_ref.graph</code></p>
<h2 id="adding-nodes"><a class="header" href="#adding-nodes">Adding nodes</a></h2>
<p>There are two ways of adding nodes to the graph, either using <em>node builders</em> or manually by calling <code>graph.add_node</code>.</p>
<h3 id="using-node-builders"><a class="header" href="#using-node-builders">Using node builders</a></h3>
<p>Every node in the engine has its respective builder which can be used to create an instance of the node. Using
builders is a preferable way to create scene nodes. There are following node builders:</p>
<ol>
<li><code>BaseBuilder</code> - creates an instance of base node. See <a href="fyrox/scene/./base_node.html">Base node</a> for more info.</li>
<li><code>CameraBuilder</code> - creates an instance of camera node. See <a href="fyrox/scene/./camera_node.html">Camera node</a> for more info.</li>
<li><code>MeshBuilder</code> - creates an instance of mesh node. See <a href="fyrox/scene/./mesh_node.html">Mesh node</a> for more info.</li>
<li><code>LightBuilder</code> - creates an instance of light node. See <a href="fyrox/scene/./light_node.html">Light node</a> for more info.</li>
<li><code>SpriteBuilder</code> - creates an instance of sprite node. See <a href="fyrox/scene/./sprite_node.html">Sprite node</a> for more info.</li>
<li><code>ParticleSystemBuilder</code> - creates an instance of particle system node. 
See <a href="fyrox/scene/./particle_system_node.html">Particle system node</a> for more info.</li>
<li><code>TerrainBuilder</code> - creates an instance of terrain node. See <a href="fyrox/scene/./terrain_node.html">Terrain node</a> for more info.</li>
<li><code>DecalBuilder</code> - creates an instance of decal node. See <a href="fyrox/scene/./decal_node.html">Decal node</a> for more info.</li>
<li><code>RigidBody</code> - creates an instance of rigid body node. See <a href="fyrox/scene/../physics/rigid_body.html">Rigid body</a> for more info.</li>
<li><code>Collider</code> - creates an instance of collider node. See <a href="fyrox/scene/../physics/collider.html">Rigid body</a> for more info.</li>
<li><code>Joint</code> - creates an instance of joint node. See <a href="fyrox/scene/../physics/joint.html">Rigid body</a> for more info.</li>
<li><code>Rectangle</code> - creates an instance of 2D rectangle node. See <a href="fyrox/scene/./rectangle.html">Rigid body</a> for more info.</li>
</ol>
<p>Every builder, other than <code>BaseBuilder</code>, accepts <code>BaseBuilder</code> as a parameter in <code>.new(..)</code> method. Why so?
Because every node (other than Base) is &quot;derived&quot; from Base via composition and the derived
builder must know how to build Base node. While it may sound confusing, it is actually very useful and clear.
Consider this example:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::{algebra::Vector3, pool::Handle},
</span><span class="boring">    scene::{
</span><span class="boring">        base::BaseBuilder, camera::CameraBuilder, node::Node, transform::TransformBuilder,
</span><span class="boring">        Scene,
</span><span class="boring">    },
</span><span class="boring">};
</span>
fn create_camera(scene: &amp;mut Scene) -&gt; Handle&lt;Node&gt; {
    CameraBuilder::new(
        // Here we passing a base builder. Note that, since we can build Base node separately
        // we can pass any custom values to it while building.
        BaseBuilder::new().with_local_transform(
            TransformBuilder::new()
                .with_local_position(Vector3::new(2.0, 0.0, 3.0))
                .build(),
        ),
    ) 
    // Here we just setting desired Camera properties.
    .with_fov(60.0f32.to_radians())
    .build(&amp;mut scene.graph)
}
<span class="boring">}
</span></code></pre></pre>
<p>As you can see, we're creating an instance of BaseBuilder and fill it with desired properties as well as filling
the CameraBuilder's instance properties. This is a very flexible mechanism, allowing you to build complex hierarchies
in a declarative manner:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::{algebra::Vector3, pool::Handle},
</span><span class="boring">    scene::{
</span><span class="boring">        base::BaseBuilder, camera::CameraBuilder, mesh::MeshBuilder, node::Node,
</span><span class="boring">        sprite::SpriteBuilder, transform::TransformBuilder, Scene,
</span><span class="boring">    },
</span><span class="boring">};
</span>
fn create_node(scene: &amp;mut Scene) -&gt; Handle&lt;Node&gt; {
    CameraBuilder::new(
        BaseBuilder::new()
            // Add some children nodes.
            .with_children(&amp;[
                // A staff...
                MeshBuilder::new(
                    BaseBuilder::new()
                        .with_name(&quot;MyFancyStaff&quot;)
                        .with_local_transform(
                            TransformBuilder::new()
                                .with_local_position(Vector3::new(0.5, 0.5, 1.0))
                                .build(),
                        ),
                )
                .build(&amp;mut scene.graph),
                // and a spell.
                SpriteBuilder::new(
                    BaseBuilder::new()
                        .with_name(&quot;MyFancyFireball&quot;)
                        .with_local_transform(
                            TransformBuilder::new()
                                .with_local_position(Vector3::new(-0.5, 0.5, 1.0))
                                .build(),
                        ),
                )
                .build(&amp;mut scene.graph),
            ])
            .with_local_transform(
                TransformBuilder::new()
                    .with_local_position(Vector3::new(2.0, 0.0, 3.0))
                    .build(),
            ),
    )
    .with_fov(60.0f32.to_radians())
    .build(&amp;mut scene.graph)
}
<span class="boring">}
</span></code></pre></pre>
<p>This code snippet creates a camera for first-person role-playing game's player, it will have a staff in &quot;right-hand&quot;
and a spell in the left hand. Of course all of this is very simplified, but should give you the main idea. Note
that staff and fireball will be children nodes of camera, and when setting their transform, we're actually setting
<strong>local</strong> transform which means that the transform will be relative to camera's. The staff and the spell will move
together with the camera.</p>
<h3 id="adding-a-node-manually"><a class="header" href="#adding-a-node-manually">Adding a node manually</a></h3>
<p>For some rare cases you may also want to delay adding a node to the graph, specifically for that purpose, every node 
builder has <code>.build_node</code> method which creates an instance of <code>Node</code>  but does not add it to the graph.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    scene::{base::BaseBuilder, camera::CameraBuilder, node::Node, Scene},
</span><span class="boring">};
</span>
fn create_node(scene: &amp;mut Scene) -&gt; Handle&lt;Node&gt; {
    let node: Node = CameraBuilder::new(BaseBuilder::new()).build_node();

    // We must explicitly add the node to the graph.
    scene.graph.add_node(node)
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="how-to-modify-the-hierarchy"><a class="header" href="#how-to-modify-the-hierarchy">How to modify the hierarchy</a></h2>
<p>For many cases you can't use builders to create complex hierarchy, the simplest example of such situation when 
you're creating an instance of some 3D model. If you want the instance to be a child object of some other object,
you should attach it explicitly by using <code>graph.link_nodes(..)</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::{futures::executor::block_on, pool::Handle},
</span><span class="boring">    engine::resource_manager::{ResourceManager},
</span><span class="boring">    scene::{base::BaseBuilder, camera::CameraBuilder, node::Node, Scene},
</span><span class="boring">};
</span>
fn link_weapon_to_camera(
    scene: &amp;mut Scene,
    camera: Handle&lt;Node&gt;,
    resource_manager: ResourceManager,
) {
    let weapon = block_on(
        resource_manager
            .request_model(&quot;path/to/weapon.fbx&quot;),
    )
    .unwrap()
    .instantiate_geometry(scene);

    // Link weapon to the camera.
    scene.graph.link_nodes(weapon, camera);
}
<span class="boring">}
</span></code></pre></pre>
<p>Here we've loaded a weapon 3D model, instantiated it on scene and attached to <em>existing</em> camera. </p>
<h2 id="how-to-remove-nodes"><a class="header" href="#how-to-remove-nodes">How to remove nodes</a></h2>
<p>A node could be removed by simply calling <code>graph.remove_node(handle)</code>, this method removes the node from the 
graph <strong>with all of its children nodes</strong>. Sometimes this is unwanted behaviour, and you want to preserve children
nodes while deleting parent node. To do that, you need to explicitly detach children nodes of the node you're about
to delete:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    scene::{node::Node, Scene},
</span><span class="boring">};
</span>
fn remove_preserve_children(scene: &amp;mut Scene, node_to_remove: Handle&lt;Node&gt;) {
    for child in scene.graph[node_to_remove].children().to_vec() {
        scene.graph.unlink_node(child);
    }

    scene.graph.remove_node(node_to_remove);
}
<span class="boring">}
</span></code></pre></pre>
<p>After calling this function, every child node of <code>node_to_remove</code> will be detached from it and the <code>node_to_remove</code>
will be deleted. <code>remove_node</code> has some limitations: it cannot be used to extract &quot;sub-graph&quot; from the graph, it
just drops nodes immediately. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="prefabs"><a class="header" href="#prefabs">Prefabs</a></h1>
<p>Prefab is a separate scene that can be instantiated to some other scene, while preserving links between properties
between instances and its parent prefab. Prefabs allow you to create a part of a scene and create multiple instances of
it in some other scenes.</p>
<p>Let's quickly check what that means on practice. The engine has a prefab system which allows you to build 
hierarchical scenes which can include any number of other scenes as child scenes. Child scenes can have their own child
scenes and so on. This is very efficient decoupling mechanism that allows you to put pieces of the scene in separate 
scenes (prefabs) and modify them independently. The changes in child scenes will be automatically reflected to all parent
scenes. Here is the very simple example of why this is important: imagine you need to populate a town with 3D models of
cars. Each kind of car has its own 3D model and for example, a collision body that won't allow the player to walk through
cars. How would you do this? The simplest (and dumbest) solution is to copy dozens of car models in the scene, and
you're done. Imagine that now you need to change something in your car, for example, add a trunk that can be opened.
What will you do? Of course, you should &quot;iterate&quot; over each car model and do the required changes, you simply don't have
any other option. This will eat huge amount of time and in general it is very non-productive.</p>
<p>This is where prefabs will save you hours of work. All you need to do is to create a car prefab and instantiate it
multiple times in your scene. When you'll need to change something in the car, you simply go to the prefab and change
it. After that every prefab instance will have your changes!</p>
<h2 id="how-to-create-and-use-a-prefab"><a class="header" href="#how-to-create-and-use-a-prefab">How to create and use a prefab</a></h2>
<p>All you need to do is to make a scene in the editor with all required objects and save it! After that, you can use the
scene in other scenes and just do its instantiation, as in usual 3D models. You can either instantiate it from the
editor by drag'n'drop a prefab to scene previewer, or do standard <a href="fyrox/scene/../resources/model.html">model resource instantiation</a></p>
<h2 id="property-inheritance"><a class="header" href="#property-inheritance">Property inheritance</a></h2>
<p>As already mentioned in the intro section, instances inherit properties from their parent prefabs. For example, you
can change position of an object in prefab and every instance will reflect that change - the object's instances will
also move. This works until there's no manual change to a property in instance, if you do so, your change is 
considered with higher priority. Such feature allows you to tweak instances, add some unique details to them, but keep
generic properties from parent prefabs.</p>
<h2 id="hierarchical-prefabs"><a class="header" href="#hierarchical-prefabs">Hierarchical Prefabs</a></h2>
<p>Prefabs can have other prefab instances inside it. This means that you can, for example, create a room populated with
instances of other prefabs (bookshelves, chairs, tables, etc.) and then use the room prefab to build a bigger scene.
The changes in the base prefabs will be reflected in their instances, regardless of how deep the hierarchy is.</p>
<h2 id="prefabs-and-scripts"><a class="header" href="#prefabs-and-scripts">Prefabs and Scripts</a></h2>
<p>Prefab entities can have script assigned, the engine will create respective instances when you'll instantiate a prefab
in a scene. The main difference here, is in property inheritance - current version of the engine (0.27) does not support
inheritance for properties in scripts. This means, that making hierarchical prefabs with scripts could be problematic,
there is no way to create a basic prefab with scripts and change properties of scripts in derived prefabs while keeping
the inheritance.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="base-node"><a class="header" href="#base-node">Base node</a></h1>
<p>Base node is a scene node that stores hierarchical information (a handle to the parent node and a set of handles
to children nodes), local and global transform, name, tag, lifetime, etc. It has self-describing name - it
is used as a base node for every other scene node (via composition).</p>
<p>It has no graphical information, so it is invisible all the time, but it is useful as a &quot;container&quot; for children
nodes.</p>
<h2 id="how-to-create-2"><a class="header" href="#how-to-create-2">How to create</a></h2>
<p>Use the <code>PivotBuilder</code> to create an instance of the Pivot node (remember <code>Base</code> node itself is used only to build other
node types):</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::scene::{base::BaseBuilder, pivot::PivotBuilder, Scene};
</span><span class="boring">fn build_node(scene: &amp;mut Scene) {
</span>let handle = PivotBuilder::new(BaseBuilder::new()).build(&amp;mut scene.graph);
<span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="building-a-complex-hierarchy"><a class="header" href="#building-a-complex-hierarchy">Building a complex hierarchy</a></h2>
<p>To build a complex hierarchy of some nodes, use <code>.with_children()</code> method of the <code>BaseBuilder</code>, it allows you
to build a hierarchy of any complexity:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::scene::{base::BaseBuilder, pivot::PivotBuilder, camera::CameraBuilder, Scene};
</span><span class="boring">
</span><span class="boring">fn build_node(scene: &amp;mut Scene) {
</span>let handle = PivotBuilder::new(BaseBuilder::new()
    .with_children(&amp;[
        CameraBuilder::new(BaseBuilder::new()).build(&amp;mut scene.graph),
        PivotBuilder::new(BaseBuilder::new()
            .with_children(&amp;[PivotBuilder::new(BaseBuilder::new()).build(&amp;mut scene.graph)]))
            .build(&amp;mut scene.graph),
    ]))
    .build(&amp;mut scene.graph);
<span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p>Note that when we're building a <code>Camera</code> instance, we're passing a new instance of <code>BaseBuilder</code> to it, this
instance can also be used to set some properties and a set of children nodes.</p>
<p>The &quot;fluent syntax&quot; is not mandatory to use, the above code snipped could be rewritten like this:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::scene::{base::BaseBuilder, pivot::PivotBuilder, camera::CameraBuilder, Scene};
</span><span class="boring">
</span><span class="boring">fn build_node(scene: &amp;mut Scene) {
</span>let camera = CameraBuilder::new(BaseBuilder::new()).build(&amp;mut scene.graph);

let child_base = PivotBuilder::new(BaseBuilder::new()).build(&amp;mut scene.graph);

let base = PivotBuilder::new(BaseBuilder::new()
    .with_children(&amp;[child_base]))
    .build(&amp;mut scene.graph);

let handle = PivotBuilder::new(BaseBuilder::new()
    .with_children(&amp;[camera, base]))
    .build(&amp;mut scene.graph);
<span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p>However, it looks less informative, because it loses the hierarchical view and it is harder to tell the relations
between objects.</p>
<h2 id="transform"><a class="header" href="#transform">Transform</a></h2>
<p>Base node has a local transform that allows you to translate/scale/rotate/etc. your node as you want to. For example,
to move a node at specific location you could use this:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">   core::{algebra::Vector3, pool::Handle},
</span><span class="boring">   scene::{node::Node, Scene},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn translate_node(scene: &amp;mut Scene, node_handle: Handle&lt;Node&gt;) {
</span>scene.graph[node_handle]
    .local_transform_mut()
    .set_position(Vector3::new(1.0, 0.0, 2.0));
<span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p>You could also chain multiple <code>set_x</code> calls, like so:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">   core::{algebra::Vector3, pool::Handle},
</span><span class="boring">   scene::{node::Node, Scene},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn transform_node(scene: &amp;mut Scene, node_handle: Handle&lt;Node&gt;) {
</span>scene.graph[node_handle]
    .local_transform_mut()
    .set_position(Vector3::new(1.0, 0.0, 2.0))
    .set_scale(Vector3::new(2.0, 2.0, 2.0))
    .set_rotation_offset(Vector3::new(1.0, 1.0, 0.0));
<span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mesh-node"><a class="header" href="#mesh-node">Mesh node</a></h1>
<p>Mesh is a scane node that represents a 3D model. This one of the most commonly used nodes in almost every game.
Meshes could be easily created either programmatically or be made in some 3D modelling software (like Blender)
and loaded in your scene.</p>
<h2 id="how-to-create-3"><a class="header" href="#how-to-create-3">How to create</a></h2>
<p>There are basically two ways, how to pick one depends on your needs. In general, using a 3D modelling software is
the way to go, especially with tons and tons of free 3D models available online.</p>
<p><strong>Caveat:</strong> The engine supports <em>only</em> FBX file format for 3D models!</p>
<h3 id="using-a-3d-modelling-software"><a class="header" href="#using-a-3d-modelling-software">Using a 3D modelling software</a></h3>
<p>To create 3D model, you could use <a href="https://www.blender.org/">Blender</a> and then export it to <code>FBX</code> file format.
To load your 3D model in the game, you should do few simple steps:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span>
use fyrox::{
    core::{futures::executor::block_on, pool::Handle},
    engine::resource_manager::{ResourceManager},
    scene::{node::Node, Scene},
};
use std::path::Path;

fn load_model_to_scene(
    scene: &amp;mut Scene,
    path: &amp;Path,
    resource_manager: ResourceManager,
) -&gt; Handle&lt;Node&gt; {
    // Request model resource and block until it loading. 
    let model_resource =
        block_on(resource_manager.request_model(path))
            .unwrap();

    // Create an instance of the resource in the scene. 
    model_resource.instantiate_geometry(scene)
}
<span class="boring">}
</span></code></pre></pre>
<p>This code snippet intentionally omits proper <code>async/await</code> usage (instead it just blocks current thread until
model is loading) and error handling. In the real game you should carefully handle all errors and use <code>async/await</code>
properly.</p>
<h3 id="creating-a-procedural-mesh"><a class="header" href="#creating-a-procedural-mesh">Creating a procedural mesh</a></h3>
<p>A mesh instance could be created from code, such meshes are called &quot;procedural&quot;. They're suitable for cases when you
cannot create a mesh in 3D modelling software.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span>
use fyrox::{
    core::{
        algebra::{Matrix4, Vector3},
        parking_lot::Mutex,
        pool::Handle,
        sstorage::ImmutableString,
    },
    engine::resource_manager::ResourceManager,
    material::{shader::SamplerFallback, Material, PropertyValue},
    scene::{
        base::BaseBuilder,
        mesh::{
            surface::{SurfaceBuilder, SurfaceData},
            MeshBuilder,
        },
        node::Node,
        transform::TransformBuilder,
        Scene,
    },
};
use std::sync::Arc;

fn create_procedural_mesh(
    scene: &amp;mut Scene,
    resource_manager: ResourceManager,
) -&gt; Handle&lt;Node&gt; {
    let mut material = Material::standard();

    // Material is completely optional, but here we'll demonstrate that it is possible to
    // create procedural meshes with any material you want.
    material
        .set_property(
            &amp;ImmutableString::new(&quot;diffuseTexture&quot;),
            PropertyValue::Sampler {
                value: Some(resource_manager.request_texture(&quot;some_texture.jpg&quot;)),
                fallback: SamplerFallback::White,
            },
        )
        .unwrap();

    // Notice the MeshBuilder.
    MeshBuilder::new(
        BaseBuilder::new().with_local_transform(
            TransformBuilder::new()
                .with_local_position(Vector3::new(0.0, -0.25, 0.0))
                .build(),
        ),
    )
    .with_surfaces(vec![SurfaceBuilder::new(Arc::new(Mutex::new(
        // Our procedural mesh will have a form of squashed cube.
        // A mesh can have unlimited amount of surfaces.
        SurfaceData::make_cube(Matrix4::new_nonuniform_scaling(&amp;Vector3::new(
            25.0, 0.25, 25.0,
        ))),
    )))
        .with_material(Arc::new(Mutex::new(material)))
        .build()])
    .build(&amp;mut scene.graph)
}
<span class="boring">}
</span></code></pre></pre>
<p>As you can see, creating a mesh procedurally requires lots of manual work and not so easy.</p>
<h2 id="animation"><a class="header" href="#animation">Animation</a></h2>
<p>Meshes have full support of bone animation, it means that you can load pretty much any model in your game, and 
it will play animation with no problems. One difference that should be noted is that you should use <code>instantiate</code>
method instead of <code>instantiate_geometry</code> and then manually apply animation to the mesh in your game loop.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::resource::model::ModelInstance;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::{futures::executor::block_on, pool::Handle},
</span><span class="boring">    engine::resource_manager::{ResourceManager},
</span><span class="boring">    scene::{node::Node, Scene},
</span><span class="boring">};
</span><span class="boring">use std::path::Path;
</span>
fn load_model_to_scene(
    scene: &amp;mut Scene,
    path: &amp;Path,
    resource_manager: ResourceManager,
) -&gt; ModelInstance {
    // Request model resource and block until it loading.
    let model_resource =
        block_on(resource_manager.request_model(path))
            .unwrap();

    // Create an instance of the resource in the scene.
    model_resource.instantiate(scene)
}

<span class="boring">fn animate(scene: &amp;mut Scene, resource_manager: ResourceManager) {
</span>// At initialization.
let ModelInstance { root, animations } = load_model_to_scene(
    scene,
    &amp;Path::new(&quot;path/to/your/model.fbx&quot;),
    resource_manager,
);

// .. Somewhere in the game loop ..

scene.animations[animations[0]]
    .get_pose()
    .apply(&amp;mut scene.graph);
<span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<h3 id="retargetting"><a class="header" href="#retargetting">Retargetting</a></h3>
<p>You don't have to store all possible animations inside a single 3D model file, instead you can store each animation
in separate file and retarget it to your mesh instance when needed. This also allows you to store non-animated
3D model in a separate file and all animations in their own files.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="light-node"><a class="header" href="#light-node">Light node</a></h1>
<p>The engine offers complex lighting system with various types of light sources. </p>
<h2 id="light-types"><a class="header" href="#light-types">Light types</a></h2>
<p>There are three main types of light sources: directional, point, and spot lights.</p>
<h3 id="directional-light"><a class="header" href="#directional-light">Directional light</a></h3>
<p>Directional light does not have a position, its rays are always parallel and it has a particular direction in space.
An example of directional light in real-life could be our Sun. Even if it is a point light, it is so far away from
the Earth, so we can assume that its rays are always parallel. Directional light sources are suitable for outdoor 
scenes.</p>
<p>A directional light source could be created like this:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    scene::{
</span><span class="boring">        base::BaseBuilder,
</span><span class="boring">        light::{directional::DirectionalLightBuilder, BaseLightBuilder},
</span><span class="boring">        node::Node,
</span><span class="boring">        Scene,
</span><span class="boring">    },
</span><span class="boring">};
</span>
fn create_directional_light(scene: &amp;mut Scene) -&gt; Handle&lt;Node&gt; {
    DirectionalLightBuilder::new(BaseLightBuilder::new(BaseBuilder::new()))
        .build(&amp;mut scene.graph)
}
<span class="boring">}
</span></code></pre></pre>
<p>By default, the light source will be oriented to lit &quot;the ground&quot;. In other words its direction will be faced towards
<code>(0.0, -1.0, 0.0)</code> vector. You can rotate it as you want by setting local transform of it while building. Something
like this:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::{
</span><span class="boring">        algebra::{UnitQuaternion, Vector3},
</span><span class="boring">        pool::Handle,
</span><span class="boring">    },
</span><span class="boring">    scene::{
</span><span class="boring">        base::BaseBuilder,
</span><span class="boring">        light::{directional::DirectionalLightBuilder, BaseLightBuilder},
</span><span class="boring">        node::Node,
</span><span class="boring">        transform::TransformBuilder,
</span><span class="boring">        Scene,
</span><span class="boring">    },
</span><span class="boring">};
</span>
fn create_directional_light(scene: &amp;mut Scene) -&gt; Handle&lt;Node&gt; {
    DirectionalLightBuilder::new(BaseLightBuilder::new(
        BaseBuilder::new().with_local_transform(
            TransformBuilder::new()
                .with_local_rotation(UnitQuaternion::from_axis_angle(
                    &amp;Vector3::x_axis(),
                    -45.0f32.to_radians(),
                ))
                .build(),
        ),
    ))
    .build(&amp;mut scene.graph)
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="point-light"><a class="header" href="#point-light">Point light</a></h3>
<p>Point light is a light source that emits lights in all directions, it has a position, but does not have an orientation.
An example of a point light source: light bulb. </p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    scene::{
</span><span class="boring">        base::BaseBuilder,
</span><span class="boring">        light::{point::PointLightBuilder, BaseLightBuilder},
</span><span class="boring">        node::Node,
</span><span class="boring">        Scene,
</span><span class="boring">    },
</span><span class="boring">};
</span>
fn create_point_light(scene: &amp;mut Scene) -&gt; Handle&lt;Node&gt; {
    PointLightBuilder::new(BaseLightBuilder::new(BaseBuilder::new()))
        .with_radius(5.0)
        .build(&amp;mut scene.graph)
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="spotlight"><a class="header" href="#spotlight">Spotlight</a></h3>
<p>Spot light is a light source that emits lights in cone shape, it has a position and orientation. An example of 
a spot light source: flashlight.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    scene::{
</span><span class="boring">        base::BaseBuilder,
</span><span class="boring">        light::{spot::SpotLightBuilder, BaseLightBuilder},
</span><span class="boring">        node::Node,
</span><span class="boring">        Scene,
</span><span class="boring">    },
</span><span class="boring">};
</span>
fn create_spot_light(scene: &amp;mut Scene) -&gt; Handle&lt;Node&gt; {
    SpotLightBuilder::new(BaseLightBuilder::new(BaseBuilder::new()))
        .with_distance(5.0)
        .with_hotspot_cone_angle(50.0f32.to_radians())
        .with_falloff_angle_delta(10.0f32.to_radians())
        .build(&amp;mut scene.graph)
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="light-scattering"><a class="header" href="#light-scattering">Light scattering</a></h2>
<p>Spot and point lights support light scattering effect. Imagine you're walking with a flashlight in a foggy weather,
the fog will scatter the light from your flashlight making it, so you'll see the &quot;light volume&quot;. Light scattering is
<strong>enabled by default</strong>, so you don't have to do anything to enable it. However, in some cases you might want to disable 
it, you can do this either while building a light source or change light scattering options on existing light source.
Here is the small example of how to do that.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    scene::{node::Node, light::BaseLight, Scene},
</span><span class="boring">};
</span>
fn disable_light_scatter(scene: &amp;mut Scene, light_handle: Handle&lt;Node&gt;) {
    scene.graph[light_handle]
        .query_component_mut::&lt;BaseLight&gt;()
        .unwrap()
        .enable_scatter(false);
}
<span class="boring">}
</span></code></pre></pre>
<p>You could also change the amount of scattering per each color channel, using this you could imitate the 
<a href="https://en.wikipedia.org/wiki/Rayleigh_scattering">Rayleigh scattering</a>:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::{algebra::Vector3, pool::Handle},
</span><span class="boring">    scene::{node::Node, light::BaseLight, Scene},
</span><span class="boring">};
</span>
fn use_rayleigh_scattering(scene: &amp;mut Scene, light_handle: Handle&lt;Node&gt;) {
    scene.graph[light_handle]
        .query_component_mut::&lt;BaseLight&gt;()
        .unwrap()
        .set_scatter(Vector3::new(0.03, 0.035, 0.055));
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="shadows"><a class="header" href="#shadows">Shadows</a></h2>
<p>Spot and point lights both support shadows, however directional light still lacks shadows. There is a
<a href="https://github.com/FyroxEngine/Fyrox/issues/220">tracking issue</a> for that.</p>
<h2 id="performance-1"><a class="header" href="#performance-1">Performance</a></h2>
<p>Lights are not very cheap, every light source has some performance impact. As a general rule, try to keep the amount
of light sources at reasonable levels and especially try to avoid creating tons of light sources in a small area.
Keep in mind that the less area the light needs to &quot;cover&quot;, the higher the performance. This means that you can have
tons of small light sources for free.</p>
<p>Shadows giving the most significant performance impact, you should keep the amount of light sources that can cast
shadows at lowest possible amount to keep performance at good levels. You can also turn on/off shadows when you 
need:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    scene::{node::Node, light::BaseLight, Scene},
</span><span class="boring">};
</span>
fn switch_shadows(scene: &amp;mut Scene, light_handle: Handle&lt;Node&gt;, cast_shadows: bool) {
    scene.graph[light_handle]
        .query_component_mut::&lt;BaseLight&gt;()
        .unwrap()
        .set_cast_shadows(cast_shadows);
}
<span class="boring">}
</span></code></pre></pre>
<p>Not every light should cast shadows, for example a small light that a player can see only in a distance can have
shadows disabled. You should set the appropriate values depending on your scene, just remember: the fewer the shadows
the better the performance. The most expensive shadows are from point lights, the less, from spot lights.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sprite"><a class="header" href="#sprite">Sprite</a></h1>
<p>Sprite is just a quad mesh that is always facing camera. It has size, color, rotation around &quot;look&quot; axis and a texture.
Sprites are useful mostly for projectiles, like glowing plasma, and for things that should always face a camera.</p>
<p><strong>Important:</strong> It should be noted that <strong>sprites are not meant to be used for 2D games</strong>, they're only for 3D. 
There is a separate 2D scenes with their own nodes, which are very well optimized for 2D games.</p>
<h2 id="how-to-create-4"><a class="header" href="#how-to-create-4">How to create</a></h2>
<p>A sprite instance could be created using <code>SpriteBuilder</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::{color::Color, pool::Handle},
</span><span class="boring">    scene::{base::BaseBuilder, node::Node, sprite::SpriteBuilder, Scene},
</span><span class="boring">};
</span>
fn create_sprite(scene: &amp;mut Scene) -&gt; Handle&lt;Node&gt; {
    SpriteBuilder::new(BaseBuilder::new())
        .with_size(2.0)
        .with_rotation(45.0f32.to_radians())
        .with_color(Color::RED)
        .build(&amp;mut scene.graph)
}
<span class="boring">}
</span></code></pre></pre>
<p>A sprite with a texture could be created by using <code>.with_texture</code> method of the builder:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span>use fyrox::{
    core::pool::Handle,
    engine::resource_manager::ResourceManager,
    scene::{base::BaseBuilder, node::Node, sprite::SpriteBuilder, Scene},
};

fn create_sprite(scene: &amp;mut Scene, resource_manager: ResourceManager) -&gt; Handle&lt;Node&gt; {
    SpriteBuilder::new(BaseBuilder::new())
        .with_texture(resource_manager.request_texture(&quot;path/to/your/texture.png&quot;))
        .build(&amp;mut scene.graph)
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="general-rules"><a class="header" href="#general-rules">General rules</a></h2>
<p>Sprites <strong>must not</strong> be used to create any visual effects that involve many particles. You should use particle
systems for that. Why so? Particles systems are very well optimized for managing huge amounts of particles at the
same time, but sprites are not. Each sprite is very heavy to be used as a particle in particle systems, it has
a lot of &quot;useless&quot; info that bloats its size up to 600 bytes. </p>
<p>Currently, the renderer will render each sprite in a separate draw call, which is very inefficient. So you should 
avoid creating lots of sprites.</p>
<h2 id="limitations"><a class="header" href="#limitations">Limitations</a></h2>
<p>Sprites are not supporting any sort of lighting, if you need lighted sprites, you need to create your own render
pass and use <code>Mesh</code> node with custom shader that will orient all faces towards camera and will do lighting 
calculations. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="particle-system"><a class="header" href="#particle-system">Particle system</a></h1>
<p>Particle system is a scene node that is used to create complex visual effects (VFX). It operates on huge amount
of particles at once allowing you to do complex simulation that involves large amount of particles. Typically,
particle systems are used to create following visual effects: smoke, sparks, blood splatters, steam, etc. </p>
<p><strong>Important:</strong> Current particle system implementation is <strong>not deterministic</strong>, this means that the state of the
particles will be different at each run of your game. Also you <strong>cannot</strong> rewind the particle system, nor set
a particular position in time. This fact limits potential usages of the particle system, however it is still useful
for any effects that does not have to be deterministic, like sparks, smoke, steam, etc. This is a known issue, and
it will eventually be fixed by adding a new kind of particle systems. Tracking issue could be found 
<a href="https://github.com/FyroxEngine/Fyrox/issues/120">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="terrain-wip"><a class="header" href="#terrain-wip">Terrain (WIP)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="camera-node"><a class="header" href="#camera-node">Camera node</a></h1>
<p>Camera is a special scene node that allows you to &quot;look&quot; at your scene from any point and with any orientation.
Currently, the engine supports only <em>perspective</em> cameras, which could be represented as a frustum volume. Everything
that &quot;intersects&quot; with the frustum will be rendered. </p>
<p><img src="fyrox/scene/./frustum.svg" alt="Frustum" /></p>
<h2 id="how-to-create-5"><a class="header" href="#how-to-create-5">How to create</a></h2>
<p>An instance of camera node could be created using <code>CameraBuilder</code>: </p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    scene::{base::BaseBuilder, camera::CameraBuilder, node::Node, Scene},
</span><span class="boring">};
</span>
fn create_camera(scene: &amp;mut Scene) -&gt; Handle&lt;Node&gt; {
    CameraBuilder::new(BaseBuilder::new())
        // Set some properties.
        .with_fov(80.0f32.to_radians())
        .with_z_far(256.0)
        .build(&amp;mut scene.graph)
}
<span class="boring">}
</span></code></pre></pre>
<p>Orientation and position should be set in <code>BaseBuilder</code> as usual.</p>
<h2 id="projection-modes"><a class="header" href="#projection-modes">Projection modes</a></h2>
<p>Projection mode defines how your scene will look like after rendering, there are two projection modes available.</p>
<h3 id="perspective"><a class="header" href="#perspective">Perspective</a></h3>
<p>Perspective projection makes distant objects smaller and parallel lines converging when using it, it is the most 
common projection type for 3D games. By default, each camera uses perspective projection. It's defined by three 
parameters that describes frustum volume:</p>
<ul>
<li>Field of view angle</li>
<li>Near clipping plane location</li>
<li>Far clipping plane location</li>
</ul>
<p>Here is a simple example of how to create a camera with perspective projection:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    scene::{
</span><span class="boring">        base::BaseBuilder,
</span><span class="boring">        camera::{CameraBuilder, PerspectiveProjection, Projection},
</span><span class="boring">        graph::Graph,
</span><span class="boring">        node::Node,
</span><span class="boring">    },
</span><span class="boring">};
</span>fn create_perspective_camera(graph: &amp;mut Graph) -&gt; Handle&lt;Node&gt; {
    CameraBuilder::new(BaseBuilder::new())
        .with_projection(Projection::Perspective(PerspectiveProjection {
            // Keep in mind that field of view expressed in radians!
            fov: 60.0f32.to_radians(),
            z_near: 0.025,
            z_far: 1024.0,
        }))
        .build(graph)
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="orthographic"><a class="header" href="#orthographic">Orthographic</a></h3>
<p>Orthographic projection prevents parallel lines from converging, it does not affect object size with distance.
If you're making 2D games or isometric 3D games, this is the projection mode you're looking for. Orthographic
projection defined by three parameters:</p>
<ul>
<li>Vertical Size</li>
<li>Near Clipping Plane</li>
<li>Far Clipping Plane</li>
</ul>
<p>Vertical size defines how large the &quot;box&quot; will be in vertical axis, horizontal size is derived from vertical
size by multiplying vertical size with aspect ratio.</p>
<p>Here is a simple example of how to create a camera with orthographic projection:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    scene::{
</span><span class="boring">        base::BaseBuilder,
</span><span class="boring">        camera::{CameraBuilder, OrthographicProjection, Projection},
</span><span class="boring">        graph::Graph,
</span><span class="boring">        node::Node,
</span><span class="boring">    },
</span><span class="boring">};
</span>fn create_perspective_camera(graph: &amp;mut Graph) -&gt; Handle&lt;Node&gt; {
    CameraBuilder::new(BaseBuilder::new())
        .with_projection(Projection::Orthographic(OrthographicProjection {
            vertical_size: 5.0,
            z_near: 0.025,
            z_far: 1024.0,
        }))
        .build(graph)
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="performance-2"><a class="header" href="#performance-2">Performance</a></h2>
<p>Each camera forces engine to re-render scene one more time, which can be very resource-intensive (both CPU and GPU)
operation. </p>
<p>To reduce GPU load, try to keep the Far Clipping Plane at lowest possible values. For example, if you're making a game
with closed environment (lots of corridors, small rooms, etc.) set the Far clipping Plane to max possible distance that 
can be &quot;seen&quot; in your game - if the largest thing is a corridor, then set the Far clipping Plane to slightly exceed the 
length. This will force the engine to clip everything that is out of bounds and do not draw such objects.</p>
<h2 id="skybox"><a class="header" href="#skybox">Skybox</a></h2>
<p>Outdoor scenes usually have distant objects that can't be reached, these can be mountains, sky, distant forest, etc.
such objects can be pre-rendered and then applied to a huge cube around camera, it always will be rendered first and will
be the background of your scene. To create a Skybox and set it to a camera, you can use the following code:</p>
<pre><pre class="playground"><code class="language-rust no_run edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::{futures::executor::block_on, pool::Handle},
</span><span class="boring">    engine::resource_manager::ResourceManager,
</span><span class="boring">    resource::texture::TextureWrapMode,
</span><span class="boring">    scene::{
</span><span class="boring">        base::BaseBuilder,
</span><span class="boring">        camera::{CameraBuilder, SkyBox, SkyBoxBuilder},
</span><span class="boring">        node::Node,
</span><span class="boring">        Scene,
</span><span class="boring">    },
</span><span class="boring">};
</span>
async fn create_skybox(resource_manager: ResourceManager) -&gt; SkyBox {
    // Load skybox textures in parallel.
    let (front, back, left, right, top, bottom) = fyrox::core::futures::join!(
        resource_manager.request_texture(&quot;path/to/front.jpg&quot;),
        resource_manager.request_texture(&quot;path/to/back.jpg&quot;),
        resource_manager.request_texture(&quot;path/to/left.jpg&quot;),
        resource_manager.request_texture(&quot;path/to/right.jpg&quot;),
        resource_manager.request_texture(&quot;path/to/up.jpg&quot;),
        resource_manager.request_texture(&quot;path/to/down.jpg&quot;)
    );

    // Unwrap everything.
    let skybox = SkyBoxBuilder {
        front: Some(front.unwrap()),
        back: Some(back.unwrap()),
        left: Some(left.unwrap()),
        right: Some(right.unwrap()),
        top: Some(top.unwrap()),
        bottom: Some(bottom.unwrap()),
    }
    .build()
    .unwrap();

    // Set S and T coordinate wrap mode, ClampToEdge will remove any possible seams on edges
    // of the skybox.
    let skybox_texture = skybox.cubemap().unwrap();
    let mut data = skybox_texture.data_ref();
    data.set_s_wrap_mode(TextureWrapMode::ClampToEdge);
    data.set_t_wrap_mode(TextureWrapMode::ClampToEdge);

    skybox
}

fn create_camera(scene: &amp;mut Scene, resource_manager: ResourceManager) -&gt; Handle&lt;Node&gt; {
    CameraBuilder::new(BaseBuilder::new())
        .with_skybox(block_on(create_skybox(resource_manager)))
        .build(&amp;mut scene.graph)
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="color-grading-look-up-tables"><a class="header" href="#color-grading-look-up-tables">Color grading look-up tables</a></h2>
<p>Color grading Look-Up Tables (LUT) allows you to transform color space of your frame. Probably everyone saw the
famous &quot;mexican&quot; movie effect when everything becomes yellow-ish when action takes place in Mexico, this is done
via color grading LUT effect. When used wisely, it can significantly improve perception of your scene.</p>
<p>Here is the same scene having no color correction along with another case that has &quot;mexico&quot; color correction:</p>
<div class="table-wrapper"><table><thead><tr><th>Scene</th><th>Look-up-table</th></tr></thead><tbody>
<tr><td><img src="fyrox/scene/./no_color_correction.PNG" alt="No Color Correction" /></td><td><img src="fyrox/scene/./lut_neutral.jpg" alt="Neutral LUT" /></td></tr>
<tr><td><img src="fyrox/scene/./with_color_correction.PNG" alt="With Color Correction" /></td><td><img src="fyrox/scene/./lut_mexico.jpg" alt="Neutral LUT" /></td></tr>
</tbody></table>
</div>
<p>To use color grading LUT you could do something like this:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::{futures::executor::block_on, pool::Handle},
</span><span class="boring">    engine::resource_manager::ResourceManager,
</span><span class="boring">    scene::{
</span><span class="boring">        base::BaseBuilder,
</span><span class="boring">        camera::{CameraBuilder, ColorGradingLut},
</span><span class="boring">        node::Node,
</span><span class="boring">        Scene,
</span><span class="boring">    },
</span><span class="boring">};
</span>
fn create_camera_with_lut(
    scene: &amp;mut Scene,
    resource_manager: ResourceManager,
) -&gt; Handle&lt;Node&gt; {
    CameraBuilder::new(BaseBuilder::new())
        .with_color_grading_enabled(true)
        .with_color_grading_lut(
            block_on(ColorGradingLut::new(
                resource_manager.request_texture(&quot;path/to/lut.jpg&quot;),
            ))
            .unwrap(),
        )
        .build(&amp;mut scene.graph)
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="exposure-and-hdr"><a class="header" href="#exposure-and-hdr">Exposure and HDR</a></h2>
<p>(WIP)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="decal-node"><a class="header" href="#decal-node">Decal node</a></h1>
<p>Decal nodes allow you to &quot;project&quot; a texture onto your scene within some specific bounds. It is widely used for
bullet holes, blood splatter, dirt, cracks and so on. Here is the example of the decal applied to the scene:</p>
<p><img src="fyrox/scene/./decal.PNG" alt="Decal" /></p>
<p>The rust marks are applied on existing geometry of the scene by projecting a rust texture in specific direction.</p>
<h2 id="how-to-create-6"><a class="header" href="#how-to-create-6">How to create</a></h2>
<p>A decal instance can be created using DecalBuilder:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    engine::resource_manager::ResourceManager,
</span><span class="boring">    scene::{base::BaseBuilder, decal::DecalBuilder, node::Node, Scene},
</span><span class="boring">};
</span>
fn create_decal(scene: &amp;mut Scene, resource_manager: ResourceManager) -&gt; Handle&lt;Node&gt; {
    DecalBuilder::new(BaseBuilder::new())
        .with_diffuse_texture(resource_manager.request_texture(&quot;path/to/your/decal.png&quot;))
        .build(&amp;mut scene.graph)
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="textures"><a class="header" href="#textures">Textures</a></h2>
<p>You can specify which textures the decal will be projecting, currently there is only diffuse and normal maps
supported.</p>
<h2 id="rendering"><a class="header" href="#rendering">Rendering</a></h2>
<p>Currently, the engine supports only <em>deferred decals</em>, which means that decals modify the information stored in
G-Buffer. This fact means that decals will be lit correctly with other geometry in the scene. However, if you 
have some objects in your scene that uses forward rendering path, your decals won't be applied to them.</p>
<h2 id="bounds"><a class="header" href="#bounds">Bounds</a></h2>
<p>Decal uses Object-Oriented Bounding Box (OOB) to determine pixels on which decal's textures will be projected,
everything that got into OOB will be covered. Exact bounds can be set by tweaking local transform of a decal.
If you want your decal to be larger, set its scale to some large value. To position a decal - use local position,
to rotate - local rotation.</p>
<p>A decal defines a cube that projects a texture on every pixel of a scene that got into the cube. Exact cube size 
is defined by decal's local scale. For example, if you have a decal with scale of (1.0, 2.0, 0.1) then the size of 
the cube (in local coordinates) will be width = 1.0, height = 2.0 and depth = 0.1. The decal can be rotated as any 
other scene node. Its final size and orientation are defined by the chain of transformations of parent nodes.</p>
<h2 id="layers"><a class="header" href="#layers">Layers</a></h2>
<p>There are situations when you want to prevent some geometry from being covered with a decal, to do that the engine
offers a concept of layers. A decal will be applied to a geometry if and only if they have matching layer index. This 
allows you to create environment damage decals and they won't affect dynamic objects since they're located on 
different layers.</p>
<h2 id="performance-3"><a class="header" href="#performance-3">Performance</a></h2>
<p>Current implementation of decals is relatively cheap, this allows you to create many decals on scene. However, you
should keep the amount of decals at a reasonable level. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rectangle-node"><a class="header" href="#rectangle-node">Rectangle node</a></h1>
<p>Rectangle is the simplest &quot;2D&quot; node, it can be used to create &quot;2D&quot; graphics. 2D is in quotes here because the node
is actually a 3D node, like everything else in the engine. Here is an example scene made with the rectangle nodes and 
an orthographic camera:</p>
<p><img src="fyrox/scene/2d_scene.PNG" alt="2d scene" /></p>
<p>As you can see it is a good basis for 2D games.</p>
<h2 id="how-to-create-7"><a class="header" href="#how-to-create-7">How to create</a></h2>
<p>Use the RectangleBuilder to create Rectangle nodes:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::{algebra::Vector3, color::Color, pool::Handle},
</span><span class="boring">    engine::resource_manager::ResourceManager,
</span><span class="boring">    scene::{
</span><span class="boring">        base::BaseBuilder, dim2::rectangle::RectangleBuilder, graph::Graph, node::Node,
</span><span class="boring">        transform::TransformBuilder,
</span><span class="boring">    },
</span><span class="boring">};
</span>fn create_rect(graph: &amp;mut Graph, resource_manager: ResourceManager) -&gt; Handle&lt;Node&gt; {
    RectangleBuilder::new(
        BaseBuilder::new().with_local_transform(
            TransformBuilder::new()
                // Size of the rectangle is defined only by scale.
                .with_local_scale(Vector3::new(0.4, 0.2, 1.0))
                .build(),
        ),
    )
    .with_color(Color::RED)
    .with_texture(resource_manager.request_texture(&quot;path/to/your_texture.jpg&quot;))
    .build(graph)
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="specifying-image-portion-for-rendering"><a class="header" href="#specifying-image-portion-for-rendering">Specifying image portion for rendering</a></h2>
<p>By default, Rectangle node uses entire image for rendering, but for some applications it is not enough. For example,
you may want to use sprite sheets to animate your 2D entities. In this case you need to be able to use only portion
of an image. It is possible to do by using <code>set_uv_rect</code> method of the Rectangle node. Here's an example of setting
right-top quarter of an image to be used by a Rectangle node:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{core::math::Rect, scene::dim2::rectangle::Rectangle};
</span><span class="boring">
</span>fn set_2nd_quarter_image_portion(rectangle: &amp;mut Rectangle) {
    rectangle.set_uv_rect(Rect::new(
        0.5, // Offset by 50% to the right
        0.0, // No need to offset to bottom.
        0.5, // Use half (50%) of width and height
        0.5,
    ));
}
<span class="boring">}
</span></code></pre></pre>
<p>Keep in mind that every part of uv rectangle is proportional. For example 0.5 means 50%, 1.5 = 150% and so on. If width
or height is exceeding 1.0 and the texture being used is set to Wrapping mode at respective axis, the image will tile
across axes.</p>
<h2 id="performance-4"><a class="header" href="#performance-4">Performance</a></h2>
<p>Rectangles use specialized renderer that is heavily optimized to render tons of rectangles at once, so you can use 
rectangles almost for everything in 2D games. </p>
<h2 id="limitations-1"><a class="header" href="#limitations-1">Limitations</a></h2>
<p>Rectangle nodes does not support custom materials - it is a simplified version of a Mesh node that allows you draw a
rectangle with a texture and a color. Its main purpose is to be able to start making games as quick as possible without
diving too deep into details (shaders, render passes, etc.). You can still create a &quot;rectangle&quot; with custom material, use
Mesh node with single rectangle surface:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::{
</span><span class="boring">        algebra::{Matrix4, Vector3},
</span><span class="boring">        parking_lot::Mutex,
</span><span class="boring">        pool::Handle,
</span><span class="boring">    },
</span><span class="boring">    material::Material,
</span><span class="boring">    scene::{
</span><span class="boring">        base::BaseBuilder,
</span><span class="boring">        graph::Graph,
</span><span class="boring">        mesh::{
</span><span class="boring">            surface::{SurfaceBuilder, SurfaceData},
</span><span class="boring">            MeshBuilder, RenderPath,
</span><span class="boring">        },
</span><span class="boring">        node::Node,
</span><span class="boring">        transform::TransformBuilder,
</span><span class="boring">    },
</span><span class="boring">};
</span><span class="boring">use std::sync::Arc;
</span>
fn create_rect_with_custom_material(
    graph: &amp;mut Graph,
    material: Arc&lt;Mutex&lt;Material&gt;&gt;,
) -&gt; Handle&lt;Node&gt; {
    MeshBuilder::new(
        BaseBuilder::new().with_local_transform(
            TransformBuilder::new()
                .with_local_scale(Vector3::new(0.4, 0.2, 1.0))
                .build(),
        ),
    )
    .with_surfaces(vec![SurfaceBuilder::new(Arc::new(Mutex::new(
        SurfaceData::make_quad(&amp;Matrix4::identity()),
    )))
    .with_material(material)
    .build()])
    .with_render_path(RenderPath::Forward)
    .build(graph)
}
<span class="boring">}
</span></code></pre></pre>
<p>This will effectively &quot;mimic&quot; the Rectangle node, but will allow you to use the full power of custom shaders. Keep in
mind that Mesh nodes will be rendered via Deferred Renderer, while Rectangle nodes rendered with specialized renderer,
that might result in some graphical artifacts.</p>
<p>Rectangle nodes has limited lighting support, it means that they still will be lit by standard scene lights, but it will
be a very simple diffuse lighting without any &quot;physically correct&quot; lighting. This is perfectly ok for 95% of 2D games,
if you want to add custom lighting then you should use custom shader.</p>
<p>Rectangle nodes works well with 2D physics nodes, check 2D physics section of the book for more info.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-scene-node"><a class="header" href="#custom-scene-node">Custom Scene Node</a></h1>
<p>Sometimes there is a need to have custom scene nodes, it is possible to do, but it requires quite a lot of boilerplate
code.</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">// TODO: remove `compile_fail` when 0.27 is released.
</span>use fxhash::FxHashMap;
use fyrox::{
    core::{
        inspect::prelude::*,
        math::aabb::AxisAlignedBoundingBox,
        pool::Handle,
        uuid::{uuid, Uuid},
        variable::InheritError,
        visitor::prelude::*,
    },
    engine::resource_manager::ResourceManager,
    impl_directly_inheritable_entity_trait,
    scene::{
        base::Base,
        node::{Node, NodeTrait},
        DirectlyInheritableEntity,
    },
};
use std::ops::{Deref, DerefMut};

#[derive(Clone, Inspect, Visit, Debug)]
pub struct CustomNode {
    base: Base,
}

impl Deref for CustomNode {
    type Target = Base;

    fn deref(&amp;self) -&gt; &amp;Self::Target {
        &amp;self.base
    }
}

impl DerefMut for CustomNode {
    fn deref_mut(&amp;mut self) -&gt; &amp;mut Self::Target {
        &amp;mut self.base
    }
}

impl_directly_inheritable_entity_trait!(CustomNode;);

impl NodeTrait for CustomNode {
    fyrox::impl_query_component!();

    fn local_bounding_box(&amp;self) -&gt; AxisAlignedBoundingBox {
        self.base.local_bounding_box()
    }

    fn world_bounding_box(&amp;self) -&gt; AxisAlignedBoundingBox {
        self.base.world_bounding_box()
    }

    fn inherit(&amp;mut self, parent: &amp;Node) -&gt; Result&lt;(), InheritError&gt; {
        if let Some(parent) = parent.cast::&lt;CustomNode&gt;() {
            self.base.try_inherit_self_properties(parent)?;
        }
        Ok(())
    }

    fn reset_inheritable_properties(&amp;mut self) {
        self.base.reset_self_inheritable_properties()
    }

    fn restore_resources(&amp;mut self, _resource_manager: ResourceManager) {
        // Use this method to remap resource handles to valid handles after deserialization.
    }

    fn remap_handles(&amp;mut self, _old_new_mapping: &amp;FxHashMap&lt;Handle&lt;Node&gt;, Handle&lt;Node&gt;&gt;) {
        // Use this method to remap handle to other nodes. It is used when the node is copied.
    }

    fn id(&amp;self) -&gt; Uuid {
        // Provide unique id for serialization needs. It must be unique, use https://www.uuidgenerator.net/
        // to generate one.
        uuid!(&quot;f592e7f7-5e34-4043-9226-407c7457bb48&quot;)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Once the node is defined, you can create is as usual and put in the graph:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    scene::{camera::Camera, graph::Graph, node::Node},
</span><span class="boring">};
</span><span class="boring">type CustomNode = Camera;
</span><span class="boring">
</span>fn add_custom_node(graph: &amp;mut Graph) -&gt; Handle&lt;Node&gt; {
    graph.add_node(Node::new(CustomNode::default()))
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="limitations-2"><a class="header" href="#limitations-2">Limitations</a></h2>
<p>Scene nodes have no access to outer context, this means that you cannot reference any data that is located outside 
graph easily. You still can define a global variable that <strong>will</strong> be accessible, but it is considered as a hack and
should be avoided. If you want to add custom logic to scene nodes, then you should use scripts instead. Custom nodes
are intended for very specific use cases, such as adding &quot;data sources&quot; for renderer, etc.</p>
<h2 id="editor-support"><a class="header" href="#editor-support">Editor support</a></h2>
<p>Current <code>NodeTrait</code> implementation clearly states that you cannot edit properties of your objects from the editor. 
This is a bug and will be fixed in future versions.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="physics"><a class="header" href="#physics">Physics</a></h1>
<p>The engine have full-featured physics engine under the hood (Rapier), it helps you to simulate physics in your games.
There is first-class support for both 2D and 3D physics. There are three main physics entities in the engine:</p>
<ul>
<li>Rigid Body - responsible for rigid body dynamics simulation, must have at least one collider to be able to interact with
other rigid bodies in the world.</li>
<li>Collider - responsible for collision detection.</li>
<li>Joint - responsible for motion restriction between two rigid bodies.</li>
</ul>
<p>All these entities are ordinary scene nodes, so they can be arranged into any hierarchy in the scene. However there some
rules that have to be followed to make physics simulation work as intended:</p>
<ul>
<li>Rigid body node must have at least one <em>direct child</em> Collider node, otherwise rigid body won't interact with other
rigid bodies in the world.</li>
<li>Joint node must have two <em>direct child</em> rigid bodies, otherwise joint will have no effect.</li>
</ul>
<h2 id="differences-between-3d-and-2d"><a class="header" href="#differences-between-3d-and-2d">Differences between 3D and 2D</a></h2>
<p>There is a very few differences between 3D and 2D physics, the most obvious is that 2D physics does simulation only in 
oXY plane (the plane of the screen). 2D physics has less collider shapes available since some 3D shapes degenerate in
2D, for example cylinder 3D shape in 2D is just a rectangle. There is also lesser amount of joints available in 2D, 
there is no revolute joint for example. Unlike 3D physics entities, 2D physics entities exist in the separate
<code>scene::dim2</code> module.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rigid-body-node"><a class="header" href="#rigid-body-node">Rigid body node</a></h1>
<p>Rigid body node is the one of main physical entities in the engine. Rigid body nodes can be affected by gravity, 
external forces and other rigid bodies. Use rigid body node everywhere you need natural physical behaviour for
your objects.</p>
<h2 id="how-to-create-8"><a class="header" href="#how-to-create-8">How to create</a></h2>
<p>Use RigidBodyBuilder to create a rigid body instance:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::{algebra::Vector3, pool::Handle},
</span><span class="boring">    scene::{
</span><span class="boring">        base::BaseBuilder,
</span><span class="boring">        collider::{ColliderBuilder, ColliderShape},
</span><span class="boring">        graph::Graph,
</span><span class="boring">        node::Node,
</span><span class="boring">        rigidbody::RigidBodyBuilder,
</span><span class="boring">    },
</span><span class="boring">};
</span>fn create_cube_rigid_body(graph: &amp;mut Graph) -&gt; Handle&lt;Node&gt; {
    RigidBodyBuilder::new(BaseBuilder::new().with_children(&amp;[
            // Rigid body must have at least one collider
            ColliderBuilder::new(BaseBuilder::new())
                .with_shape(ColliderShape::cuboid(0.5, 0.5, 0.5))
                .build(graph),
        ]))
    .with_mass(2.0)
    .with_lin_vel(Vector3::new(0.0, 3.0, 1.0))
    .build(graph)
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="colliders"><a class="header" href="#colliders">Colliders</a></h2>
<p>Rigid body must have at least one collider to participate in simulation properly, multiple colliders can be used to
create complex shapes from simple shapes, you can create concave objects this way.</p>
<h2 id="force-and-torque"><a class="header" href="#force-and-torque">Force and torque</a></h2>
<p>You can apply forces and torque to any rigid body, but only dynamic bodies will be affected. There is two ways of
applying force to a rigid body: at center of mass or at particular point at the body:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{core::algebra::Vector3, scene::rigidbody::RigidBody};
</span>fn apply_force_and_torque(rigid_body: &amp;mut RigidBody) {
    // Push rigid body forward at the center of mass.
    rigid_body.apply_force(Vector3::new(0.0, 0.0, 1.0));

    // Kick rigid body at the side (this will also make it rotate)
    rigid_body.apply_force_at_point(Vector3::new(0.0, 0.0, 1.0), Vector3::new(1.0, 0.0, 0.0));

    // Turn rigid body around center of mass.
    rigid_body.apply_torque(Vector3::new(0.0, 3.0, 0.0));
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="kinematic-rigid-bodies"><a class="header" href="#kinematic-rigid-bodies">Kinematic rigid bodies</a></h2>
<p>Sometimes you may want to have direct control over position/rotation of a rigid body and tell the physics engine to not
do simulation for the body. This can be achieved by making the rigid body <em>kinematic</em>:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::{algebra::Vector3, pool::Handle},
</span><span class="boring">    scene::{
</span><span class="boring">        base::BaseBuilder,
</span><span class="boring">        collider::{ColliderBuilder, ColliderShape},
</span><span class="boring">        graph::Graph,
</span><span class="boring">        node::Node,
</span><span class="boring">        rigidbody::{RigidBodyBuilder, RigidBodyType},
</span><span class="boring">    },
</span><span class="boring">};
</span>
fn create_kinematic_rigid_body(graph: &amp;mut Graph) -&gt; Handle&lt;Node&gt; {
    RigidBodyBuilder::new(BaseBuilder::new().with_children(&amp;[
            // Rigid body must have at least one collider
            ColliderBuilder::new(BaseBuilder::new())
                .with_shape(ColliderShape::cuboid(0.5, 0.5, 0.5))
                .build(graph),
        ]))
    .with_body_type(RigidBodyType::KinematicPositionBased)
    .build(graph)
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="continuous-collision-detection"><a class="header" href="#continuous-collision-detection">Continuous collision detection</a></h2>
<p>Fast-moving rigid bodies can &quot;fly through&quot; other objects (for example a bullet can completely ignore walls if it is 
moving too fast), this happens because of discrete calculation. This can be fixed by using continuous collision detection,
to enable it use either <code>.with_ccd_enabled(state)</code> of <code>RigidBodyBuilder</code> or <code>.set_ccd_enabled(state)</code> of <code>RigidBody</code>.</p>
<h2 id="2d-rigid-bodies"><a class="header" href="#2d-rigid-bodies">2D rigid bodies</a></h2>
<p>2D rigid bodies have no difference with 3D, except the simulation happens in oXY plane and Z coordinate is ignored.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="collider-node"><a class="header" href="#collider-node">Collider node</a></h1>
<p>Collider is a geometrical shape that is used for collision detection, contact manifold generation, etc. Colliders are used
in pair with rigid bodies, they make rigid body participate in collisions.</p>
<h2 id="shapes"><a class="header" href="#shapes">Shapes</a></h2>
<p>Collider can have almost any shape, the engine offers the following shapes for 3D:</p>
<ul>
<li>Ball - dynamic sphere shape.</li>
<li>Cylinder - dynamic cylinder shape.</li>
<li>Cone - dynamic cone shape.</li>
<li>Cuboid - dynamic box shape.</li>
<li>Capsule - dynamic capsule shape.</li>
<li>Segment - dynamic segment (&quot;line&quot;) shape</li>
<li>Triangle - simple dynamic triangle shape</li>
<li>Triangle mesh - static concave shape, can be used together with any static level geometry (wall, floors, ceilings,
anything else)</li>
<li>Height field - static height field shape, can be used together with terrains.</li>
<li>Polyhedron - dynamic concave shape.</li>
</ul>
<p>Also, there is a similar, but smaller set for 2D (because some shapes degenerate in 2D):</p>
<ul>
<li>Ball - dynamic circle shape.</li>
<li>Cuboid - dynamic rectangle shape.</li>
<li>Capsule - dynamic capsule shape.</li>
<li>Segment - dynamic segment (&quot;line&quot;) shape.</li>
<li>Triangle - dynamic triangle shape.</li>
<li>Trimesh - static triangle mesh shape.</li>
<li>Heightfield - static height field shape.</li>
</ul>
<p><em>Dynamic</em> in both lists means that such shapes can be used together with <em>dynamic</em> rigid bodies, they'll correctly handle
all collisions and simulation will look as it should. <em>Static</em> means that such shape should be used only with <em>static</em>
rigid bodies.</p>
<h2 id="how-to-create-9"><a class="header" href="#how-to-create-9">How to create</a></h2>
<p>Use ColliderBuilder to create an instance of collider from code with any shape you want.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    scene::{
</span><span class="boring">        base::BaseBuilder,
</span><span class="boring">        collider::{ColliderBuilder, ColliderShape},
</span><span class="boring">        graph::Graph,
</span><span class="boring">        node::Node,
</span><span class="boring">    },
</span><span class="boring">};
</span>fn create_capsule_collider(graph: &amp;mut Graph) -&gt; Handle&lt;Node&gt; {
    ColliderBuilder::new(BaseBuilder::new())
        .with_shape(ColliderShape::capsule_y(0.5, 0.2))
        .with_friction(1.0)
        .build(graph)
}
<span class="boring">}
</span></code></pre></pre>
<p>In the editor you can use <code>MainMenu -&gt; Create -&gt; Physics -&gt; Collider</code>, or right-click on a node in <code>World Viewer</code> and
select <code>Add Child -&gt; Physics -&gt; Collider</code>. Collider must be direct child of a rigid body, colliders do nothing on
their own!</p>
<h2 id="using-colliders-for-hit-boxes"><a class="header" href="#using-colliders-for-hit-boxes">Using colliders for hit boxes</a></h2>
<p>You can use colliders to simulate hit boxes for your game characters. It can be done by creating a rigid body with
<code>KinematicPositionBased</code> type and an appropriate collider as a child node. As the last step you need to attach the body
to a bone in your character's model. Here's a quick example from the editor:</p>
<p><img src="fyrox/physics/./hitbox.png" alt="hitbox" /></p>
<p>As you can see, the rigid body has a capsule collider as a child and the body is attached to the neck bone. The body
has <code>KinematicPositionBased</code> type, which will ensure that the body won't be simulated, instead its position will be 
synchronized with the position of the parent bone.</p>
<p>To actually use the hit boxes in your game, you can either use a ray-casting to perform a hit scan or you can use 
contacts information to fetch the stuff with which a hit box was contacted. See <a href="fyrox/physics/./ray.html">Ray casting</a> chapter of the
section.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="joint"><a class="header" href="#joint">Joint</a></h1>
<p>Joint is a configurable link between two rigid bodies, it restricts relative motion of two bodies. Fyrox provides a 
fixed set of joints that are suitable for various applications.</p>
<ul>
<li>Fixed Joint - hard link between two bodies, it is the same is if two rigid bodies were &quot;welded&quot; to each other with 
a metal rod.</li>
<li>Revolute Joint - restricts all translational movement and any rotations around Y and Z axes, but leaves rotation
around local X axis free. An example of the joint from real world is a door hinge, it allows the door to rotate around 
single axis, but not move.</li>
<li>Prismatic Joint - restricts all rotations, movement is allowed along single axis (local X of the joint). An example
of the joint from real world could be a slider that supports drawers on a table.</li>
<li>Ball Joint - restricts all movement, but leaves rotations unrestricted. An example of a ball joint from real world 
could be human shoulder.</li>
</ul>
<p>2D joints does not have revolute joints, because it degenerates into ball joint.</p>
<h2 id="bodies-binding"><a class="header" href="#bodies-binding">Bodies Binding</a></h2>
<p>When the joint is created and all bodies are set to it, it uses self global transform and bodies global transforms to
calculate local frames for bodies. This process is called <em>binding</em>, it happens once when the joint is created, but
can be initiated by moving the joint to some other position by changing local transform of the joint.</p>
<h2 id="how-to-create-10"><a class="header" href="#how-to-create-10">How to create</a></h2>
<p>To create a joint from code use <code>JointBuilder</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    scene::{
</span><span class="boring">        base::BaseBuilder,
</span><span class="boring">        graph::Graph,
</span><span class="boring">        joint::{BallJoint, JointBuilder, JointParams},
</span><span class="boring">        node::Node,
</span><span class="boring">    },
</span><span class="boring">};
</span>fn create_joint(graph: &amp;mut Graph, body1: Handle&lt;Node&gt;, body2: Handle&lt;Node&gt;) -&gt; Handle&lt;Node&gt; {
    JointBuilder::new(BaseBuilder::new())
        .with_body1(body1)
        .with_body2(body2)
        .with_params(JointParams::BallJoint(BallJoint {
            x_limits_enabled: false,
            x_limits_angles: Default::default(),
            y_limits_enabled: false,
            y_limits_angles: Default::default(),
            z_limits_enabled: false,
            z_limits_angles: Default::default(),
        }))
        .build(graph)
}
<span class="boring">}
</span></code></pre></pre>
<p>Once the joint is created, it will bind given bodies, using the process describe in the above section.</p>
<p>To create a joint from editor, use  <code>MainMenu -&gt; Create -&gt; Physics -&gt; Joint</code>, select the new joint and find <code>Body1</code> and
<code>Body2</code> properties. Assign the fields by holding <code>Alt</code> key and drag'n'drop a rigid body to a field. Move the joint to 
correct position to ensure the binding will happen as intended.</p>
<h2 id="limits"><a class="header" href="#limits">Limits</a></h2>
<p>You can restrict motion on primary joint axis (rotational and translational) by setting a limit to desired axis. </p>
<ul>
<li>Ball Joint have three angular limits, one per rotation around an axis. The angle range is given in radians.</li>
<li>Prismatic Joint have only one limit it is maximum linear distance between two bodies along primary joint axis.</li>
<li>Revolute Joint have a single angular limit around primary axis. The angle range is given in radians.</li>
<li>Fixed Joint does not have any limit setting, because it locks all degrees of freedom.</li>
</ul>
<h2 id="usage-1"><a class="header" href="#usage-1">Usage</a></h2>
<p>Joints can be used to create many game entities, such as doors, chains and rag dolls. The most interesting here is 
rag doll. It is used to create realistic behaviour for humans and creatures in games. In general, it is a set of 
rigid bodies, colliders and joints. Where each joint configured to match joints of a creature, for example ball joint
could be used for shoulders, revolute joints for knees and elbows.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ray-casting"><a class="header" href="#ray-casting">Ray Casting</a></h1>
<p>Ray casting allows you to query intersections of a ray with rigid bodies in a scene. Typical usage for ray casting is
hit-scan weapons (weapons that shoots high-speed projectiles), AI collision avoidance, etc. To query intersections,
use physics world instance of a scene graph:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::algebra::{Point3, Vector3},
</span><span class="boring">    scene::graph::{
</span><span class="boring">        physics::{Intersection, RayCastOptions},
</span><span class="boring">        Graph,
</span><span class="boring">    },
</span><span class="boring">};
</span><span class="boring">
</span>fn do_ray_cast(graph: &amp;mut Graph, begin: Vector3&lt;f32&gt;, end: Vector3&lt;f32&gt;) -&gt; Vec&lt;Intersection&gt; {
    let mut buffer = Vec::new();

    let ray_direction = end - begin;

    graph.physics.cast_ray(
        RayCastOptions {
            ray_origin: Point3::from(begin),
            ray_direction,
            max_len: ray_direction.norm(),
            groups: Default::default(),
            sort_results: true,
        },
        &amp;mut buffer,
    );

    buffer
}
<span class="boring">}
</span></code></pre></pre>
<p>The function above will return a collection of intersections that are sorted by intersection distance (a distance from
beginning of the ray to an intersection point). Each intersection is represented by the following structure:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::{
</span><span class="boring">        algebra::{Point3, Vector3},
</span><span class="boring">        pool::Handle,
</span><span class="boring">    },
</span><span class="boring">    scene::{graph::physics::FeatureId, node::Node},
</span><span class="boring">};
</span>pub struct Intersection {
    pub collider: Handle&lt;Node&gt;,
    pub normal: Vector3&lt;f32&gt;,
    pub position: Point3&lt;f32&gt;,
    pub feature: FeatureId,
    pub toi: f32,
}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li><code>collider</code> - a handle of the collider with which intersection was detected. To obtain a handle to rigid body, borrow
the <code>collider</code> and fetch its <code>parent</code> field: <code>graph[collider].parent()</code>.</li>
<li><code>normal</code> - a normal at the intersection position in world coordinates.</li>
<li><code>position</code> - a position of the intersection in world coordinates.</li>
<li><code>feature</code> - additional data that contains a kind of the feature with which intersection was detected as well as its
index. FeatureId::Face might have index that is greater than amount of triangles in a triangle mesh, this means that 
intersection was detected from &quot;back&quot; side of a face. To &quot;fix&quot; that index, simply subtract amount of triangles of a 
triangle mesh from the value.</li>
<li><code>toi</code> - (<code>time of impact</code>) a distance from ray's origin to <code>position</code>.</li>
</ul>
<h2 id="avoiding-unnecessary-allocations"><a class="header" href="#avoiding-unnecessary-allocations">Avoiding unnecessary allocations</a></h2>
<p>As you might've noticed, the function above return <code>Vec&lt;Intersection&gt;</code> which allocates intersections on heap. This is
relatively slow and could be sped up a lot by using static array on stack:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::{
</span><span class="boring">        algebra::{Point3, Vector3},
</span><span class="boring">        arrayvec::ArrayVec,
</span><span class="boring">    },
</span><span class="boring">    scene::graph::{
</span><span class="boring">        physics::{Intersection, RayCastOptions},
</span><span class="boring">        Graph,
</span><span class="boring">    },
</span><span class="boring">};
</span><span class="boring">
</span>fn do_static_ray_cast&lt;const N: usize&gt;(
    graph: &amp;mut Graph,
    begin: Vector3&lt;f32&gt;,
    end: Vector3&lt;f32&gt;,
) -&gt; ArrayVec&lt;Intersection, N&gt; {
    let mut buffer = ArrayVec::&lt;Intersection, N&gt;::new();

    let ray_direction = end - begin;

    graph.physics.cast_ray(
        RayCastOptions {
            ray_origin: Point3::from(begin),
            ray_direction,
            max_len: ray_direction.norm(),
            groups: Default::default(),
            sort_results: true,
        },
        &amp;mut buffer,
    );

    buffer
}

fn usage_example(graph: &amp;mut Graph, begin: Vector3&lt;f32&gt;, end: Vector3&lt;f32&gt;) {
    // Fetch first 32 intersections.
    dbg!(do_static_ray_cast::&lt;32&gt;(graph, begin, end));
}
<span class="boring">}
</span></code></pre></pre>
<p><code>usage_example</code> shows how to use the <code>do_static_ray_cast</code> function - all you need to do is to specify maximum amount of
intersections you're interested in as a generic parameter.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sound"><a class="header" href="#sound">Sound</a></h1>
<p>In Fyrox, sounds are nodes of type Sound, with all the consequent properties and workflows.</p>
<p>Audio files are loaded using the resource manager:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{engine::Engine, scene::Scene};
</span><span class="boring">fn build_node(engine: Engine, scene: &amp;mut Scene) {
</span>let sound = engine
    .resource_manager
    .request_sound_buffer(&quot;/path/to/resource.ogg&quot;);
<span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p>Then, the node is built using the standard builder pattern:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    engine::Engine,
</span><span class="boring">    scene::{
</span><span class="boring">        base::BaseBuilder,
</span><span class="boring">        sound::{SoundBuilder, Status},
</span><span class="boring">        Scene,
</span><span class="boring">    },
</span><span class="boring">};
</span><span class="boring">fn build_node(engine: Engine, scene: &amp;mut Scene) {
</span><span class="boring">let sound = engine
</span><span class="boring">    .resource_manager
</span><span class="boring">    .request_sound_buffer(&quot;/path/to/resource.ogg&quot;);
</span><span class="boring">
</span>let sound_handle = SoundBuilder::new(BaseBuilder::new())
    .with_buffer(Some(sound))
    .with_status(Status::Playing)
    .with_play_once(true)
    .build(&amp;mut scene.graph);
<span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p>There are a few notable things in the example above.</p>
<p>The first is that sounds don't play automatically; in order to do so, we need to invoke <code>.with_status(Status::Playing)</code>.</p>
<p>The second is that sound nodes are not dropped automatically after playback; dropping it can be performed in two ways. One way is to use the convenient builder API <code>.with_play_once(true)</code>; another is to use the graph APIs:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    engine::Engine,
</span><span class="boring">    scene::{
</span><span class="boring">        base::BaseBuilder,
</span><span class="boring">        sound::{SoundBuilder, Status},
</span><span class="boring">        Scene,
</span><span class="boring">    },
</span><span class="boring">};
</span><span class="boring">fn build_node(engine: Engine, scene: &amp;mut Scene) {
</span>let sound_handle = SoundBuilder::new(BaseBuilder::new()).build(&amp;mut scene.graph);

let sound = scene.graph[sound_handle].as_sound();

if sound.status() == Status::Stopped {
    scene.remove_node(sound_handle);
}
<span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p>If we want to play background music (or anyway a repeated sound), we just set the <code>looping</code> property when building the node:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    engine::Engine,
</span><span class="boring">    scene::{base::BaseBuilder, sound::SoundBuilder, Scene},
</span><span class="boring">};
</span><span class="boring">fn build_node(engine: Engine, scene: &amp;mut Scene) {
</span>SoundBuilder::new(BaseBuilder::new())
    .with_looping(true)
    // etc.
    .build(&amp;mut scene.graph);
<span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p>In order to stream large audio files, instead of loading them entirely in memory, the simplest strategy is to create a corresponding <code>.options</code> file, with the following content:</p>
<pre><code class="language-ron">(
  stream: true
)
</code></pre>
<p>If the audio file is called, for example, <code>/path/to/background.ogg</code>, call this <code>/path/to/background.ogg.options</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="effects-wip"><a class="header" href="#effects-wip">Effects (WIP)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="animation-1"><a class="header" href="#animation-1">Animation</a></h1>
<p>The engine offers a quite powerful animation system that will help you to animate your game characters. It built around
skeletal animation and pose blending. Next chapters will help you to understand what this means.</p>
<h2 id="what-is-animation"><a class="header" href="#what-is-animation">What is animation?</a></h2>
<p>Animation is a timeline with tracks, which in their turn have key frames, each key frame holds information about how a 
parameter should change at a moment in time. When playback time changes, the animation calculates intermediate values
between key frames using various sorts of interpolation:</p>
<ul>
<li>Step - value changes from keyframe to keyframe immediately.</li>
<li>Linear - value changes linearly from keyframe to keyframe.</li>
<li>Cubic - value changes from keyframe to keyframe using cubic interpolation.</li>
</ul>
<p>Animation can have multiple tracks, where each track is responsible for animation of a single node (see <code>Limitations</code>
section). </p>
<p>Animations usually prepared in special 3D or 2D modelling software, and then loaded in the engine. Animation loading 
have no difference to a model resource loading. Model resource can hold any number of animations which will be 
instantiated to a scene either by calling <code>Model::instantiate</code> or by <code>Model::retarget_animations</code>.</p>
<h2 id="limitations-3"><a class="header" href="#limitations-3">Limitations</a></h2>
<p>Current version of the engine does <strong>not</strong> support animation of arbitrary object properties. At the moment, you can 
animate only position, scaling, rotation part of a node's transform. While this may seem too limiting, it covers 90%
of animation use cases. </p>
<p>Arbitrary property animation however, allows you to animate any property of an object. For example, you may have an 
animation that animates color of an object. Such functionality is planned for the future versions along with the
animation editor.</p>
<p>Morphing animation is not supported too, but can be done manually by transforming vertices in a model's vertex buffer. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="animation-blending"><a class="header" href="#animation-blending">Animation Blending</a></h1>
<p>Animation blending is a powerful feature that allows you to mix multiple animations into one. Each animation
is mixed with a various weights which in sum gives 1.0 (100%). By having opposite coefficients (k1 = 0 -&gt; 1, k2 = 1 -&gt; 0)
changing in time it is possible to create transition effect. </p>
<p>Handling transitions with all the coefficients is a routine job, the engine can handle it for you giving you some nice
features:</p>
<ul>
<li>Multiple states with smooth transitions between them</li>
<li>Ability to blend multiple animations in one and use it as pose source for blending</li>
<li>Ability to specify a set of variables that will be used as blending coefficients and transition rules.</li>
</ul>
<p>All these features consolidated in so-called animation blending state machine (ABSM). Machine is used to blend multiple 
animation as well as perform automatic &quot;smooth&quot; transition between states. Let's have a quick look at a simple machine
graph:</p>
<pre><code class="language-text">                                                 +-------------+
                                                 |  Idle Anim  |
                                                 +------+------+
                                                        |
          Walk Weight                                   |
+-----------+      +-------+           Walk-&gt;Idle Rule  |
| Walk Anim +------+       |                            |
+-----------+      |       |      +-------+         +---+---+
                   | Blend |      |       +--------&gt;+       |
                   |       +------+ Walk  |         |  Idle |
+-----------+      |       |      |       +&lt;--------+       |
| Aim Anim  +------+       |      +--+----+         +---+---+
+-----------+      +-------+         |                  ^
          Aim Weight                 | Idle-&gt;Walk Rule  |
                                     |                  |
                      Walk-&gt;Run Rule |    +---------+   | Run-&gt;Idle Rule
                                     |    |         |   |
                                     +---&gt;+   Run   +---+
                                          |         |
                                          +----+----+
                                               |
                                               |
                                        +------+------+
                                        |  Run Anim   |
                                        +-------------+
</code></pre>
<p>Here we have Walk, Idle and Run states which use different sources of poses:</p>
<ul>
<li>Walk - is the most complicated here - it uses result of blending between <code>Aim</code> and <code>Walk</code> animations with different 
weights. This is useful if your character can only walk or can walk <em>and</em> aim at the same time. Desired pose determined
by Walk Weight and Aim Weight parameters combination.</li>
<li>Run and idle both directly use animation as pose source.</li>
</ul>
<p>There are four transitions between three states each with its own rule. Rule is just a boolean parameter that indicates 
that transition should be activated. Let's look at the code example of the above state graph:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span>use fyrox::{
  animation::machine::{
      Machine, State, Transition, PoseNode, node::blend::BlendPose,
      Parameter, PlayAnimation, PoseWeight, node::blend::BlendAnimations
  },
  core::pool::Handle
};

// Assume that these are correct handles.
let idle_animation = Handle::default();
let walk_animation = Handle::default();
let aim_animation = Handle::default();
let model_root = Handle::default();

let mut machine = Machine::new(model_root);

let aim = machine.add_node(PoseNode::PlayAnimation(PlayAnimation::new(aim_animation)));
let walk = machine.add_node(PoseNode::PlayAnimation(PlayAnimation::new(walk_animation)));

// Blend two animations together
let blend_aim_walk = machine.add_node(PoseNode::BlendAnimations(
  BlendAnimations::new(vec![
      BlendPose::new(PoseWeight::Constant(0.75), aim),
      BlendPose::new(PoseWeight::Constant(0.25), walk)
  ])
));

let walk_state = machine.add_state(State::new(&quot;Walk&quot;, blend_aim_walk));

let idle = machine.add_node(PoseNode::PlayAnimation(PlayAnimation::new(idle_animation)));
let idle_state = machine.add_state(State::new(&quot;Idle&quot;, idle));

machine.add_transition(Transition::new(&quot;Walk-&gt;Idle&quot;, walk_state, idle_state, 1.0, &quot;WalkToIdle&quot;));
machine.add_transition(Transition::new(&quot;Idle-&gt;Walk&quot;, idle_state, walk_state, 1.0, &quot;IdleToWalk&quot;));
<span class="boring">}
</span></code></pre></pre>
<p>As you can see, everything is quite straightforward. Even such simple state machine requires quite a lot of code, which
can be removed by using ABSM editor. Read the next chapter to learn about it.</p>
<h2 id="multiple-absm-per-model"><a class="header" href="#multiple-absm-per-model">Multiple ABSM per model</a></h2>
<p>You can use multiple machines to animate single model - for example one machine can be used for locomotion and other for 
combat. This means that locomotion machine will take control over lower body and combat machine will control upper body.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="animation-blending-state-machine-absm-editor"><a class="header" href="#animation-blending-state-machine-absm-editor">Animation Blending State Machine (ABSM) Editor</a></h1>
<p>While it is possible to create and manage animation blending and state manually from code, it quickly becomes too 
annoying and hardly manageable. To help you create and manage blending machines in easy way, the engine offers 
a ABSM Editor tool.</p>
<p><img src="fyrox/animation/./absm.png" alt="absm editor" /></p>
<p>The editor has five main parts (windows):</p>
<ul>
<li><code>Previewer</code> - it allows you to see the result of the animation blending. </li>
<li><code>Parameters</code> - allows you to edit various variables that are responsible for transitions, weight parameters for 
blending, etc.</li>
<li><code>State Graph</code> - allows you to create, delete, edit states and transition between them.</li>
<li><code>State Viewer</code> - allows you to edit pose source for a state. Pose source can be represented either by a single 
node that plays an animation, or a series of play animation nodes connected to blending nodes (which can be connected
to other blending nodes, etc.)</li>
<li><code>Inspector</code> - allows you to tweak properties of current selection (states, transitions, nodes, etc.).</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="artificial-intelligence-wip"><a class="header" href="#artificial-intelligence-wip">Artificial Intelligence (WIP)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="behaviour-trees-wip"><a class="header" href="#behaviour-trees-wip">Behaviour Trees (WIP)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="path-finding-wip"><a class="header" href="#path-finding-wip">Path Finding (WIP)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="navigational-meshes-wip"><a class="header" href="#navigational-meshes-wip">Navigational Meshes (WIP)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rendering-wip"><a class="header" href="#rendering-wip">Rendering (WIP)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="shaders"><a class="header" href="#shaders">Shaders</a></h1>
<p>Shader is a set of programs that run directly on graphics adapter. Each program from the set is called
<em>sub-shader</em>. Sub-shaders linked with render pass, each render pass defines &quot;where&quot; to draw an object.
&quot;where&quot; means that you can set up your own render pass and the renderer will use the sub-shader with 
your render pass. For the ease of use there are a number of <a href="fyrox/rendering/shaders.html#predefined-render-passes">predefined render passes</a>.</p>
<p>Shaders have properties of various types that can be used together with materials to draw an object. </p>
<h2 id="shaders-language"><a class="header" href="#shaders-language">Shaders language</a></h2>
<p>The engine uses GLSL shading language for every sub-shader. There are numerous GLSL guides over the 
internet, so there is no need to &quot;re-post&quot; the well documented info again.</p>
<p>There are very few differences:</p>
<ol>
<li>No need to define a version of the shader. Every shader source will be pre-processed, and it will 
get correct version automatically. Preprocessing is needed because the same shader could run on OpenGL
and WebGL (OpenGL ES) which have some differences.</li>
<li>There is a &quot;standard&quot; library of useful methods which is automatically included in every shader source
at preprocessing stage. The library source could be found
<a href="https://github.com/FyroxEngine/Fyrox/blob/master/src/renderer/framework/shaders/shared.glsl">here</a>. It 
is well documented, and you may find some functions useful for you job.</li>
</ol>
<h2 id="structure-1"><a class="header" href="#structure-1">Structure</a></h2>
<p>Shader has rigid structure that could be described in this code snippet:</p>
<pre><code class="language-ron">(
    // A set of properties, there could be any amount of properties.
    properties: [
        (
            // Each property must have a name. This name must match with respective
            // uniforms! That's is the whole point of having properties.
            name: &quot;diffuseTexture&quot;,
            // Value has limited set of possible variants.
            value: Sampler(default: None, fallback: White)
        )
    ],
    // A set of render passes (see next section for more info)
    passes: [
        (
            // Name must match with the name of either standard render pass (see below) or
            // one of your passes.
            name: &quot;Forward&quot;,
            // A set of parameters that regulate renderer pipeline state.
            // This is mandatory field of each render pass.
            draw_parameters: DrawParameters(
                // A face to cull. Either Front or Back.
                cull_face: Some(Back),
                // Color mask. Defines which colors should be written to render target.
                color_write: ColorMask(
                    red: true,
                    green: true,
                    blue: true,
                    alpha: true,
                ),
                // Whether to modify depth buffer or not.
                depth_write: true,
                // Whether to use stencil test or not.
                stencil_test: None,
                // Whether to perform depth test when drawing.
                depth_test: true,
                // Blending options.
                blend: Some(BlendFunc(
                    sfactor: SrcAlpha,
                    dfactor: OneMinusSrcAlpha,
                )),
                // Stencil options.
                stencil_op: StencilOp(
                    fail: Keep,
                    zfail: Keep,
                    zpass: Keep,
                    write_mask: 0xFFFF_FFFF,
                ),
            ),
            // Vertex shader code.
            vertex_shader:
                r#&quot;
                layout(location = 0) in vec3 vertexPosition;
                layout(location = 1) in vec2 vertexTexCoord;
                uniform mat4 rg3d_worldViewProjection;
                out vec2 texCoord;
                void main()
                {
                    texCoord = vertexTexCoord;
                    gl_Position = rg3d_worldViewProjection * vertexPosition;
                }
                &quot;#;
            // Pixel shader code.
            pixel_shader:
                r#&quot;
                // Note that the name of this uniform match the name of the property up above.
                uniform sampler2D diffuseTexture;
                out vec4 FragColor;
                in vec2 texCoord;
                void main()
                {
                    FragColor = diffuseColor * texture(diffuseTexture, texCoord);
                }
                &quot;#;
        )
    ],
)
</code></pre>
<h2 id="properties"><a class="header" href="#properties">Properties</a></h2>
<p>Property is a named variable of some type. Properties are directly tied with the uniforms in the sub-shaders,
for each you can have a property called <code>time</code>, and then you can define <code>uniform float time;</code> in your sub-shader
and the engine will pass a property value to that uniform for you before drawing an object. Properties placed in 
a &quot;global namespace&quot;, which means that every sub-shader has &quot;access&quot; to the properties.</p>
<h2 id="built-in-properties"><a class="header" href="#built-in-properties">Built-in properties</a></h2>
<p>There are a number of built-in properties, the full list is available
<a href="https://docs.rs/fyrox/0.23.1/fyrox/material/shader/struct.Shader.html#built-in-variables">here</a></p>
<h2 id="predefined-render-passes"><a class="header" href="#predefined-render-passes">Predefined render passes</a></h2>
<p>Predefined render passes helps you to create your own shader without a need to create your own render pass 
and to quickly start writing your shaders.</p>
<ul>
<li><strong>GBuffer</strong> - A pass that fills a set with render target sized textures with various data about each rendered 
object. These textures then are used for physically-based lighting. Use this pass when you want the standard 
lighting to work with your objects.</li>
<li><strong>Forward</strong> - A pass that draws an object directly in render target. This pass is very limiting, it does not 
support lighting, shadows, etc. It should be only used to render translucent objects.</li>
<li><strong>SpotShadow</strong> - A pass that emits depth values for an object, later this depth map will be used to render shadows.</li>
<li><strong>PointShadow</strong> - A pass that emits distance from a fragment to a point light, later this depth map will be used
to render shadows.</li>
</ul>
<h2 id="drawing-parameters"><a class="header" href="#drawing-parameters">Drawing parameters</a></h2>
<p>Drawing parameters defines which GPU functions to use and at which state. For example, to render transparent
objects you need to enable blending with specific blending rules. Or you need to disable culling to draw objects
from both sides. This is when draw parameters come in handy. There is a relatively large list of drawing
parameters, and it could confuse a person who isn't used to work with graphics. Thankfully there is a good
documentation about this available <a href="https://docs.rs/fyrox/0.23.1/fyrox/material/shader/struct.Shader.html#drawing-parameters">here</a></p>
<h2 id="vertex-shader"><a class="header" href="#vertex-shader">Vertex shader</a></h2>
<p>Vertex shader operates on single vertices, it must provide at least the position of the vertex
in clipping space. In other words it has to do at least this:</p>
<pre><code class="language-glsl">layout(location = 0) in vec3 vertexPosition;

uniform mat4 rg3d_worldViewProjection; // Note the built-in variable.

void main()
{
    gl_Position = rg3d_worldViewProjection * vertexPosition;
}
</code></pre>
<p>This is the simplest vertex shader, using vertex shaders you can create various graphical effects that affects
vertices.</p>
<h2 id="pixel-shader"><a class="header" href="#pixel-shader">Pixel Shader</a></h2>
<p>Pixel shader (or more precisely - fragment shader), operates on a small fragment of your render target. In general
pixels shaders just writes some color to a render target (or multiple targets) using some program.</p>
<pre><code class="language-glsl">out vec4 FragColor;

void main()
{
    FragColor = vec4(1, 0, 0, 1);
}
</code></pre>
<p>This is the simplest pixel shader, it just fills the render target with red color.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="materials"><a class="header" href="#materials">Materials</a></h1>
<p>Material defines a set of values for a shader. Materials usually contains textures (diffuse, normal, height, emission and other maps), numerical values (floats, integers), vectors, booleans, matrices and arrays of each type, except
textures. Each parameter can be changed in runtime giving you the ability to create animated materials. However,
in practice, most materials are static, this means that once it's created, it won't be changed anymore.</p>
<p>Please keep in mind that the actual &quot;rules&quot; of drawing an entity are stored in the shader, 
<strong>material is only a storage</strong> for specific uses of the shader. </p>
<p>Multiple materials can share the same shader, for example standard shader covers 95% of most common use cases,
and it is shared across multiple materials. The only difference are property values, for example you can draw
multiple cubes using the same shader, but with different textures.</p>
<p>Material itself can be shared across multiple places as well as the shader. This gives you the ability to render
multiple objects with the same material efficiently.</p>
<h2 id="performance-5"><a class="header" href="#performance-5">Performance</a></h2>
<p>It is very important re-use materials as much as possible, because the amount of materials used per frame
significantly correlates with performance. The more unique materials you have per frame, the more work
the renderer and video driver need in order to render a frame and more time the frame will require for
rendering, thus lowering your FPS.</p>
<h2 id="standard-material"><a class="header" href="#standard-material">Standard material</a></h2>
<p>The engine offers a standard PBR material, PBR stands for &quot;Physically-Based Rendering&quot; which gives you the quality
of shading which is very close to materials in real world (to some extent of course).</p>
<p>The standard material can cover 95% of use cases, and it is suitable for almost any kind of game, except maybe
some cartoon-ish or stylized games. </p>
<p>The standard material has quite a lot of properties that can be used to fully utilize the power of PBR rendering:</p>
<ul>
<li><strong>diffuseColor</strong> - an RGBA color that will be used as a base color for you object. <strong>Caveat:</strong> the opacity value
(alpha) will be used only with <code>Forward</code> render path! This means that you will need to switch render path on your
mesh (<a href="fyrox/rendering/materials.html#transparency">see below</a>)</li>
<li><strong>diffuseTexture</strong> - a 2D texture containing the unlit &quot;basic&quot; colors of your object, this is the most commonly
used texture. For example, you can assign a brick wall texture to this property and your object will look like a brick
wall.</li>
<li><strong>normalTexture</strong> - a 2D texture containing per-pixel normal vectors. </li>
<li><strong>metallicTexture</strong> - a 2D texture containing per-pixel metallic factor, where 0 - dielectric, 1 - metal.
In simple words it defines whether your object reflects (1.0) the environment or not (0.0). </li>
<li><strong>roughnessTexture</strong> - a 2D texture containing per-pixel roughness factor, where 0 - completely flat, 1 - 
very rough.</li>
<li><strong>heightTexture</strong> - a 2D texture containing per-pixel displacement value, it is used with parallax mapping to
crate an effect of volume on a flat surface.</li>
<li><strong>emissionTexture</strong> - a 2D texture containing per-pixel emission lighting. You could use this to create emissive
surfaces like small lamps on wall of sci-fi ship, or to create glowing eyes for your monsters that will scare 
the player.</li>
<li><strong>lightmapTexture</strong> - a 2D texture containing per-pixel <strong>static</strong> lighting. It is used to apply precomputed
light to your 3D models, and the most common use case is to lit a static object using a static light. Precomputed
light is very cheap. The engine offers built-in lightmapper that can generate lightmaps for you.</li>
<li><strong>aoTexture</strong> - a 2D texture containing per-pixel shading values, allows you to &quot;bake&quot; shadows in for your 3D
object.</li>
<li><strong>texCoordScale</strong> - a 2D vector that allows you to scale texture coordinates used to sample the textures 
mentioned above (except lightmaps, they're using separate texture coordinates)</li>
<li><strong>layerIndex</strong> - a natural number that is used for decals masking, a decal will only be applied to your mesh
if and only if the decal has matching index. </li>
<li><strong>emissionStrength</strong> - a 3D vector that allows you to set the strength of emission per-channel (R, G, B) for 
your <code>emissionTexture</code></li>
</ul>
<h2 id="transparency"><a class="header" href="#transparency">Transparency</a></h2>
<p>The standard material offers very basic transparency support, to use it you have to explicitly switch render
path on your mesh object. It could be done in this way:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    scene::{mesh::RenderPath, node::Node, Scene},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn set_forward_render_path(scene: &amp;mut Scene, mesh_handle: Handle&lt;Node&gt;) {
</span>    scene.graph[mesh_handle]
        .as_mesh_mut()
        .set_render_path(RenderPath::Forward);
<span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p>After this, your mesh will be rendered using a specialized render pass called Forward which supports alpha-blending
and transparent objects. <strong>Caveat:</strong> Current forward renderer implementation does not support any kind of lighting,
if you need lighting, you will need to use custom shader for that!</p>
<h2 id="material-import"><a class="header" href="#material-import">Material import</a></h2>
<p>When you're loading a 3D model in the engine, the engine tries to convert the materials stored inside to standard
material. In most cases there is no way to create 100% matching material on the fly, instead the engine tries 
to do its best to make sure the material will be imported as closely as possible to the original one. Various 3D modelling
tools use different material system, but all of them allow you to export your 3D model in one of the commonly
used formats (such as FBX).</p>
<h3 id="blender"><a class="header" href="#blender">Blender</a></h3>
<p>When using Blender, make sure you are using <strong>Principled BSDF</strong> material, it is the closest material that can be converted
to engine's standard material at almost 100% fidelity. </p>
<h3 id="3ds-max"><a class="header" href="#3ds-max">3Ds max</a></h3>
<p>It highly depends on the version of the 3Ds max, but in general the default material should work fine.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="light-maps-wip"><a class="header" href="#light-maps-wip">Light Maps (WIP)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="settings"><a class="header" href="#settings">Settings</a></h1>
<p>Renderer has a large set of settings, that allows you to tweak graphics quality to find optimal balance between
rendering quality and performance. Quality settings are represented by the following structure:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::renderer::{CsmSettings, ShadowMapPrecision};
</span>struct QualitySettings {
    point_shadow_map_size: usize,
    point_soft_shadows: bool,
    point_shadows_enabled: bool,
    point_shadows_distance: f32,
    point_shadow_map_precision: ShadowMapPrecision,
    spot_shadow_map_size: usize,
    spot_soft_shadows: bool,
    spot_shadows_enabled: bool,
    spot_shadows_distance: f32,
    spot_shadow_map_precision: ShadowMapPrecision,
    csm_settings: CsmSettings,
    use_ssao: bool,
    ssao_radius: f32,
    light_scatter_enabled: bool,
    fxaa: bool,
    use_parallax_mapping: bool,
    use_bloom: bool,
}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li><code>point_shadow_map_size</code> - size of a cube map face of shadow map texture (in pixels). The higher, the better quality,
but lower performance. Typical values for medium GPU (GTX 1050) is 1024 pixels.</li>
<li><code>point_soft_shadows</code> - should the shadows from point lights be smooth (<code>true</code>) or blocky (<code>false</code>). The latter option
has better performance, but lower quality.</li>
<li><code>point_shadows_enabled</code> - are the shadows from point lights enabled? </li>
<li><code>point_shadows_distance</code> - maximal distance from a camera to draw point light shadows. It is used to disable shadows
on distant lights. The distance is given in meters. The lower the value, the better performance is.</li>
<li><code>point_shadow_map_precision</code> - defines bit-depth (<code>u16</code> or <code>u32</code>) for shadow map pixels. Lower bit depth means better
performance and lower quality.</li>
<li><code>spot_shadow_map_size</code> - size of a shadow map texture for spotlights. The higher, the better quality,
but lower performance. Typical values for medium GPU (GTX 1050) is 1024 pixels.</li>
<li><code>spot_soft_shadows</code> - should the shadows from spotlights be smooth (<code>true</code>) or blocky (<code>false</code>). The latter option
has better performance, but lower quality.</li>
<li><code>spot_shadows_enabled</code> - are the shadows from spotlights enabled? </li>
<li><code>spot_shadows_distance</code> - maximal distance from a camera to draw spotlight shadows. It is used to disable shadows
on distant lights. The distance is given in meters. The lower the value, the better performance is. </li>
<li><code>spot_shadow_map_precision</code> - defines bit-depth (<code>u16</code> or <code>u32</code>) for shadow map pixels.  Lower bit depth means better
performance and lower quality.</li>
<li><code>csm_settings</code> - settings for cascaded shadow maps for directional lights.
<ul>
<li><code>enabled</code> - whether cascaded shadow maps enabled or not. </li>
<li><code>size</code> - size of texture for each cascade.</li>
<li><code>precision</code> - defines bit-depth (<code>u16</code> or <code>u32</code>) for shadow map pixels. Lower bit depth means better
performance and lower quality.</li>
<li><code>pcf</code> - should the shadows from directional lights be smooth (<code>true</code>) or blocky (<code>false</code>). The latter option
has better performance, but lower quality.</li>
</ul>
</li>
<li><code>use_ssao</code> - defines whether the renderer should perform separate screen-space ambient occlusion pass. This option
has relatively small performance impact.</li>
<li><code>ssao_radius</code> - radius of sampling hemisphere used in SSAO, it defines much ambient occlusion will be in your scene.
has no performance impact.</li>
<li><code>light_scatter_enabled</code> - global switch to enable or disable light scattering. Each light have its own scatter switch,
but this one is able to globally disable scatter. Light scattering has medium performance impact, it also depends on 
light count in your scene.</li>
<li><code>fxaa</code> - is full-screen anti-aliasing needed? This option has low performance impact.</li>
<li><code>use_parallax_mapping</code> - defines whether the renderer should use parallax mapping to simulate bumps and dents on
flat surfaces using special textures. This option has low performance impact.</li>
<li><code>use_bloom</code> - defines whether the renderer should draw glowing pixels. This option has low performance impact.</li>
</ul>
<h2 id="presets"><a class="header" href="#presets">Presets</a></h2>
<p>The renderer offers built-in presets for various graphics quality, use <code>QualitySettings::ultra()</code>, 
<code>QualitySettings::high()</code>, <code>QualitySettings::medium()</code> and <code>QualitySettings::low()</code> presets to quickly tune 
quality-performance balance.</p>
<h2 id="how-to-apply"><a class="header" href="#how-to-apply">How to apply</a></h2>
<p>To apply the settings, use <code>renderer.set_quality_settings</code> method:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    renderer::{QualitySettings, Renderer},
</span><span class="boring">    utils::log::Log,
</span><span class="boring">};
</span><span class="boring">
</span>fn set_quality_settings(renderer: &amp;mut Renderer) {
    let mut settings = QualitySettings::high();

    // Disable something.
    settings.use_ssao = false;
    settings.fxaa = false;

    // Apply.
    Log::verify(renderer.set_quality_settings(&amp;settings))
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="render-pass"><a class="header" href="#render-pass">Render Pass</a></h1>
<p>You can define your own render passes that extends the renderer, currently there are render passes only for scenes,
so no custom post-effects (this is planned to be improved in Fyrox 0.28). Render pass has full access to graphics 
framework (which is a thin wrapper around OpenGL) so it can utilize full power of it to implement various graphical
effects.</p>
<h2 id="creating-a-render-pass"><a class="header" href="#creating-a-render-pass">Creating a render pass</a></h2>
<p>Render pass is a complex thing, that requires relatively deep knowledge in computer graphics. It is intended to be used
by experienced graphics programmers. Here's the simplest render pass that renders unit quad without any textures.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::{algebra::Matrix4, pool::Handle, sstorage::ImmutableString},
</span><span class="boring">    renderer::{
</span><span class="boring">        framework::{
</span><span class="boring">            error::FrameworkError,
</span><span class="boring">            framebuffer::DrawParameters,
</span><span class="boring">            geometry_buffer::{GeometryBuffer, GeometryBufferKind},
</span><span class="boring">            gpu_program::{GpuProgram, UniformLocation},
</span><span class="boring">        },
</span><span class="boring">        RenderPassStatistics, Renderer, SceneRenderPass, SceneRenderPassContext,
</span><span class="boring">    },
</span><span class="boring">    scene::{mesh::surface::SurfaceData, Scene},
</span><span class="boring">};
</span><span class="boring">use std::{cell::RefCell, rc::Rc};
</span><span class="boring">
</span>struct MyRenderPass {
    enabled: bool,
    shader: GpuProgram,
    target_scene: Handle&lt;Scene&gt;,
    quad: GeometryBuffer,
    world_view_proj: UniformLocation,
}

impl MyRenderPass {
    pub fn new(
        renderer: &amp;mut Renderer,
        target_scene: Handle&lt;Scene&gt;,
    ) -&gt; Result&lt;Self, FrameworkError&gt; {
        let vs = r#&quot;
                layout(location = 0) in vec3 vertexPosition;
                
                uniform mat4 c;
                         
                void main()
                {
                    gl_Position = worldViewProjectionMatrix * vertexPosition;
                }
            &quot;#;

        let fs = r#&quot;                
                out vec4 FragColor;             
                
                void main()
                {
                    FragColor = vec4(1.0, 0.0, 0.0, 1.0);
                }
            &quot;#;

        let shader = GpuProgram::from_source(&amp;mut renderer.state, &quot;MyShader&quot;, vs, fs)?;

        Ok(Self {
            enabled: true,
            world_view_proj: shader.uniform_location(
                &amp;renderer.state,
                &amp;ImmutableString::new(&quot;worldViewProjectionMatrix&quot;),
            )?,
            target_scene,
            quad: GeometryBuffer::from_surface_data(
                &amp;SurfaceData::make_quad(&amp;Matrix4::identity()),
                GeometryBufferKind::StaticDraw,
                &amp;mut renderer.state,
            ),
            shader,
        })
    }
}

impl SceneRenderPass for MyRenderPass {
    fn on_ldr_render(
        &amp;mut self,
        ctx: SceneRenderPassContext,
    ) -&gt; Result&lt;RenderPassStatistics, FrameworkError&gt; {
        let mut stats = RenderPassStatistics::default();

        // Make sure to render only to target scene.
        if self.enabled &amp;&amp; ctx.scene_handle == self.target_scene {
            stats += ctx.framebuffer.draw(
                &amp;self.quad,
                ctx.pipeline_state,
                ctx.viewport,
                &amp;self.shader,
                &amp;DrawParameters::default(),
                |mut program| {
                    program.set_matrix4(&amp;self.world_view_proj, &amp;Matrix4::identity());
                },
            );
        }

        Ok(stats)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>The code snippet shows how to create a shader, find its uniforms, and finally how to actually render something in 
target frame buffer.</p>
<h2 id="registering-a-render-pass"><a class="header" href="#registering-a-render-pass">Registering a render pass</a></h2>
<p>Every render pass must be registered in the renderer, otherwise it won't be used. You can register a render pass using
<code>add_render_pass</code> method of the <code>Renderer</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::renderer::{Renderer, SceneRenderPass};
</span><span class="boring">use std::{cell::RefCell, rc::Rc};
</span><span class="boring">
</span><span class="boring">struct MyRenderPass;
</span><span class="boring">impl SceneRenderPass for MyRenderPass {}
</span><span class="boring">
</span>fn usage_example(renderer: &amp;mut Renderer, render_pass: MyRenderPass) {
    let shared_pass = Rc::new(RefCell::new(render_pass));
    // You can share the pass across multiple places to be able to control it.
    renderer.add_render_pass(shared_pass);
}
<span class="boring">}
</span></code></pre></pre>
<p>Please notice that we've wrapped render pass in <code>Rc&lt;RefCell&lt;..&gt;&gt;</code>, this means that you can share it across multiple places
and modify its data from the code of your game.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="asset-management-1"><a class="header" href="#asset-management-1">Asset Management</a></h1>
<p>This chapter covers asset management in the engine. Asset management is performed by <code>Asset Browser</code> in the editor 
and by <code>ResourceManager</code> from API.</p>
<h2 id="general-info"><a class="header" href="#general-info">General Info</a></h2>
<p>Assets loading is asynchronous, it is possible to load multiple assets in parallel or load until a specific asset is 
loaded.</p>
<h2 id="asset-browser"><a class="header" href="#asset-browser">Asset Browser</a></h2>
<p>Asset browser allows you to preview your assets and edit their import properties. It looks something like this (keep
in mind that the screenshot could be outdated).</p>
<p><img src="fyrox/resources/asset_browser.png" alt="Asset Browser" /></p>
<p>There are three main areas in it:</p>
<ol>
<li>Left directory tree - shows all <em>directories</em> starting from project root. It does <em>not</em> show any files, this is 
for what the center section is.</li>
<li>Center asset previewer - shows all assets from selected directory. The path at the top of the section shows asset
path.</li>
<li>Right asset import options inspector - it shows import properties of selected asset.</li>
</ol>
<p>Typical workflow could look like this:</p>
<ol>
<li>Select desired directory from the left tree</li>
<li>Select desired asset in the center previewer</li>
<li>Edit import properties of selected asset and click &quot;Apply&quot; button to save import options and re-load the asset with
new options.</li>
</ol>
<p>Check next chapters to learn how to manage specific asset types and what their import does what.</p>
<h2 id="api-docs"><a class="header" href="#api-docs">API Docs</a></h2>
<p>Please read API docs <a href="https://docs.rs/fyrox/latest/fyrox/engine/resource_manager/index.html">here</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="model-resources"><a class="header" href="#model-resources">Model resources</a></h1>
<h2 id="supported-formats"><a class="header" href="#supported-formats">Supported formats</a></h2>
<p>Fyrox supports these file formats for 3D models:</p>
<ul>
<li>FBX - standard game development industry 3D model exchange format</li>
<li>RGS - native scenes format produced by Fyroxed (the editor)</li>
</ul>
<p>The list could be extended in the future.</p>
<h2 id="instantiation"><a class="header" href="#instantiation">Instantiation</a></h2>
<p>Model must be instantiated in your scene, there is no other way of using it. To do this, you can either use drag'n'drop
from Asset Browser in the editor or instantiate the model dynamically from code:</p>
<pre><pre class="playground"><code class="language-rust no_run edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    engine::resource_manager::ResourceManager,
</span><span class="boring">    scene::{node::Node, Scene},
</span><span class="boring">};
</span><span class="boring">use std::path::Path;
</span>async fn instantiate_model(
    path: &amp;Path,
    resource_manager: ResourceManager,
    scene: &amp;mut Scene,
) -&gt; Handle&lt;Node&gt; {
    // Load model first. Alternatively, you can store resource handle somewhere and use it for
    // instantiation.
    let model = resource_manager.request_model(path).await.unwrap();

    model.instantiate(scene).root
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="material-import-1"><a class="header" href="#material-import-1">Material import</a></h2>
<p>The engine tries to import materials as close as possible to originals in the model, however it is not always possible
because some 3D modelling software could use different shading models. By default, the engine tries to convert
everything to PBR materials, so if you have a 3D model with a special material made for cartoon shading, the
engine will still import it as PBR material (with lots of missing textures of course). You should take this into
account when working with something other than PBR materials. </p>
<p>In cases when your 3D model have some weird materials, you should create appropriate materials and shaders <em>manually</em>,
the engine is not a magic tool, it has some defaults that do not cover all possible cases.</p>
<p>It is also possible to specify how to resolve textures while loading a 3D model, select your model in the <code>Asset Browser</code>
and there will be import options right below the model preview:</p>
<p><img src="fyrox/resources/model_import.png" alt="model import" /></p>
<p>It is also possible to specify such options manually. To do that, you need to create import options file with the 
following content near your 3D model (this is what the editor does for you):</p>
<pre><code class="language-text">(
    material_search_options: RecursiveUp
)
</code></pre>
<p>The file must have the <code>.options</code> additional extension. For example, if you have a <code>foo.fbx</code> model, the options
file should have <code>foo.fbx.options</code> name. Even if it is possible to modify it by hand, it is strongly advised to use
the editor to edit import options, because it reduces the chance of messing up.</p>
<h2 id="tips-for-blender"><a class="header" href="#tips-for-blender">Tips for Blender</a></h2>
<p>Blender's FBX exporter has exporting scale properties usually set to 100%, this may lead to incorrect scale
of your model in the engine. It will have <code>(100.0, 100.0, 100.0)</code> scale which is very huge. To fix that, set
the scale in the exporter to <code>0.01</code>.</p>
<h2 id="tips-for-3ds-max"><a class="header" href="#tips-for-3ds-max">Tips for 3Ds Max</a></h2>
<p>Latest versions of 3Ds max have node-based material editor which creates some &quot;junk&quot; nodes which may mess up
material import. To prevent any issues with that, you should clean all assignments to material slots to use
maps directly.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="textures-1"><a class="header" href="#textures-1">Textures</a></h1>
<p>Texture is an image that is used to fill faces to add details to them. In most cases textures are just 2D images, however 
there are some exclusions to that - for example cube maps, that may be used for environment mapping. Fyrox supports 1D,
2D, 3D and Cube textures.</p>
<h2 id="supported-formats-1"><a class="header" href="#supported-formats-1">Supported formats</a></h2>
<p>To load images and decode them, Fyrox uses image and ddsfile crates. Here is the list of supported formats: png,
tga, bmp, dds, jpg, gif, tiff, dds.</p>
<h2 id="compressed-textures"><a class="header" href="#compressed-textures">Compressed textures</a></h2>
<p>Fyrox supports most commonly used formats of compressed textures: DXT1, DXT3, DXT5. Such textures can be loaded
only from <code>DDS</code> files. You can specify on-demand texture compression in import options (see below), it works for every
texture format except DDS. It is meant to be used when you don't want to bother with DDS format, there are two
compression methods:</p>
<ul>
<li><code>Quality</code> - has 4:1 compression ratio, supports full 8-bit alpha channel. Textures with gradients will most likely
suffer from noticeable banding.</li>
<li><code>Speed</code> - has lower quality compared to <code>Quality</code> mode, but it has 8:1 compression ratio for texture without alpha
channel and 6:1 with alpha channel. Keep in mind, that alpha channel in this mode supports only 1 bit - it is either
enabled or not.</li>
</ul>
<p>Compressed textures usually does not support color gradient very well, if you have a texture with a lot of colors and
gradients, then you'll most likely get compressed texture with lots of graphical artifacts such as banding.</p>
<p>It is also worth mentioning, that you should <strong>never</strong> use compression with normal maps, it can significantly distort 
normals because normal maps usually have lots of color gradients.</p>
<h2 id="import-options"><a class="header" href="#import-options">Import options</a></h2>
<p>It is possible to define custom import options. Using import options you could set desired compression quality,
filtering, wrapping, etc. Import options should be defined using Asset Browser in the editor:</p>
<p><img src="fyrox/resources/texture_import.png" alt="texture import" /></p>
<p>It is also possible to define import options manually in a separate file with the same name as the source
texture, but with additional extension <code>options</code>, this is what the editor does for you. For example, you have a 
<code>foo.jpg</code> texture, a file with import options should be called <code>foo.jpg.options</code>. Its content may look something like
this:</p>
<pre><code class="language-text">(
    minification_filter: Linear,
    magnification_filter: Linear,
    s_wrap_mode: Repeat,
    t_wrap_mode: ClampToEdge,
    anisotropy: 8.0,
    compression: NoCompression,    
)
</code></pre>
<p>Even if it is possible to modify it by hand, it is strongly advised to use the editor to edit import options, because
it reduces chances of messing up.</p>
<h2 id="render-target"><a class="header" href="#render-target">Render target</a></h2>
<p>Texture can be used as a render target to render a scene in it. To do this you should use <code>new_render_target</code> method and
pass its result to scene's render target property. Renderer will automatically provide you info about metrics of
texture, but it won't give you access to pixels of render target.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sound-wip"><a class="header" href="#sound-wip">Sound (WIP)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="curve-wip"><a class="header" href="#curve-wip">Curve (WIP)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="animation-blending-state-machine-wip"><a class="header" href="#animation-blending-state-machine-wip">Animation Blending State Machine (WIP)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="user-interface"><a class="header" href="#user-interface">User Interface</a></h1>
<p>Fyrox features an extremely powerful and flexible node-based user interface system. Power and flexibility comes with
a certain price: it has a steep learning curve. This chapter will cover user interface usage in the engine, explain
basic concepts, provide information about most commonly used widgets, and so on.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basic-concepts"><a class="header" href="#basic-concepts">Basic concepts</a></h1>
<p>This chapter should help you understand basic concepts lying in the foundation of the GUI in the engine.</p>
<h2 id="stateful"><a class="header" href="#stateful">Stateful</a></h2>
<p>*<em>Stateful UI</em> means that we can create and destroy widgets when we need to, it is the opposite approach of 
<strong>immediate-mode</strong> or <strong>stateless UIs</strong> when you don't have long-lasting state for your widgets
(usually stateless UI hold its state only for one or two frames). </p>
<p>Stateful UI is much more powerful and flexible, it allows you to have complex layout system without having to 
create hacks to create complex layout as you'd do in immediate-mode UIs. It is also much faster in terms of 
performance.</p>
<p>Stateful UI is a must for complex user interfaces that requires rich layout and high performance. I'm not telling
that you <em>can't</em> do it in immediate mode UI, you can, but using tons of hacks. See <a href="fyrox/ui/basic_concepts/basic_concepts.html#layout">Layout</a> section for
more info.</p>
<h2 id="node-based-architecture"><a class="header" href="#node-based-architecture">Node-based architecture</a></h2>
<p>Every user interface could be represented as a set of small blocks that have hierarchical bonding between each
other. For example a button could be represented using two parts: a background and a foreground. Usually the background
is just a simple rectangle (either a vector or bitmap), and a foreground is a text. The text (the foreground widget)
is a child object of the rectangle (the background widget). These two widgets forms another, more complex widget that
we call button. Graphically it will look like this:</p>
<p><img src="fyrox/ui/basic_concepts/./button.svg" alt="Button" /></p>
<p>On the right side of the image we can see the generic button and on the left side, we can see its hierarchical 
structure. Such approach allows us to modify the look of the button as we wish, we can create a button with 
image background, or with any vector image, or even other widgets. The foreground can be anything too, it can also
contain its own complex hierarchy, like a pair of an icon with a text and so on.</p>
<h2 id="composition"><a class="header" href="#composition">Composition</a></h2>
<p>Every widget in the engine uses composition to build more complex widgets. All widgets (and respective builders) contains
<code>Widget</code> instance inside, it provides basic functionality the widget such as layout information, hierarchy, default
foreground and background brushes (their usage depends on derived widget), render and layout transform and so on. </p>
<h2 id="component-querying"><a class="header" href="#component-querying">Component Querying</a></h2>
<p>Many widgets provide component querying functionality - you can get an immutable reference to inner component by its type. It is 
used instead of type casting in many places. Component querying is much more flexible compared to direct type casting. 
For example, you may want to build a custom <a href="fyrox/ui/basic_concepts/../tree.html">Tree</a> widget, you want your CustomTree to inherit all the 
functionality from the Tree, but add something new. The Tree widget can manage its children subtrees, but it needs to
somehow get required data from subtree. Direct type casting would fail in this case, because now you have something
like this:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::gui::tree::Tree;
</span>struct CustomTree {
    tree: Tree,
    my_data: u32
}
<span class="boring">}
</span></code></pre></pre>
<p>On other hand, component querying will work fine, because you can query inner component (Tree in our case). Please note 
that this has nothing similar with ECS and stuff, it is made to circumvent Rust's lack of inheritance.</p>
<h2 id="message-passing"><a class="header" href="#message-passing">Message passing</a></h2>
<p>The engine uses message passing mechanism for any UI logic. What does that mean? Let's see at the button from the
previous section and imagine we want to change its text. To do that we need to explicitly &quot;tell&quot; the button's text
widget to change its content to something new. This is done by sending a message to the widget.</p>
<h3 id="message-routing-strategies"><a class="header" href="#message-routing-strategies">Message routing strategies</a></h3>
<p>Message passing mechanism works in pair with various routing strategies that allows you to define how the message 
will &quot;travel&quot; across the tree of nodes.</p>
<ol>
<li>Bubble - a message starts its way from a widget and goes up on hierarchy until it reaches root node of hierarchy.
Nodes that lies outside that path won't receive the message. This is the most important message routing strategy, that
is used for <strong>every</strong> node by default.</li>
<li>Direct - a message passed directly to every node that are capable to handle it. There is actual routing in this 
case. Direct routing is used in rare cases when you need to catch a message outside its normal &quot;bubble&quot; route.</li>
</ol>
<h2 id="layout"><a class="header" href="#layout">Layout</a></h2>
<p>The engine uses very complex, yet powerful layout system that allows you to build complex user interfaces with 
complex layout. Layout pass has two <em>recursive</em> sub-passes:</p>
<ol>
<li>Measurement - the sub-pass is used to fetch the desired size of each node in hierarchy.</li>
<li>Arrangement - the sub-pass is used to set final position and size of each node in hierarchy.</li>
</ol>
<p>Such split is required because we need to know desired size of each node in hierarchy before we can actually do an
arrangement.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="general-rules-1"><a class="header" href="#general-rules-1">General rules</a></h1>
<p>This chapter covers general rules that will help you to write code that will be easy to understand.</p>
<h2 id="fluent-syntax"><a class="header" href="#fluent-syntax">Fluent syntax</a></h2>
<p>Widget builders supports fluent syntax, this means that you can create your widget in series of nested 
call of other widget builders. In code, it looks something like this:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    engine::resource_manager::ResourceManager,
</span><span class="boring">    gui::{
</span><span class="boring">        button::ButtonBuilder, image::ImageBuilder, widget::WidgetBuilder, UiNode,
</span><span class="boring">        UserInterface,
</span><span class="boring">    },
</span><span class="boring">    utils::into_gui_texture,
</span><span class="boring">};
</span><span class="boring">fn create_fancy_button(ui: &amp;mut UserInterface, resource_manager: ResourceManager) -&gt; Handle&lt;UiNode&gt; {
</span><span class="boring">let ctx = &amp;mut ui.build_ctx();
</span>ButtonBuilder::new(WidgetBuilder::new())
    .with_back(
        ImageBuilder::new(WidgetBuilder::new())
            .with_texture(into_gui_texture(
                resource_manager.request_texture(&quot;path/to/your/texture&quot;),
            ))
            .build(ctx),
    )
    .with_text(&quot;Click me!&quot;)
    .build(ctx)
<span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p>This code snippet creates a button with an image and a text. Actually it creates <strong>three</strong> widgets, that forms 
complex hierarchy. The topmost widget in hierarchy is the <code>Button</code> widget itself, it has two children widgets:
background image and a text. Background image is set explicitly by calling image widget builder with specific 
texture. The text is created implicitly, the button builder creates <code>Text</code> widget for you and attaches it to 
the button. The structure of the button can contain <em>any</em> amount of nodes, for example you can create a button
that contains text with some icon. To do that, replace <code>.with_text(&quot;My Button&quot;)</code> with this:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    engine::resource_manager::ResourceManager,
</span><span class="boring">    gui::{
</span><span class="boring">        button::ButtonBuilder,
</span><span class="boring">        grid::{Column, GridBuilder, Row},
</span><span class="boring">        image::ImageBuilder,
</span><span class="boring">        text::TextBuilder,
</span><span class="boring">        widget::WidgetBuilder,
</span><span class="boring">        UiNode, UserInterface,
</span><span class="boring">    },
</span><span class="boring">    utils::into_gui_texture,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn create_fancy_button(
</span><span class="boring">    ui: &amp;mut UserInterface,
</span><span class="boring">    resource_manager: ResourceManager,
</span><span class="boring">) -&gt; Handle&lt;UiNode&gt; {
</span><span class="boring">    let ctx = &amp;mut ui.build_ctx();
</span><span class="boring">
</span><span class="boring">    ButtonBuilder::new(WidgetBuilder::new())
</span>        .with_content(
            GridBuilder::new(
                WidgetBuilder::new()
                    .with_child(
                        ImageBuilder::new(WidgetBuilder::new().on_column(0))
                            .with_texture(into_gui_texture(
                                resource_manager.request_texture(&quot;your_icon&quot;),
                            ))
                            .build(ctx),
                    )
                    .with_child(
                        TextBuilder::new(WidgetBuilder::new().on_column(1))
                            .with_text(&quot;My Button&quot;)
                            .build(ctx),
                    ),
            )
            .add_row(Row::stretch())
            .add_column(Column::auto())
            .add_column(Column::stretch())
            .build(ctx),
        )
<span class="boring">      .build(ctx)
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p>Quite often you need to store a handle to a widget in a variable, there is one neat trick to do that preserving
the fluent syntax:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    engine::resource_manager::ResourceManager,
</span><span class="boring">    gui::{
</span><span class="boring">        button::ButtonBuilder, image::ImageBuilder, widget::WidgetBuilder, UiNode,
</span><span class="boring">        UserInterface,
</span><span class="boring">    },
</span><span class="boring">    utils::into_gui_texture,
</span><span class="boring">};
</span><span class="boring">fn create_fancy_button(ui: &amp;mut UserInterface, resource_manager: ResourceManager) -&gt; Handle&lt;UiNode&gt; {
</span><span class="boring">let ctx = &amp;mut ui.build_ctx();
</span>let image;
ButtonBuilder::new(WidgetBuilder::new())
    .with_back({
        image = ImageBuilder::new(WidgetBuilder::new())
            .with_texture(into_gui_texture(
                resource_manager.request_texture(&quot;path/to/your/texture&quot;),
            ))
            .build(ctx);
        image
    })
    .with_text(&quot;Click me!&quot;)
    .build(ctx)
<span class="boring">}
</span>// image now contains a handle of the Image widget 
<span class="boring">}
</span></code></pre></pre>
<h2 id="should-i-create-a-custom-widget-or-use-composition-of-other-widgets"><a class="header" href="#should-i-create-a-custom-widget-or-use-composition-of-other-widgets">Should I create a custom widget or use composition of other widgets?</a></h2>
<p>The answer depends on the use case, but the general rules here is quite simple: </p>
<ul>
<li>If your widget exist in a single instance, then there is no need to create a custom widget for it.</li>
<li>If you need to create multiple instances of your widget, and each widget will carry some specific data, then you
definitely need a custom widget.</li>
</ul>
<p>Custom widgets have some limitations that could be limiting, one of them is that custom widgets do not have 
access to your code, since they're &quot;living&quot; inside UI and know nothing about the &quot;environment&quot; where they're 
being used.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="font"><a class="header" href="#font">Font</a></h1>
<p>Font is used to store graphical representation of characters. The engine supports TTF and OTF fonts, you can load
pretty much any font from the internet and use it as is.</p>
<h2 id="create-new-font"><a class="header" href="#create-new-font">Create New Font</a></h2>
<p>There are two ways to create font instance - either load font from file, or load it directly from memory.</p>
<h3 id="loading-font-from-file"><a class="header" href="#loading-font-from-file">Loading Font From File</a></h3>
<p>The easiest way to create a font is load it from file:</p>
<pre><pre class="playground"><code class="language-rust no_run edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::gui::ttf::Font;
</span>async fn load_font_from_file() -&gt; Font {
    let character_set = Font::default_char_set(); // ASCII character set.
    Font::from_file(&quot;path/to/your/font.ttf&quot;, 20.0, character_set)
        .await
        .unwrap()
}
<span class="boring">}
</span></code></pre></pre>
<p>Please note, that this function is <code>async</code> due to the fact that it supports <code>fetch</code> API on WebAssembly, which does
remote file fetching which is asynchronous by its nature. If you don't plan to support WebAssembly and don't want to
use <code>async</code>, then the next section is for you.</p>
<h3 id="creating-font-from-memory"><a class="header" href="#creating-font-from-memory">Creating Font From Memory</a></h3>
<p>This option could be useful, if you already have your font loaded into memory. Loading font from data buffer is very
simple:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::gui::ttf::Font;
</span>fn load_font_from_memory(data: &amp;[u8]) -&gt; Font {
    let character_set = Font::default_char_set(); // ASCII character set.
    Font::from_memory(data, 20.0, character_set).unwrap()
}
<span class="boring">}
</span></code></pre></pre>
<p><code>data</code> input parameter could be a buffer that contains any valid TTF/OTF font. For example, you can load TTF file into
a data buffer and create font using the data buffer:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::gui::ttf::Font;
</span><span class="boring">use std::{fs::File, io::Read};
</span>fn load_font_from_memory() -&gt; Font {
    let character_set = Font::default_char_set(); // ASCII character set.

    let mut data = Vec::new();
    File::open(&quot;path/to/your/font.ttf&quot;)
        .unwrap()
        .read_to_end(&amp;mut data)
        .unwrap();

    Font::from_memory(data, 20.0, character_set).unwrap()
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="default-font"><a class="header" href="#default-font">Default Font</a></h2>
<p>User interface provides its own font of fixed size, it is enough to cover most of the use cases, but the default font
includes only ASCII characters, if you need extended character set, you can replace default font using the following
code snippet:</p>
<pre><pre class="playground"><code class="language-rust no_run edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::gui::{ttf::Font, UserInterface};
</span>async fn set_default_font(ui: &amp;mut UserInterface) {
    // Select character set.
    let character_set = Font::korean_char_set();
    // Load font.
    let new_font = Font::from_file(&quot;path/to/your/font.ttf&quot;, 20.0, character_set)
        .await
        .unwrap();
    // Set as default font.
    ui.default_font.set(new_font)
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="how-to-change-font-size"><a class="header" href="#how-to-change-font-size">How to Change Font Size</a></h2>
<p>Unfortunately, you need to create new font instance for that, there is a 
<a href="https://github.com/FyroxEngine/Fyrox/issues/74">tracking issue</a> for that. Use any method from above paragraphs.</p>
<h2 id="character-set"><a class="header" href="#character-set">Character Set</a></h2>
<p>Current font implementation requires you to define fixed character set while creating an instance. What is character
set and how it can be extended? Character set is just a set of ranges from Unicode, for example here's korean character
set:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::ops::Range;
</span>pub fn korean_char_set() -&gt; &amp;'static [Range&lt;u32&gt;] {
    &amp;[
        // Basic Latin + Latin Supplement
        0x0020..0x00FF,
        // Korean alphabets
        0x3131..0x3163,
        // Korean characters
        0xAC00..0xD7A3,
        // Invalid
        0xFFFD..0xFFFD,
    ]
}
<span class="boring">}
</span></code></pre></pre>
<p>You can create custom character set yourself by defining desired ranges from Unicode.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="theme"><a class="header" href="#theme">Theme</a></h1>
<p>The engine has an ability to customize the look of widgets, however it is not centralized, and has to be done 
per widget. Check <code>Theme</code> section of each widget.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="widgets"><a class="header" href="#widgets">Widgets</a></h1>
<p>The subsections of this chapter explains how to use every widget built into Fyrox. The widgets in the table of contents to the left are ordered in alphebetical order. However, below we will order them by primary function to help introduce them to new users.</p>
<h2 id="containers"><a class="header" href="#containers">Containers</a></h2>
<p>The Container widgets primary purpose is to contain other widgets. They are mostly used as a tool to layout the UI in visually different ways.</p>
<ul>
<li><a href="fyrox/ui/./stack_panel.html">Stack panel</a>: The Stack Panel arranges widgets in a linear fashion, either vertically or horizontally depending on how it's setup.</li>
<li><a href="fyrox/ui/./wrap_panel.html">Wrap Panel</a>: The Wrap Panel arranges widgets in a linear fashion but if it overflows the widgets are continued adjacent to the first line. Can arrange widgets either vertically or horizontally depending on how it's setup.</li>
<li><a href="fyrox/ui/./grid.html">Grid</a>: The Grid arranges widgets into rows and columns with given size constraints.</li>
<li><a href="fyrox/ui/./canvas.html">Canvas</a>: The Canvas arranges widgets with pixel perfect precision.</li>
<li><a href="fyrox/ui/./window.html">Window</a>: The Window holds other widgets in a panel that can be configured at setup to be move-able, expanded and contracted via user input, exited, and have a displayed label. The window has a title bar to assist with these features.
<ul>
<li><a href="fyrox/ui/./message_box.html">Message Box</a>: The Message Box is a Window that has been streamlined to show standard confirmation/information dialogues, for example, closing a document with unsaved changes. It has a title, some text, and a fixed set of buttons (Yes, No, Cancel in different combinations).</li>
</ul>
</li>
<li><a href="fyrox/ui/./menu.html">Menu</a>: The Menu is a root container for Menu Items, an example could be a menu strip with File, Edit, View, etc items.</li>
<li><a href="fyrox/ui/./popup.html">Popup</a>: The Popup is a panel that locks input to its content while it is open. A simple example of it could be a context menu.</li>
<li><a href="fyrox/ui/./scroll_viewer.html">Scroll Viewer</a>: The ScrollViewer is a wrapper for Scroll Panel that adds two scroll bars to it.
<ul>
<li><a href="fyrox/ui/./scroll_panel.html">Scroll Panel</a>: The Scroll Panel is a panel that allows you apply some offset to children widgets. It is used to create &quot;scrollable&quot; area in conjunction with the Scroll Viewer.</li>
</ul>
</li>
<li><a href="fyrox/ui/./expander.html">Expander</a>: The Expander handles hiding and showing multiple panels of widgets in an accordian style UI element. Multiple panels can be shown or hidden at any time based on user input.</li>
<li><a href="fyrox/ui/./tab_control.html">Tab Control</a>: The Tab Control handles hiding several panels of widgets, only showing the one that the user has selected.</li>
<li><a href="fyrox/ui/./dock.html">Docking Manager</a>: The Docking manager allows you to dock windows and hold them in-place.</li>
<li><a href="fyrox/ui/./tree.html">Tree</a>: The Tree allows you to create views for hierarchical data.</li>
</ul>
<h2 id="visual"><a class="header" href="#visual">Visual</a></h2>
<p>The Visual widgets primary purpose is to provide the user feedback generally without the user directly interacting with them.</p>
<ul>
<li><a href="fyrox/ui/./text.html">Text</a>: The Text widget is used to display a string to the user.</li>
<li><a href="fyrox/ui/./image.html">Image</a>: The Image widget is used to display a pixel image to the user.</li>
<li><a href="fyrox/ui/./vector_image.html">Vector Image</a>: The Vector Image is used to render vector instructions as a graphical element.</li>
<li><a href="fyrox/ui/./rect.html">Rect</a>: The Rect allows you to specify numeric values for X, Y, Width, and Height of a rectangle.</li>
<li><a href="fyrox/ui/./progress_bar.html">Progress Bar</a>: The Progress Bar shows a bar whoes fill state can be adjusted to indicate visually how full something is, for example how close to 100% is a loading process.</li>
<li><a href="fyrox/ui/./decorator.html">Decorator</a>: The Decorator is used to style any widget. It has support for different styles depending on various events like mouse hover or click.
<ul>
<li><a href="fyrox/ui/./border.html">Border</a>: The Border widget is used in conjunction with the Decorator widget to provide configurable boarders to any widget for styling purposes.</li>
</ul>
</li>
</ul>
<h2 id="controls-1"><a class="header" href="#controls-1">Controls</a></h2>
<p>Control widgets primary purpose is to provide users with intractable UI elements to control some aspect of the program.</p>
<ul>
<li><a href="fyrox/ui/./creating_button.html">Button</a>: The Button provides a press-able control that can contain other UI elements, for example a Text or Image Widget.</li>
<li><a href="fyrox/ui/./checkbox/check_box.html">Check Box</a>: The Check Box is a toggle-able control that can contain other UI elements, for example a Text or Image Widget.</li>
<li><a href="fyrox/ui/./text_box.html">Text Box</a>: The Text Box is a control that allows the editing of text.</li>
<li><a href="fyrox/ui/./scroll_bar.html">Scroll Bar</a>: The Scroll Bar provides a scroll bar like control that can be used on it's own as a data input or with certain other widgets to provide content scrolling capabilities.</li>
<li><a href="fyrox/ui/./numeric.html">Numeric Field</a>: The Numeric Field provides the ability to adjust a number via increment and decrement buttons or direct input. The number can be constrained to remain inside a specific range or have a specific step.</li>
<li><a href="fyrox/ui/./range.html">Range</a>: The Range allows the user to edit a numeric range - specify its begin and end values.</li>
<li><a href="fyrox/ui/./list_view.html">List View</a>: The List View provides a control where users can select from a list of items.</li>
<li><a href="fyrox/ui/./dropdown_list.html">Dropdown List</a>: The Drop-down List is a control which shows the currently selected item and provides a drop-down list to select an item.</li>
<li><a href="fyrox/ui/./file_browser.html">File Browser</a>: The File Browser is a tree view of the file system allowing the user to select a file or folder.</li>
<li><a href="fyrox/ui/./curve_editor.html">Curve Editor</a>: The CurveEditor allows editing parametric curves - adding points, and setting up transitions (constant, linear, cubic) between them.</li>
<li><a href="fyrox/ui/./inspector.html">Inspector</a>: The Inspector automatically creates and handles the input of UI elements based on a populated Inspector Context given to it allowing the user to adjust values of a variety of models without manually creating UI's for each type.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="button"><a class="header" href="#button">Button</a></h1>
<h2 id="simple-button-with-text"><a class="header" href="#simple-button-with-text">Simple button with text</a></h2>
<p>To create a simple button with text you should do something like this:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    gui::{button::ButtonBuilder, widget::WidgetBuilder, UiNode, UserInterface},
</span><span class="boring">};
</span>fn create_button(ui: &amp;mut UserInterface) -&gt; Handle&lt;UiNode&gt; {
    ButtonBuilder::new(WidgetBuilder::new())
        .with_text(&quot;Click me!&quot;)
        .build(&amp;mut ui.build_ctx())
}
<span class="boring">}
</span></code></pre></pre>
<p>How to create a button using custom dimensions (100x100) and custom text alignment (Vertical centered and Horizontal 
right aligned):</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    gui::{button::ButtonBuilder, widget::WidgetBuilder, UiNode, UserInterface, HorizontalAlignment, VerticalAlignment, text::TextBuilder},
</span><span class="boring">};
</span>fn create_button(ui: &amp;mut UserInterface) -&gt; Handle&lt;UiNode&gt; {
    ButtonBuilder::new(
        WidgetBuilder::new()
            .with_width(100.0)
            .with_height(100.0),
    )
    .with_content(
        TextBuilder::new(WidgetBuilder::new())
            .with_text(&quot;Click me!&quot;)
            .with_horizontal_text_alignment(HorizontalAlignment::Right)
            .with_vertical_text_alignment(VerticalAlignment::Center)
            .build(&amp;mut ui.build_ctx()),
    )
    .build(&amp;mut ui.build_ctx())
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="a-button-with-image"><a class="header" href="#a-button-with-image">A button with image</a></h2>
<p>More fancy-looking button with an image as a background could be created using this code snippet:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    engine::resource_manager::ResourceManager,
</span><span class="boring">    gui::{
</span><span class="boring">        button::ButtonBuilder, image::ImageBuilder, widget::WidgetBuilder, UiNode,
</span><span class="boring">        UserInterface,
</span><span class="boring">    },
</span><span class="boring">    utils::into_gui_texture,
</span><span class="boring">};
</span>fn create_fancy_button(ui: &amp;mut UserInterface, resource_manager: ResourceManager) -&gt; Handle&lt;UiNode&gt; {
    let ctx = &amp;mut ui.build_ctx();

    ButtonBuilder::new(WidgetBuilder::new())
        .with_back(
            ImageBuilder::new(WidgetBuilder::new())
                .with_texture(into_gui_texture(
                    resource_manager.request_texture(&quot;path/to/your/texture&quot;),
                ))
                .build(ctx),
        )
        .with_text(&quot;Click me!&quot;)
        .build(ctx)
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="message-handling"><a class="header" href="#message-handling">Message handling</a></h2>
<p>When clicked, a button sends a <code>ButtonMessage::Click</code> message, you can catch it in your code and do something
useful:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    event_loop::ControlFlow,
</span><span class="boring">    gui::{button::ButtonMessage, message::UiMessage, UiNode},
</span><span class="boring">    plugin::PluginContext,
</span><span class="boring">};
</span><span class="boring">
</span>struct Game {
    button: Handle&lt;UiNode&gt;,
}

impl Game {
    fn on_ui_message(
        &amp;mut self,
        context: &amp;mut PluginContext,
        message: &amp;UiMessage,
        control_flow: &amp;mut ControlFlow,
    ) {
        if let Some(ButtonMessage::Click) = message.data() {
            if message.destination() == self.button {
                //
                // Insert your code clicking handling code here.
                //
            }
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="using-a-button-to-exit-the-game"><a class="header" href="#using-a-button-to-exit-the-game">Using a button to exit the game</a></h2>
<p>Add a flag to your Game struct like <code>exit: bool</code> and set it in button handler to <code>true</code>, then check it in <code>on_tick</code> 
and set <code>*control_flow = ControlFlow::Exit</code> if the flag is raised</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    event_loop::ControlFlow,
</span><span class="boring">    gui::{
</span><span class="boring">        button::{ButtonBuilder, ButtonMessage},
</span><span class="boring">        message::UiMessage,
</span><span class="boring">        text::TextBuilder,
</span><span class="boring">        widget::WidgetBuilder,
</span><span class="boring">        UiNode, UserInterface,
</span><span class="boring">    },
</span><span class="boring">    plugin::PluginContext,
</span><span class="boring">};
</span><span class="boring">
</span>struct Game {
    quit_button_handle: Handle&lt;UiNode&gt;,
}

fn create_button(ui: &amp;mut UserInterface) -&gt; Handle&lt;UiNode&gt; {
    ButtonBuilder::new(WidgetBuilder::new())
        .with_content(
            TextBuilder::new(WidgetBuilder::new())
                .with_text(&quot;Quit&quot;)
                .build(&amp;mut ui.build_ctx()),
        )
        .build(&amp;mut ui.build_ctx())
}

impl Game {
    fn new(ctx: PluginContext) -&gt; Self {
        Self {
            quit_button_handle: create_button(ctx.user_interface),
        }
    }

    fn on_ui_message(
        &amp;mut self,
        context: &amp;mut PluginContext,
        message: &amp;UiMessage,
        control_flow: &amp;mut ControlFlow,
    ) {
        if let Some(ButtonMessage::Click) = message.data() {
            if message.destination() == self.quit_button_handle {
                *control_flow = ControlFlow::Exit;
            }
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="border"><a class="header" href="#border">Border</a></h1>
<p>The Border widget provides a stylized, static border around it's child widget. Below is an example of creating a 1 pixel
thick border around a button widget:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span>use fyrox::gui::{
    UserInterface,
    widget::WidgetBuilder, 
    border::BorderBuilder, 
    Thickness, 
    text::TextBuilder,
};

fn create_border_with_button(ui: &amp;mut UserInterface) {
    BorderBuilder::new(
        WidgetBuilder::new()
            .with_child(
                TextBuilder::new(WidgetBuilder::new())
                    .with_text(&quot;I'm boxed in!&quot;)
                    .build(&amp;mut ui.build_ctx())
            )
    )
    //You can also use Thickness::uniform(1.0)
    .with_stroke_thickness(Thickness {left: 1.0, right: 1.0, top: 1.0, bottom: 1.0})
    .build(&amp;mut ui.build_ctx());
}
<span class="boring">}
</span></code></pre></pre>
<p>As with other UI elements, we create the border using the BorderBuilder helper struct. The widget that should have a
border around it is added as a child of the base WidgetBuilder, and the border thickness can be set by providing a 
Thickness struct to the BorderBuilder's <em>with_stroke_thickness</em> function. This means you can set different thicknesses 
for each edge of the border.</p>
<p>You can style the border by creating a Brush and setting the border's base WidgetBuilder's foreground or background. 
The foreground will set the style of the boarder itself, while setting the background will color the whole area within 
the border. Below is an example of a blue border and a red background with white text inside.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::gui::{
</span><span class="boring">    brush::Brush,
</span><span class="boring">    core::color::Color,
</span><span class="boring">    widget::WidgetBuilder, 
</span><span class="boring">    text::TextBuilder,
</span><span class="boring">    border::BorderBuilder,
</span><span class="boring">    UserInterface,
</span><span class="boring">    Thickness, 
</span><span class="boring">};
</span>
<span class="boring">let mut ui = UserInterface::new(Default::default());
</span>
BorderBuilder::new(
    WidgetBuilder::new()
        .with_foreground(Brush::Solid(Color::opaque(0, 0, 200)))
        .with_background(Brush::Solid(Color::opaque(200, 0, 0)))
        .with_child(
            TextBuilder::new(WidgetBuilder::new())
                .with_text(&quot;I'm boxed in Blue and backed in Red!&quot;)
                .build(&amp;mut ui.build_ctx())
        )
)
.with_stroke_thickness(Thickness {left: 2.0, right: 2.0, top: 2.0, bottom: 2.0})
.build(&amp;mut ui.build_ctx());
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="canvas"><a class="header" href="#canvas">Canvas</a></h1>
<p>Canvas is a panel widget that allows you to explicitly set coordinates for children widgets. It is useful when you 
need to manually control position of children widgets. Root UI node is canvas, so any widgets that are not attached
to any other widgets can have explicit position.</p>
<h2 id="how-to-create-11"><a class="header" href="#how-to-create-11">How to create</a></h2>
<p>Use <code>CanvasBuilder</code> to create Canvas instance:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    gui::{canvas::CanvasBuilder, widget::WidgetBuilder, BuildContext, UiNode},
</span><span class="boring">};
</span><span class="boring">
</span>fn create_canvas(ctx: &amp;mut BuildContext) -&gt; Handle&lt;UiNode&gt; {
    CanvasBuilder::new(WidgetBuilder::new()).build(ctx)
}
<span class="boring">}
</span></code></pre></pre>
<p>Canvas does not have any specific options, so its creation is probably simplest of all widgets.</p>
<h2 id="how-to-position-children-nodes"><a class="header" href="#how-to-position-children-nodes">How to position children nodes</a></h2>
<p>Use <code>.with_desired_position</code> on children widgets to set specific position:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::{algebra::Vector2, pool::Handle},
</span><span class="boring">    gui::{
</span><span class="boring">        button::ButtonBuilder, canvas::CanvasBuilder, text::TextBuilder, widget::WidgetBuilder,
</span><span class="boring">        BuildContext, UiNode,
</span><span class="boring">    },
</span><span class="boring">};
</span><span class="boring">
</span>fn create_canvas_with_children_widgets(ctx: &amp;mut BuildContext) -&gt; Handle&lt;UiNode&gt; {
    CanvasBuilder::new(
        WidgetBuilder::new()
            .with_child(
                TextBuilder::new(
                    WidgetBuilder::new().with_desired_position(Vector2::new(100.0, 200.0)),
                )
                .with_text(&quot;Simple Text at (100.0, 200.0)&quot;)
                .build(ctx),
            )
            .with_child(
                ButtonBuilder::new(
                    WidgetBuilder::new().with_desired_position(Vector2::new(200.0, 100.0)),
                )
                .with_text(&quot;Simple Button at (200.0, 100.0)&quot;)
                .build(ctx),
            ),
    )
    .build(ctx)
}
<span class="boring">}
</span></code></pre></pre>
<p>The code snippet will create a canvas with a text widget located at (100.0, 200.0) relative to top-left corner of the
canvas and a button located at (200.0, 100.0).</p>
<h2 id="tips"><a class="header" href="#tips">Tips</a></h2>
<p>Canvas provides infinite bounds for children widgets, this means that children nodes <strong>will not</strong> be stretched, instead
they'll shrink to fit their content. For example, a button with a text will take slightly bigger rectangle than the 
text bounds.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="check-box"><a class="header" href="#check-box">Check box</a></h1>
<p>Checkbox is a UI widget that have three states - <code>Checked</code>, <code>Unchecked</code> and <code>Undefined</code>. In most cases it is used
only with two values which fits in <code>bool</code> type. Third, undefined, state is used for specific situations when your
data have such state. </p>
<h2 id="how-it-looks"><a class="header" href="#how-it-looks">How it looks</a></h2>
<p>Checkbox in <code>Checked</code> state:</p>
<p><img src="fyrox/ui/checkbox/checked.PNG" alt="Checked" /></p>
<p>Checkbox in <code>Unchecked</code> state:</p>
<p><img src="fyrox/ui/checkbox/unchecked.PNG" alt="Unchecked" /></p>
<h2 id="how-to-create-12"><a class="header" href="#how-to-create-12">How to create</a></h2>
<p>To create a checkbox you should do something like this:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    gui::{check_box::CheckBoxBuilder, widget::WidgetBuilder, UiNode, UserInterface},
</span><span class="boring">};
</span>fn create_checkbox(ui: &amp;mut UserInterface) -&gt; Handle&lt;UiNode&gt; {
    CheckBoxBuilder::new(WidgetBuilder::new())
        // A custom value can be set during initialization.
        .checked(Some(true))
        .build(&amp;mut ui.build_ctx())
}
<span class="boring">}
</span></code></pre></pre>
<p>The above code will create a checkbox without any textual info, but usually checkboxes have some useful info
near them. To create such checkbox, you could use <code>.with_content(..)</code> method which accepts any widget handle.
For checkbox with text, you could use <code>TextBuilder</code> to create textual content, for checkbox with text - use 
<code>ImageBuilder</code>. As already said, you're free to use any widget handle there.</p>
<p>Here's an example of checkbox with textual content.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    gui::{
</span><span class="boring">        check_box::CheckBoxBuilder, text::TextBuilder, widget::WidgetBuilder, UiNode,
</span><span class="boring">        UserInterface,
</span><span class="boring">    },
</span><span class="boring">};
</span>fn create_checkbox(ui: &amp;mut UserInterface) -&gt; Handle&lt;UiNode&gt; {
    let ctx = &amp;mut ui.build_ctx();

    CheckBoxBuilder::new(WidgetBuilder::new())
        // A custom value can be set during initialization.
        .checked(Some(true))
        .with_content(
            TextBuilder::new(WidgetBuilder::new())
                .with_text(&quot;This is a checkbox&quot;)
                .build(ctx),
        )
        .build(ctx)
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="message-handling-1"><a class="header" href="#message-handling-1">Message handling</a></h2>
<p>Checkboxes are not static widget and have multiple states. To handle a message from a checkbox, you need to handle
a <code>CheckBoxMessage::Check</code> message. To do so, you can do something like this:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    engine::Engine,
</span><span class="boring">    event_loop::ControlFlow,
</span><span class="boring">    gui::{check_box::CheckBoxMessage, message::UiMessage, UiNode},
</span><span class="boring">    plugin::PluginContext,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">struct Foo {
</span><span class="boring">    checkbox: Handle&lt;UiNode&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Foo {
</span>fn on_ui_message(
    &amp;mut self,
    context: &amp;mut PluginContext,
    message: &amp;UiMessage,
    control_flow: &amp;mut ControlFlow,
) {
    if let Some(CheckBoxMessage::Check(value)) = message.data() {
        if message.destination() == self.checkbox {
            //
            // Insert your clicking handling code here.
            //
        }
    }
}
<span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p>Keep in mind that checkbox (as any other widget) generates <code>WidgetMessage</code> instances. You can catch them too and
do a custom handling if you need.</p>
<h2 id="theme-1"><a class="header" href="#theme-1">Theme</a></h2>
<p>Checkbox can be fully customized to have any look you want, there are few methods that will help you with 
customization:</p>
<ol>
<li><code>.with_content(..)</code> - sets the content that will be shown near the checkbox. </li>
<li><code>.with_check_mark(..)</code> - sets the widget that will be used as checked icon. </li>
<li><code>.with_uncheck_mark(..)</code> - sets the widget that will be used as unchecked icon.</li>
<li><code>.with_undefined_mark(..)</code> - sets the widget that will be used as undefined icon.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="curve-editor-wip"><a class="header" href="#curve-editor-wip">Curve editor (WIP)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="decorator-wip"><a class="header" href="#decorator-wip">Decorator (WIP)</a></h1>
<p>A visual element that changes its appearance by listening specific events.
It can has &quot;pressed&quot;, &quot;hover&quot;, &quot;selected&quot; or normal appearance:</p>
<p><code>Pressed</code> - enables on mouse down message.
<code>Selected</code> - whether decorator selected or not.
<code>Hovered</code> - mouse is over decorator.
<code>Normal</code> - not selected, pressed, hovered.</p>
<p>This element is widely used to provide some generic visual behaviour for various
widgets. For example it used to decorate button, items in items control.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="docking-manager-wip"><a class="header" href="#docking-manager-wip">Docking manager (WIP)</a></h1>
<p>Docking manager allows you to dock windows and hold them in-place.</p>
<p>Docking manager can hold any types of UI elements, but dragging works only
for windows.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dropdown-list-wip"><a class="header" href="#dropdown-list-wip">Dropdown list (WIP)</a></h1>
<p>Drop-down list. This is control which shows currently selected item and provides drop-down
list to select its current item. It is build using composition with standard list view.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="expander-wip"><a class="header" href="#expander-wip">Expander (WIP)</a></h1>
<p>Expander is a collapsible container for child widgets with a field that describes a content. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="file-browser-wip"><a class="header" href="#file-browser-wip">File browser (WIP)</a></h1>
<p>FileBrowser widget is a simple file system tree, FileSelector is a window with FileBrowser and few buttons.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="grid"><a class="header" href="#grid">Grid</a></h1>
<p>Grids are one of several methods to position multiple widgets in relation to each other. A Grid Widget, as the name 
implies, is able to position children widgets into a grid of specifically sized rows and columns. </p>
<p>Here is a simple example that positions several text widgets into a 2 by 2 grid:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::gui::{
</span><span class="boring">    UiNode,
</span><span class="boring">    BuildContext,
</span><span class="boring">    widget::WidgetBuilder,
</span><span class="boring">    text::TextBuilder,
</span><span class="boring">    grid::{GridBuilder, GridDimension},
</span><span class="boring">};
</span>
fn create_text_grid(ctx: &amp;mut BuildContext) -&gt; fyrox::core::pool::Handle&lt;UiNode&gt; {

    GridBuilder::new(
        WidgetBuilder::new()
            .with_child(
                TextBuilder::new(WidgetBuilder::new())
                    .with_text(&quot;top left &quot;)
                    .build(ctx)
            )
            .with_child(
                TextBuilder::new(
                    WidgetBuilder::new()
                        .on_column(1)
                )
                    .with_text(&quot; top right&quot;)
                    .build(ctx)
            )
            .with_child(
                TextBuilder::new(
                    WidgetBuilder::new()
                        .on_row(1)
                )
                    .with_text(&quot;bottom left &quot;)
                    .build(ctx)
            )
            .with_child(
                TextBuilder::new(
                    WidgetBuilder::new()
                        .on_row(1)
                        .on_column(1)
                )
                    .with_text(&quot; bottom right&quot;)
                    .build(ctx)
            )
        )
            .add_row(GridDimension::auto())
            .add_row(GridDimension::auto())
            .add_column(GridDimension::auto())
            .add_column(GridDimension::auto())
            .build(ctx)
}
<span class="boring">}
</span></code></pre></pre>
<p>As with other UI widgets, Grids are created via the GridBuilder struct. Each widget whose position should be controlled
by the Grid should be added as a child of the GridBuilder's base widget.</p>
<p>You then need to tell each child what row and column it belongs to via the on_column and on_row functions of their base
widget. By default, all children will be placed into row 0, column 0. </p>
<p>After that you need to provide sizing constraints for each row and column to the GridBuilder by using the add_row and 
add_column functions while providing a GridDimension instance to the call. GridDimension can be constructed with the 
following functions:</p>
<ul>
<li>GridDimension::auto() - Sizes the row or column so it's just large enough to fit the largest child's size.</li>
<li>GridDimension::stretch() - Stretches the row or column to fill the parent's available space, if multiple rows or </li>
<li>columns have this option the size is evenly distributed between them.</li>
<li>GridDimension::strict(f32) - Sets the row or column to be exactly the given value of pixels long. So a row will only </li>
<li>be the given number of pixels wide, while a column will be that many pixels tall.</li>
</ul>
<p>You can add any number of rows and columns to a grid widget, and each grid cell does <strong>not</strong> need to have a UI widget 
in it to be valid. For example you can add a column and set it to a specific size via strict to provide spacing between
two other columns.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="image"><a class="header" href="#image">Image</a></h1>
<p>Image widget is a rectangle with a texture, it is used draw custom bitmaps. The UI in the engine is vector-based, Image
widget is the only way to draw a bitmap. Usage of the Image is very simple:</p>
<h2 id="usage-2"><a class="header" href="#usage-2">Usage</a></h2>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    engine::resource_manager::ResourceManager,
</span><span class="boring">    gui::{image::ImageBuilder, widget::WidgetBuilder, BuildContext, UiNode},
</span><span class="boring">    utils::into_gui_texture,
</span><span class="boring">};
</span>
fn create_image(ctx: &amp;mut BuildContext, resource_manager: ResourceManager) -&gt; Handle&lt;UiNode&gt; {
    // You must explicitly set width and height of the image, otherwise it will collapse to a
    // point and you won't see anything.
    let width = 100.0;
    let height = 100.0;
    ImageBuilder::new(WidgetBuilder::new().with_width(width).with_height(height))        
        .with_texture(into_gui_texture(
            // Ask resource manager to load a texture.
            resource_manager.request_texture(&quot;path/to/your/texture.png&quot;),
        ))
        .build(ctx)
}
<span class="boring">}
</span></code></pre></pre>
<p>There are one common pitfall when using Image widget - you must explicitly set width and height of the image if it is
not placed to some panel, that will stretch it automatically. In other words if you created an image with undefined
width and height, then putting it to some container like Grid' cell will stretch the image to fit cell bounds.</p>
<h2 id="equal-size-to-source"><a class="header" href="#equal-size-to-source">Equal Size to Source</a></h2>
<p>Sometimes you need your image to have equal size with the texture it uses, in this case you should fetch texture 
bounds first and then create an Image width these bounds:</p>
<pre><pre class="playground"><code class="language-rust no_run edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    engine::resource_manager::ResourceManager,
</span><span class="boring">    gui::{image::ImageBuilder, widget::WidgetBuilder, BuildContext, UiNode},
</span><span class="boring">    resource::texture::TextureKind,
</span><span class="boring">    utils::into_gui_texture,
</span><span class="boring">};
</span>
async fn create_image(
    ctx: &amp;mut BuildContext&lt;'_&gt;,
    resource_manager: ResourceManager,
) -&gt; Handle&lt;UiNode&gt; {
    // Ask resource manager to load the texture and wait while it loads using `.await`.
    if let Ok(texture) = resource_manager
        .request_texture(&quot;path/to/your/texture.png&quot;)
        .await
    {
        // A texture can be not only rectangular, so we must check that.
        let texture_kind = texture.data_ref().kind();
        if let TextureKind::Rectangle { width, height } = texture_kind {
            return ImageBuilder::new(
                WidgetBuilder::new()
                    .with_width(width as f32)
                    .with_height(height as f32),
            )
            .with_texture(into_gui_texture(texture))
            .build(ctx);
        }
    }

    // Image wasn't created.
    Handle::NONE
}
<span class="boring">}
</span></code></pre></pre>
<p>This function can be used as-is whenever you need to create an Image that have same size as the source file. It is
marked as <code>async</code> because resource loading (texture is a resource) happens in separate thread and to get actual texture
data we must wait it. If you don't want to use async, then use any executor to block current thread and execute the
promise immediately:</p>
<pre><pre class="playground"><code class="language-rust no_run edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    engine::resource_manager::ResourceManager,
</span><span class="boring">    gui::{BuildContext, UiNode},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">async fn create_image(
</span><span class="boring">    ctx: &amp;mut BuildContext&lt;'_&gt;,
</span><span class="boring">    resource_manager: ResourceManager,
</span><span class="boring">) -&gt; Handle&lt;UiNode&gt; {
</span><span class="boring">    Handle::NONE
</span><span class="boring">}
</span>fn create_image_sync(
    ctx: &amp;mut BuildContext&lt;'_&gt;,
    resource_manager: ResourceManager,
) -&gt; Handle&lt;UiNode&gt; {
    fyrox::core::futures::executor::block_on(create_image(ctx, resource_manager))
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="vertical-flip"><a class="header" href="#vertical-flip">Vertical Flip</a></h2>
<p>In some rare cases you need to flip your source image before showing it, there is <code>.with_flip</code> option for that:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    engine::resource_manager::ResourceManager,
</span><span class="boring">    gui::{image::ImageBuilder, widget::WidgetBuilder, BuildContext, UiNode},
</span><span class="boring">    utils::into_gui_texture,
</span><span class="boring">};
</span>
fn create_image(ctx: &amp;mut BuildContext, resource_manager: ResourceManager) -&gt; Handle&lt;UiNode&gt; {
    ImageBuilder::new(WidgetBuilder::new().with_width(100.0).with_height(100.0))
        .with_flip(true) // Flips an image vertically
        .with_texture(into_gui_texture(
            resource_manager.request_texture(&quot;path/to/your/texture.png&quot;),
        ))
        .build(ctx)
}
<span class="boring">}
</span></code></pre></pre>
<p>There are few places where it can be helpful:</p>
<ul>
<li>You're using render target as a source texture for your Image instance, render targets are vertically flipped due
to mismatch of coordinates of UI and graphics API. The UI has origin at left top corner, the graphics API - bottom left.</li>
<li>Your source image is vertically mirrored.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="inspector-wip"><a class="header" href="#inspector-wip">Inspector (WIP)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="list-view-wip"><a class="header" href="#list-view-wip">List view (WIP)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="menu-wip"><a class="header" href="#menu-wip">Menu (WIP)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="message-box-wip"><a class="header" href="#message-box-wip">Message box (WIP)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="numeric-field-wip"><a class="header" href="#numeric-field-wip">Numeric field (WIP)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="popup-wip"><a class="header" href="#popup-wip">Popup (WIP)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="progress-bar-wip"><a class="header" href="#progress-bar-wip">Progress bar (WIP)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="range-wip"><a class="header" href="#range-wip">Range (WIP)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rect-editor-wip"><a class="header" href="#rect-editor-wip">Rect editor (WIP)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scroll-bar-wip"><a class="header" href="#scroll-bar-wip">Scroll bar (WIP)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scroll-panel-wip"><a class="header" href="#scroll-panel-wip">Scroll panel (WIP)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scroll-viewer-wip"><a class="header" href="#scroll-viewer-wip">Scroll viewer (WIP)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stack-panel"><a class="header" href="#stack-panel">Stack Panel</a></h1>
<p>Stack Panels are one of several methods to position multiple widgets in relation to each other. A Stack Panel Widget 
orders it's children widgets linerarly, aka in a stack of widgets, based on the order the widgets were added as children. 
So the first widget added will be at the top or left most position, while each additional widget will decend from top to 
bottom or continue from left most to right most. The below example code places 3 text widgets into a vertical stack:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::gui::{
</span><span class="boring">    UiNode,
</span><span class="boring">    BuildContext,
</span><span class="boring">    widget::WidgetBuilder,
</span><span class="boring">    text::TextBuilder,
</span><span class="boring">    stack_panel::StackPanelBuilder,
</span><span class="boring">};
</span>
fn create_stack_panel(ctx: &amp;mut BuildContext) -&gt; fyrox::core::pool::Handle&lt;UiNode&gt; {

    StackPanelBuilder::new(
        WidgetBuilder::new()
            .with_child(
                TextBuilder::new(WidgetBuilder::new())
                    .with_text(&quot;Top&quot;)
                    .build(ctx)
            )
            .with_child(
                TextBuilder::new(WidgetBuilder::new())
                    .with_text(&quot;Middle&quot;)
                    .build(ctx)
            )
            .with_child(
                TextBuilder::new(WidgetBuilder::new())
                    .with_text(&quot;Bottom&quot;)
                    .build(ctx)
            )
    )
        .build(ctx)
    
}
<span class="boring">}
</span></code></pre></pre>
<p>As you can see from the example, creating a Stack Panel uses the standard method for creating widgets. Create a new 
StackPanelBuilder and provide it with a new WidgetBuilder. Adding widgets to the stack is done by adding childeren to 
the StackBuilder's WidgetBuilder.</p>
<h2 id="stack-panel-orientation"><a class="header" href="#stack-panel-orientation">Stack Panel Orientation</a></h2>
<p>As has been indicated, Stack Panels can be oriented to order it's children either Vertical, from top to bottom, or 
Horizontal, Left most to right most. This is done using the StackPanelBuilder's with_orientation function providing it 
with a gui::Orientation enum value. <strong>By default</strong> all Stack Panel's are Vertical.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::gui::{
</span><span class="boring">    Orientation,
</span><span class="boring">    BuildContext,
</span><span class="boring">    widget::WidgetBuilder,
</span><span class="boring">    stack_panel::StackPanelBuilder,
</span><span class="boring">};
</span>
<span class="boring">fn build(ctx: &amp;mut BuildContext) {
</span>StackPanelBuilder::new(
    WidgetBuilder::new()
)
    .with_orientation(Orientation::Horizontal)
    .build(ctx);
<span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tab-control"><a class="header" href="#tab-control">Tab Control</a></h1>
<p>The Tab Control handles the visibility of several tabs, only showing a single tab that the user has selected via the 
tab header buttons. Each tab is defined via a Tab Definition struct which takes two widgets, one representing the tab
header and the other representing the tab's contents.</p>
<p>The following example makes a 2 tab, Tab Control containing some simple text widgets:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::gui::{
</span><span class="boring">    BuildContext,
</span><span class="boring">    widget::WidgetBuilder,
</span><span class="boring">    text::TextBuilder,
</span><span class="boring">    tab_control::{TabControlBuilder, TabDefinition},
</span><span class="boring">};
</span>
fn create_tab_control(ctx: &amp;mut BuildContext) {

    TabControlBuilder::new(WidgetBuilder::new())
        .with_tab(
            TabDefinition{
                header: TextBuilder::new(WidgetBuilder::new())
                            .with_text(&quot;First&quot;)
                            .build(ctx),
                            
                content: TextBuilder::new(WidgetBuilder::new())
                            .with_text(&quot;First tab's contents!&quot;)
                            .build(ctx),
            }
        )
        .with_tab(
            TabDefinition{
                header: TextBuilder::new(WidgetBuilder::new())
                            .with_text(&quot;Second&quot;)
                            .build(ctx),
                            
                content: TextBuilder::new(WidgetBuilder::new())
                            .with_text(&quot;Second tab's contents!&quot;)
                            .build(ctx),
            }
        )
        .build(ctx);
}
<span class="boring">}
</span></code></pre></pre>
<p>As usual, we create the widget via the builder TabControlBuilder. Tabs are added via the <em>with_tab</em> function in the 
order you want them to appear, passing each call to the function a directly constructed TabDefinition struct. Tab 
headers will appear from left to right at the top with tab contents shown directly below the tabs. As usual, if no 
constraints are given to the base WidgetBuilder of the TabControlBuilder, then the tab content area will resize to fit
whatever is in the current tab.</p>
<p>Each tab's content is made up of one widget, so to be useful you will want to use one of the container widgets to help 
arrange additional widgets within the tab.</p>
<h2 id="tab-header-styling"><a class="header" href="#tab-header-styling">Tab Header Styling</a></h2>
<p>Notice that you can put any widget into the tab header, so if you want images to denote each tab you can add an Image
widget to each header, and if you want an image <em>and</em> some text you can insert a stack panel with an image on top and 
text below it. </p>
<p>You will also likely want to style whatever widgets you add. As can be seen when running the code example above, the 
tab headers are scrunched when there are no margins provided to your text widgets. Simply add something like the below 
code example and you will get a decent look:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::gui::{
</span><span class="boring">    BuildContext,
</span><span class="boring">    widget::WidgetBuilder,
</span><span class="boring">    text::TextBuilder,
</span><span class="boring">    Thickness, 
</span><span class="boring">    tab_control::{TabDefinition},
</span><span class="boring">};
</span>
<span class="boring">fn build(ctx: &amp;mut BuildContext) {
</span><span class="boring">TabDefinition{
</span>header: TextBuilder::new(
            WidgetBuilder::new()
                .with_margin(Thickness::uniform(4.0))
        )
            .with_text(&quot;First&quot;)
            .build(ctx),
<span class="boring">content: Default::default()
</span><span class="boring">};
</span><span class="boring">}
</span>
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="text"><a class="header" href="#text">Text</a></h1>
<p>Text is a simple widget that allows you to print text on screen. It has various options like word wrapping, text
alignment, and so on.</p>
<h2 id="how-to-create-13"><a class="header" href="#how-to-create-13">How to create</a></h2>
<p>An instance of the Text widget could be created like so:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    gui::{text::TextBuilder, widget::WidgetBuilder, UiNode, UserInterface},
</span><span class="boring">};
</span>fn create_text(ui: &amp;mut UserInterface, text: &amp;str) -&gt; Handle&lt;UiNode&gt; {
    TextBuilder::new(WidgetBuilder::new())
        .with_text(text)
        .build(&amp;mut ui.build_ctx())
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="text-alignment-and-word-wrapping"><a class="header" href="#text-alignment-and-word-wrapping">Text alignment and word wrapping</a></h2>
<p>There are various text alignment options for both vertical and horizontal axes. Typical alignment values are:
<code>Left</code>, <code>Center</code>, <code>Right</code> for horizontal axis, and <code>Top</code>, <code>Center</code>, <code>Bottom</code> for vertical axis. An instance of 
centered text could be created like so:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    gui::{
</span><span class="boring">        text::TextBuilder, widget::WidgetBuilder, HorizontalAlignment, UiNode, UserInterface,
</span><span class="boring">        VerticalAlignment,
</span><span class="boring">    },
</span><span class="boring">};
</span>fn create_centered_text(ui: &amp;mut UserInterface, text: &amp;str) -&gt; Handle&lt;UiNode&gt; {
    TextBuilder::new(WidgetBuilder::new())
        .with_horizontal_text_alignment(HorizontalAlignment::Center)
        .with_vertical_text_alignment(VerticalAlignment::Center)
    .with_text(text)
    .build(&amp;mut ui.build_ctx())
}
<span class="boring">}
</span></code></pre></pre>
<p>Long text is usually needs to wrap on available bounds, there are three possible options for word wrapping:
<code>NoWrap</code>, <code>Letter</code>, <code>Word</code>. An instance of text with word-based wrapping could be created like so:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    gui::{
</span><span class="boring">        formatted_text::WrapMode, text::TextBuilder, widget::WidgetBuilder, UiNode,
</span><span class="boring">        UserInterface,
</span><span class="boring">    },
</span><span class="boring">};
</span>fn create_text_with_word_wrap(ui: &amp;mut UserInterface, text: &amp;str) -&gt; Handle&lt;UiNode&gt; {
    TextBuilder::new(WidgetBuilder::new())
        .with_wrap(WrapMode::Word)
        .with_text(text)
        .build(&amp;mut ui.build_ctx())
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="fonts-and-colors"><a class="header" href="#fonts-and-colors">Fonts and colors</a></h2>
<p>To set a color of the text just use <code>.with_foreground(..)</code> of the <code>WidgetBuilder</code> while building the text instance:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::{color::Color, pool::Handle},
</span><span class="boring">    gui::{brush::Brush, text::TextBuilder, widget::WidgetBuilder, UiNode, UserInterface},
</span><span class="boring">};
</span>fn create_text(ui: &amp;mut UserInterface, text: &amp;str) -&gt; Handle&lt;UiNode&gt; {
    //               vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
    TextBuilder::new(WidgetBuilder::new().with_foreground(Brush::Solid(Color::RED)))
        .with_text(text)
        .build(&amp;mut ui.build_ctx())
}
<span class="boring">}
</span></code></pre></pre>
<p>By default, text is created with default font, however it is possible to set any custom font:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::{futures::executor::block_on, pool::Handle},
</span><span class="boring">    gui::{
</span><span class="boring">        text::TextBuilder,
</span><span class="boring">        ttf::{Font, SharedFont},
</span><span class="boring">        widget::WidgetBuilder,
</span><span class="boring">        UiNode, UserInterface,
</span><span class="boring">    },
</span><span class="boring">};
</span>
fn load_font() -&gt; SharedFont {
    // Choose desired character set, default is Basic Latin + Latin Supplement.
    // Character set is a set of ranges with Unicode code points.
    let character_set = Font::default_char_set();

    // Normally `block_on` should be avoided.
    let font = block_on(Font::from_file(
        &quot;path/to/your/font.ttf&quot;,
        24.0,
        character_set,
    ))
    .unwrap();

    SharedFont::new(font)
}

fn create_text(ui: &amp;mut UserInterface, text: &amp;str) -&gt; Handle&lt;UiNode&gt; {
    TextBuilder::new(WidgetBuilder::new())
        .with_font(load_font())
        .with_text(text)
        .build(&amp;mut ui.build_ctx())
}
<span class="boring">}
</span></code></pre></pre>
<p>Please refer to <a href="fyrox/ui/font.html">Font</a> chapter to learn more about fonts.</p>
<h3 id="font-size"><a class="header" href="#font-size">Font size</a></h3>
<p>There is no way to change font size without changing the entire font used by Text, it is known issue and there is
<a href="https://github.com/FyroxEngine/Fyrox/issues/74">tracking issue</a> for that. Check <a href="fyrox/ui/font.html">Font</a> chapter to learn how 
to create fonts.</p>
<h2 id="messages"><a class="header" href="#messages">Messages</a></h2>
<p>There are few message types that Text widget can produce, most common are <code>Text</code>, <code>Wrap</code>, <code>Font</code>, <code>VerticalAlignment</code>,
and <code>HorizontalAlignment</code>. An example of changing text at runtime could be something like this:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    gui::{
</span><span class="boring">        message::{MessageDirection},
</span><span class="boring">        UiNode, UserInterface,
</span><span class="boring">        text::TextMessage
</span><span class="boring">    },
</span><span class="boring">};
</span>fn request_change_text(ui: &amp;UserInterface, text_widget_handle: Handle&lt;UiNode&gt;, text: &amp;str) {
    ui.send_message(TextMessage::text(
        text_widget_handle,
        MessageDirection::ToWidget,
        text.to_owned(),
    ))
}
<span class="boring">}
</span></code></pre></pre>
<p>Please keep in mind, that like any other situation when you &quot;changing&quot; something via messages, you should remember
that the change is <strong>not</strong> immediate. The change will be applied on <code>ui.poll_message(..)</code> call somewhere in your
code (or will be done automatically if you're using scripts or Framework (obsolete)).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="text-box"><a class="header" href="#text-box">Text Box</a></h1>
<p>TextBox is a text widget that allows you to edit text and create specialized input fields. It has various options like 
word wrapping, text alignment, and so on.</p>
<h2 id="how-to-create-14"><a class="header" href="#how-to-create-14">How to create</a></h2>
<p>An instance of the TextBox widget could be created like so:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    gui::{text_box::TextBoxBuilder, widget::WidgetBuilder, UiNode, UserInterface},
</span><span class="boring">};
</span>fn create_text_box(ui: &amp;mut UserInterface, text: &amp;str) -&gt; Handle&lt;UiNode&gt; {
    TextBoxBuilder::new(WidgetBuilder::new())
        .with_text(text)
        .build(&amp;mut ui.build_ctx())
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="text-alignment-and-word-wrapping-1"><a class="header" href="#text-alignment-and-word-wrapping-1">Text alignment and word wrapping</a></h2>
<p>There are various text alignment options for both vertical and horizontal axes. Typical alignment values are:
<code>Left</code>, <code>Center</code>, <code>Right</code> for horizontal axis, and <code>Top</code>, <code>Center</code>, <code>Bottom</code> for vertical axis. An instance of
centered text could be created like so:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    gui::{
</span><span class="boring">        text_box::TextBoxBuilder, widget::WidgetBuilder, HorizontalAlignment, UiNode, UserInterface,
</span><span class="boring">        VerticalAlignment,
</span><span class="boring">    },
</span><span class="boring">};
</span>fn create_centered_text(ui: &amp;mut UserInterface, text: &amp;str) -&gt; Handle&lt;UiNode&gt; {
    TextBoxBuilder::new(WidgetBuilder::new())
        .with_horizontal_text_alignment(HorizontalAlignment::Center)
        .with_vertical_text_alignment(VerticalAlignment::Center)
    .with_text(text)
    .build(&amp;mut ui.build_ctx())
}
<span class="boring">}
</span></code></pre></pre>
<p>Long text is usually needs to wrap on available bounds, there are three possible options for word wrapping:
<code>NoWrap</code>, <code>Letter</code>, <code>Word</code>. An instance of text with word-based wrapping could be created like so:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    gui::{
</span><span class="boring">        formatted_text::WrapMode, text_box::TextBoxBuilder, widget::WidgetBuilder, UiNode,
</span><span class="boring">        UserInterface,
</span><span class="boring">    },
</span><span class="boring">};
</span>fn create_text_with_word_wrap(ui: &amp;mut UserInterface, text: &amp;str) -&gt; Handle&lt;UiNode&gt; {
    TextBoxBuilder::new(WidgetBuilder::new())
        .with_wrap(WrapMode::Word)
        .with_text(text)
        .build(&amp;mut ui.build_ctx())
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="fonts-and-colors-1"><a class="header" href="#fonts-and-colors-1">Fonts and colors</a></h2>
<p>To set a color of the text just use <code>.with_foreground(..)</code> of the <code>WidgetBuilder</code> while building the text instance:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::{color::Color, pool::Handle},
</span><span class="boring">    gui::{brush::Brush, text_box::TextBoxBuilder, widget::WidgetBuilder, UiNode, UserInterface},
</span><span class="boring">};
</span>fn create_text(ui: &amp;mut UserInterface, text: &amp;str) -&gt; Handle&lt;UiNode&gt; {
    //                  vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
    TextBoxBuilder::new(WidgetBuilder::new().with_foreground(Brush::Solid(Color::RED)))
        .with_text(text)
        .build(&amp;mut ui.build_ctx())
}
<span class="boring">}
</span></code></pre></pre>
<p>By default, text is created with default font, however it is possible to set any custom font:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::{futures::executor::block_on, pool::Handle},
</span><span class="boring">    gui::{
</span><span class="boring">        text_box::TextBoxBuilder,
</span><span class="boring">        ttf::{Font, SharedFont},
</span><span class="boring">        widget::WidgetBuilder,
</span><span class="boring">        UiNode, UserInterface,
</span><span class="boring">    },
</span><span class="boring">};
</span>
fn load_font() -&gt; SharedFont {
    // Choose desired character set, default is Basic Latin + Latin Supplement.
    // Character set is a set of ranges with Unicode code points.
    let character_set = Font::default_char_set();

    // Normally `block_on` should be avoided.
    let font = block_on(Font::from_file(
        &quot;path/to/your/font.ttf&quot;,
        24.0,
        character_set,
    ))
    .unwrap();

    SharedFont::new(font)
}

fn create_text(ui: &amp;mut UserInterface, text: &amp;str) -&gt; Handle&lt;UiNode&gt; {
    TextBoxBuilder::new(WidgetBuilder::new())
        .with_font(load_font())
        .with_text(text)
        .build(&amp;mut ui.build_ctx())
}
<span class="boring">}
</span></code></pre></pre>
<p>Please refer to <a href="fyrox/ui/font.html">Font</a> chapter to learn more about fonts.</p>
<h3 id="font-size-1"><a class="header" href="#font-size-1">Font size</a></h3>
<p>There is no way to change font size without changing the entire font used by Text, it is known issue and there is
<a href="https://github.com/FyroxEngine/Fyrox/issues/74">tracking issue</a> for that. Check <a href="fyrox/ui/font.html">Font</a> chapter to learn how
to create fonts.</p>
<h2 id="messages-1"><a class="header" href="#messages-1">Messages</a></h2>
<p>There are few message types that Text widget can produce, most common are <code>Text</code>, <code>Wrap</code>, <code>Font</code>, <code>VerticalAlignment</code>,
and <code>HorizontalAlignment</code>. An example of changing text at runtime could be something like this:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    gui::{
</span><span class="boring">        message::{MessageDirection},
</span><span class="boring">        UiNode, UserInterface,
</span><span class="boring">        text_box::TextBoxMessage
</span><span class="boring">    },
</span><span class="boring">};
</span>fn request_change_text(ui: &amp;UserInterface, text_box_widget_handle: Handle&lt;UiNode&gt;, text: &amp;str) {
    ui.send_message(TextBoxMessage::text(
        text_box_widget_handle,
        MessageDirection::ToWidget,
        text.to_owned(),
    ))
}
<span class="boring">}
</span></code></pre></pre>
<p>Please keep in mind, that like any other situation when you &quot;changing&quot; something via messages, you should remember
that the change is <strong>not</strong> immediate. The change will be applied on <code>ui.poll_message(..)</code> call somewhere in your
code (or will be done automatically if you're using scripts or Framework (obsolete)).</p>
<h2 id="shortcuts"><a class="header" href="#shortcuts">Shortcuts</a></h2>
<p>There are number of default shortcuts that can be used to speed up text editing:</p>
<ul>
<li><code>Ctrl+A</code> - select all</li>
<li><code>Ctrl+C</code> - copy selected text</li>
<li><code>Ctrl+V</code> - paste text from clipboard</li>
<li><code>Ctrl+Home</code> - move caret to the beginning of the text</li>
<li><code>Ctrl+End</code> - move caret to the beginning of the text</li>
<li><code>Shift+Home</code> - select everything from current caret position until the beginning of current line</li>
<li><code>Shift+End</code> - select everything from current caret position until the end of current line</li>
<li><code>Arrows</code> - move caret accordingly</li>
<li><code>Delete</code> - deletes next character</li>
<li><code>Backspace</code> - deletes previous character</li>
<li><code>Enter</code> - new line (if multiline mode is set) or <code>commit</code> message</li>
</ul>
<h2 id="multiline-text-box"><a class="header" href="#multiline-text-box">Multiline Text Box</a></h2>
<p>By default, text box will not add new line character to the text if you press <code>Enter</code> on keyboard. To enable this 
functionality use <code>.with_multiline(true)</code></p>
<h2 id="read-only-mode"><a class="header" href="#read-only-mode">Read-only Mode</a></h2>
<p>You can enable or disable content editing by using read-only mode. Use <code>.with_readonly</code> at build stage.</p>
<h2 id="mask-character"><a class="header" href="#mask-character">Mask Character</a></h2>
<p>You can specify replacement character for every other characters, this is useful option for password fields. Use 
<code>.with_mask_char</code> at build stage. For example, you can set replacement character to asterisk <code>*</code> using 
<code>.with_mask_char(Some('*'))</code></p>
<h2 id="text-commit-mode"><a class="header" href="#text-commit-mode">Text Commit Mode</a></h2>
<p>In many situations you don't need the text box to send <code>new text</code> message every new character, you either want this 
message if <code>Enter</code> key is pressed or TextBox has lost keyboard focus (or both). There is <code>with_text_commit_mode</code> on builder 
specifically for that purpose. Use one of the following modes:</p>
<ul>
<li><code>TextCommitMode::Immediate</code> - text box will immediately send <code>Text</code> message after any change.</li>
<li><code>TextCommitMode::LostFocus</code> - text box will send <code>Text</code> message only when it loses focus.</li>
<li><code>TextCommitMode::LostFocusPlusEnter</code> - text box will send <code>Text</code> message when it loses focus or if Enter key was pressed. 
This is <strong>default</strong> behavior. In case of multiline text box hitting Enter key won't commit text!</li>
</ul>
<h2 id="filtering"><a class="header" href="#filtering">Filtering</a></h2>
<p>It is possible specify custom input filter, it can be useful if you're creating special input fields like numerical or
phone number. A filter can be specified at build stage like so:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    gui::{text_box::TextBoxBuilder, widget::WidgetBuilder, UiNode, UserInterface},
</span><span class="boring">};
</span><span class="boring">use std::{cell::RefCell, rc::Rc};
</span>fn create_text_box(ui: &amp;mut UserInterface) -&gt; Handle&lt;UiNode&gt; {
    TextBoxBuilder::new(WidgetBuilder::new())
        // Specify a filter that will pass only digits.
        .with_filter(Rc::new(RefCell::new(|c: char| c.is_ascii_digit())))
        .build(&amp;mut ui.build_ctx())
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="style"><a class="header" href="#style">Style</a></h2>
<p>You can change brush of caret by using <code>.with_caret_brush</code> and also selection brush by using <code>.with_selection_brush</code>,
it could be useful if you don't like default colors.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tree-wip"><a class="header" href="#tree-wip">Tree (WIP)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vector-image-wip"><a class="header" href="#vector-image-wip">Vector image (WIP)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="window"><a class="header" href="#window">Window</a></h1>
<p>The Window widget provides a standared window that can contain another widget. Based on setting windows can be configured
so users can do any of the following:</p>
<ul>
<li>Movable by the user. Not configurable.</li>
<li>Have title text on the title bar. Set by the <em>with_title</em> function.</li>
<li>Able to be exited by the user. Set by the <em>can_close</em> function.</li>
<li>Able to be minimized to just the Title bar, and of course maximized again. Set by the <em>can_minimize</em> function.</li>
<li>Able to resize the window. Set by the <em>can_resize</em> function.</li>
</ul>
<p>As with other UI elements, you create and configure the window using the WindowBuilder.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span>use fyrox::{
    core::{pool::Handle, algebra::Vector2},
    gui::{
        window::{WindowBuilder, WindowTitle}, 
        text::TextBuilder, 
        widget::WidgetBuilder, 
        UiNode, 
        UserInterface
    },
};

fn create_window(ui: &amp;mut UserInterface) {
    WindowBuilder::new(
        WidgetBuilder::new()
            .with_desired_position(Vector2::new(300.0, 0.0))
            .with_width(300.0),
    )
    .with_content(
        TextBuilder::new(WidgetBuilder::new())
            .with_text(&quot;Example Window content.&quot;)
            .build(&amp;mut ui.build_ctx())
    )
    .with_title(WindowTitle::text(&quot;Window&quot;))
    .can_close(true)
    .can_minimize(true)
    .open(true)
    .can_resize(false)
    .build(&amp;mut ui.build_ctx());
}
<span class="boring">}
</span></code></pre></pre>
<p>You will likely want to constrain the initial size of the window to somethig as shown in the example by providing a set
width and/or height to the base WidgetBuilder. Otherwise it will expand to fit it's content.</p>
<p>You may also want to set an inital position with the <em>with_desired_position</em> function called on the base WidgetBuilder 
which sets the position of the window's top-left corner. Otherwise all your windows will start with it's top-left corner
at 0,0 and be stacked on top of eachother.</p>
<p>Windows can only contain a single direct child widget, set by using the <em>with_content</em> function. 
Additional calls to <em>with_content</em> replaces the widgets given in previous calls, and the old widgets exist outside the 
window, so you should delete old widgets before changing a window's widget.  If you want multiple widgets, you need to 
use one of the layout container widgets like the Grid, Stack Panel, etc then add the additional widgets to that widget 
as needed.</p>
<p>The Window is a user editable object, but can only be affected by UI Messages they trigger if the message's corresponding
variable has been set to true aka what is set by the <em>can_close</em>, <em>can_minimize</em>, and <em>can_resize</em> functions.</p>
<h2 id="initial-open-state"><a class="header" href="#initial-open-state">Initial Open State</a></h2>
<p>By default, the window will be created in the open, or maximized, state. You can manually set this state via the <em>open</em>
function providing a true or false as desired.</p>
<h2 id="styling-the-buttons"><a class="header" href="#styling-the-buttons">Styling the Buttons</a></h2>
<p>The window close and minimise buttons can be configured with the <em>with_close_button</em> and <em>with_minimize_button</em> functions.
You will want to pass them a button widget, but can do anything else you like past that.</p>
<h2 id="modal-aka-forced-focus"><a class="header" href="#modal-aka-forced-focus">Modal (AKA Forced Focus)</a></h2>
<p>A Modal in UI design terms indicates a window or box that has forced focus. The user is not able to interact with anything 
else until the modal is dissmissed. </p>
<p>Any window can be set and unset as a modal via the <em>modal</em> function.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wrap-panel"><a class="header" href="#wrap-panel">Wrap panel</a></h1>
<p>Wrap panel is used to stack children widgets either in vertical or horizontal direction with overflow - every widget
that does not have enough space on current line, will automatically be placed on the next line.</p>
<h2 id="how-to-create-15"><a class="header" href="#how-to-create-15">How to create</a></h2>
<p>Use <code>WrapPanelBuilder</code> to create new wrap panel instance:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    gui::{
</span><span class="boring">        widget::WidgetBuilder, wrap_panel::WrapPanelBuilder, BuildContext, Orientation, UiNode,
</span><span class="boring">    },
</span><span class="boring">};
</span><span class="boring">
</span>fn create_wrap_panel(ctx: &amp;mut BuildContext) -&gt; Handle&lt;UiNode&gt; {
    WrapPanelBuilder::new(WidgetBuilder::new())
        .with_orientation(Orientation::Horizontal)
        .build(ctx)
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="orientation"><a class="header" href="#orientation">Orientation</a></h2>
<p>Wrap panel can stack your widgets either in vertical or horizontal direction. Use <code>.with_orientation</code> while building 
the panel to switch orientation to desired.</p>
<h2 id="use-cases"><a class="header" href="#use-cases">Use cases</a></h2>
<p>One of many use case examples could be picture gallery, or asset browser in the Fyroxed:</p>
<p><img src="fyrox/ui/wrap_panel.png" alt="wrap panel" /></p>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="miscellaneous"><a class="header" href="#miscellaneous">Miscellaneous</a></h1>
<p>This section contains information about miscellaneous things, which does not deserve separate section.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="logging"><a class="header" href="#logging">Logging</a></h1>
<p>The engine has built-in logger that allows you to trace execution of your game by creating log entries when needed.</p>
<p><img src="fyrox/misc/log.png" alt="Log" /></p>
<p>The window allows you to select severity of the messages that will be put in the window:</p>
<ul>
<li><code>Info+</code> will show all messages with <code>Info</code>, <code>Warning</code>, <code>Error</code> severities.</li>
<li><code>Warning+</code> will show all messages with <code>Warning</code> and <code>Error</code> severities.</li>
<li><code>Error</code> will show all messages with only <code>Error</code> severity.</li>
</ul>
<p>Each log entry can be copied to the clipboard by right-clicking on it and pressing <code>Copy</code> in the context menu. You can
also clear the log using <code>Clear</code> button.</p>
<h2 id="writing-to-the-log"><a class="header" href="#writing-to-the-log">Writing to the log</a></h2>
<p>You can use one of <code>Log::info</code>, <code>Log::warn</code>, <code>Log::err</code> methods, or use <code>Log::writeln</code> with severity specified. It is also
possible to select desired severity level:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::utils::log::{Log, MessageKind};
</span>// These lines will be printed.
Log::info(&quot;This is some info&quot;);
Log::warn(&quot;This is some warning&quot;);
Log::err(&quot;This is some error&quot;);

Log::set_verbosity(MessageKind::Warning);

Log::info(&quot;This is some info&quot;); // This won't be printed.
Log::warn(&quot;This is some warning&quot;);
Log::err(&quot;This is some error&quot;);
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tutorials"><a class="header" href="#tutorials">Tutorials</a></h1>
<p>The book offers a set of tutorials of how to write a game of specific genre using the engine. Every tutorial starts
from mild difficulty and keep increasing the difficulty until the end. All tutorials are very well structured and
you shouldn't be able to lost in them.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="first-person-shooter-tutorial"><a class="header" href="#first-person-shooter-tutorial">First-Person Shooter Tutorial</a></h1>
<p><strong>WARNING: This tutorial is using obsolete engine features, which are subject to be removed in future versions!</strong></p>
<p>In this tutorial we'll make a 3D shooter - something similar to <a href="https://github.com/mrDIMAS/rusty-shooter">rusty-shooter</a>.
Also, the series should help you to learn basic principles which lies in the foundation of the engine.</p>
<h2 id="fyrox-and-fyroxed-version"><a class="header" href="#fyrox-and-fyroxed-version">Fyrox and Fyroxed version</a></h2>
<p>Fyrox changes rapidly and tutorial's code could not compile with the newest versions of the engine, to prevent that
and keep the code compilable over time the versions of both the engine and the editor are set to specific commits 
in the main repo.</p>
<p><strong>Fyrox version</strong>: 0.26<br />
<strong>Source code</strong>: <a href="https://github.com/FyroxEngine/Fyrox-tutorials/">GitHub</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fps-tutorial-part-1---character-controller"><a class="header" href="#fps-tutorial-part-1---character-controller">FPS Tutorial Part 1 - Character Controller.</a></h1>
<p><strong>WARNING: This tutorial is using obsolete engine features, which are subject to be removed in future versions!</strong></p>
<p><strong>Source code</strong>: <a href="https://github.com/FyroxEngine/Fyrox-tutorials/tree/main/tutorial1-character-controller">GitHub</a></p>
<h2 id="table-of-contents"><a class="header" href="#table-of-contents">Table of contents</a></h2>
<ul>
<li><a href="fyrox/tutorials/fps/tutorial-1/tutorial-part-1.html#introduction">Introduction</a></li>
<li><a href="fyrox/tutorials/fps/tutorial-1/tutorial-part-1.html#creating-a-window">Creating a window</a></li>
<li><a href="fyrox/tutorials/fps/tutorial-1/tutorial-part-1.html#creating-your-first-scene">Creating your first scene</a></li>
<li><a href="fyrox/tutorials/fps/tutorial-1/tutorial-part-1.html#using-the-scene">Using the scene</a></li>
<li><a href="fyrox/tutorials/fps/tutorial-1/tutorial-part-1.html#character-controller">Character controller</a></li>
<li><a href="fyrox/tutorials/fps/tutorial-1/tutorial-part-1.html#finishing-touch">Finishing touch</a></li>
<li><a href="fyrox/tutorials/fps/tutorial-1/tutorial-part-1.html#conclusion">Conclusion</a></li>
</ul>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>Fyrox is a general purpose 3D engine, it allows creating any kind of 3D game, but today we'll focus on classic 3D shooter.
In this tutorial we'll write a simple character controller. This is what we're aiming for:</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/VcN3NUdfg3E" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<p>Let's start by creating a new cargo project, make a folder and execute this:</p>
<pre><code class="language-bash">cargo init --bin
</code></pre>
<p>Open Cargo.toml and add <code>fyrox</code> dependency:</p>
<pre><code class="language-toml">[dependencies]
fyrox = &quot;0.26.0&quot;
</code></pre>
<h3 id="creating-a-window"><a class="header" href="#creating-a-window">Creating a window</a></h3>
<p>Great! Now we can start writing the game. Let's start from something very simple - a window and a main loop. Just copy 
and paste this code in the <code>main.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">extern crate fyrox;
</span>use fyrox::{
    core::{
        algebra::{UnitQuaternion, Vector3},
        pool::Handle,
    },
    engine::{resource_manager::ResourceManager, Engine, EngineInitParams, SerializationContext},
    event::{DeviceEvent, ElementState, Event, VirtualKeyCode, WindowEvent},
    event_loop::{ControlFlow, EventLoop},
    resource::texture::TextureWrapMode,
    scene::{
        base::BaseBuilder,
        camera::{CameraBuilder, SkyBox, SkyBoxBuilder},
        collider::{ColliderBuilder, ColliderShape},
        node::Node,
        rigidbody::RigidBodyBuilder,
        transform::TransformBuilder,
        Scene,
    },
    window::WindowBuilder,
};
use std::{sync::Arc, time};

// Our game logic will be updated at 60 Hz rate.
const TIMESTEP: f32 = 1.0 / 60.0;

struct Game {
    // Empty for now.
}

impl Game {
    pub fn new() -&gt; Self {
        Self {}
    }

    pub fn update(&amp;mut self) {
        // Game logic will be placed here.
    }
}

fn main() {
    // Configure main window first.
    let window_builder = WindowBuilder::new().with_title(&quot;3D Shooter Tutorial&quot;);
    // Create event loop that will be used to &quot;listen&quot; events from the OS.
    let event_loop = EventLoop::new();

    // Finally create an instance of the engine.
    let serialization_context = Arc::new(SerializationContext::new());
    let mut engine = Engine::new(EngineInitParams {
        window_builder,
        resource_manager: ResourceManager::new(serialization_context.clone()),
        serialization_context,
        events_loop: &amp;event_loop,
        vsync: false,
    })
    .unwrap();

    // Initialize game instance. It is empty for now.
    let mut game = Game::new();

    // Run the event loop of the main window. which will respond to OS and window events and update
    // engine's state accordingly. Engine lets you to decide which event should be handled,
    // this is a minimal working example of how it should be.
    let clock = time::Instant::now();

    let mut elapsed_time = 0.0;
    event_loop.run(move |event, _, control_flow| {
        match event {
            Event::MainEventsCleared =&gt; {
                // This main game loop - it has fixed time step which means that game
                // code will run at fixed speed even if renderer can't give you desired
                // 60 fps.
                let mut dt = clock.elapsed().as_secs_f32() - elapsed_time;
                while dt &gt;= TIMESTEP {
                    dt -= TIMESTEP;
                    elapsed_time += TIMESTEP;

                    // Run our game's logic.
                    game.update();

                    // Update engine each frame.
                    engine.update(TIMESTEP, control_flow);
                }

                // Rendering must be explicitly requested and handled after RedrawRequested event is received.
                engine.get_window().request_redraw();
            }
            Event::RedrawRequested(_) =&gt; {
                // Render at max speed - it is not tied to the game code.
                engine.render().unwrap();
            }
            Event::WindowEvent { event, .. } =&gt; match event {
                WindowEvent::CloseRequested =&gt; *control_flow = ControlFlow::Exit,
                WindowEvent::KeyboardInput { input, .. } =&gt; {
                    // Exit game by hitting Escape.
                    if let Some(VirtualKeyCode::Escape) = input.virtual_keycode {
                        *control_flow = ControlFlow::Exit
                    }
                }
			    WindowEvent::Resized(size) =&gt; {
                    // It is very important to handle Resized event from window, because
                    // renderer knows nothing about window size - it must be notified
                    // directly when window size has changed.
                    engine.set_frame_size(size.into()).unwrap();
                }
                _ =&gt; (),
            },
            _ =&gt; *control_flow = ControlFlow::Poll,
        }
    });
}
</code></pre></pre>
<p>Wow! There is lots of code for such a simple task. Fear not, everything here is pretty straightforward, let's dive into
this code and disassemble it line by line. Just skip imports, it's too boring. Let's look at this line:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const TIMESTEP: f32 = 1.0 / 60.0;
<span class="boring">}
</span></code></pre></pre>
<p>Here we define a rate of update for logic of our future game, just sticking to common 60 FPS. Next goes the skeleton of
the game, just a struct with two methods. It will be filled later in this tutorial.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Game {
    // Empty for now.
}

impl Game {
    pub fn new() -&gt; Self {
        Self {}
    }

    pub fn update(&amp;mut self) {
        // Game logic will be placed here.
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Finally, we at the point where the interesting stuff happens - <code>fn main()</code>. We're starting by creating a window builder:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::window::WindowBuilder;
</span>let window_builder = WindowBuilder::new().with_title(&quot;3D Shooter Tutorial&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>The builder will be used later by the engine to create a window. Next we're creating our event loop: </p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::event_loop::EventLoop;
</span>let event_loop = EventLoop::new();
<span class="boring">}
</span></code></pre></pre>
<p>The event loop is a &quot;magic&quot; thing that receives events from the operating system and feeds your application, this is a very 
important part which makes the application work. Finally, we're creating an instance of the engine:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let serialization_context = Arc::new(SerializationContext::new());
let mut engine = Engine::new(EngineInitParams {
    window_builder,
    resource_manager: ResourceManager::new(serialization_context.clone()),
    serialization_context,
    events_loop: &amp;event_loop,
    vsync: false,
})
.unwrap();
<span class="boring">}
</span></code></pre></pre>
<p>At first, we're creating an instance of <code>SerializationContext</code> - it is used to store type constructors used for 
serialization needs. Next, we're filling <code>EngineInitParams</code> structure, there is nothing interesting there, except maybe
a flag that is responsible for vertical synchronization (VSync). In this tutorial we'll have VSync disabled, because
it requires specific platform-dependent extensions which are not always available and calling <code>.unwrap()</code> might result
in panic on some platforms. Next we're creating an instance of the game, remember this line, it will be changed soon:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut game = Game::new();
<span class="boring">}
</span></code></pre></pre>
<p>Next we define two variables for the game loop: </p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let clock = time::Instant::now();
let mut elapsed_time = 0.0;
<span class="boring">}
</span></code></pre></pre>
<p>At first, we &quot;remember&quot; the starting point of the game in time. The next variable is used to control the game loop. Finally, we run the
event loop and start checking for events coming from the OS:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>event_loop.run(move |event, _, control_flow| {
    match event {
        ...
    }
});
<span class="boring">}
</span></code></pre></pre>
<p>Let's look at each event separately starting from <code>Event::MainEventsCleared</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Event::MainEventsCleared =&gt; {
    // This main game loop - it has fixed time step which means that game
    // code will run at fixed speed even if renderer can't give you desired
    // 60 fps.
    let mut dt = clock.elapsed().as_secs_f32() - elapsed_time;
    while dt &gt;= TIMESTEP {
        dt -= TIMESTEP;
        elapsed_time += TIMESTEP;

        // Run our game's logic.
        game.update();

        // Update engine each frame.
        engine.update(TIMESTEP);
    }

    // Rendering must be explicitly requested and handled after RedrawRequested event is received.
    engine.get_window().request_redraw();
}
<span class="boring">}
</span></code></pre></pre>
<p>This is the heart of game loop - it stabilizes update rate of game logic by measuring time from last update call
and performs a various amount of iterations based on an amount of time since last update. This makes the game logic update
rate independent of FPS - it will be always 60 Hz for game logic even if FPS is 10. The <code>while</code> loop contains 
<code>game.update()</code> and <code>engine.update(TIMESTEP)</code> calls to update game's logic and engine internals respectively. After the
loop we're asking the engine to render the next frame. In the next match arm <code>Event::RedrawRequested</code> we're handing our request: </p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Event::RedrawRequested(_) =&gt; {
    // Render at max speed - it is not tied to the game code.
    engine.render().unwrap();
}
<span class="boring">}
</span></code></pre></pre>
<p>As you can see rendering happens in a single line of code. Next we need to handle window events:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Event::WindowEvent { event, .. } =&gt; match event {
    WindowEvent::CloseRequested =&gt; *control_flow = ControlFlow::Exit,
    WindowEvent::KeyboardInput { input, .. } =&gt; {
        // Exit game by hitting Escape.
        if let Some(VirtualKeyCode::Escape) = input.virtual_keycode {
            *control_flow = ControlFlow::Exit
        }
    }
	WindowEvent::Resized(size) =&gt; {
		// It is very important to handle Resized event from window, because
		// renderer knows nothing about window size - it must be notified
		// directly when window size has changed.
		engine.set_frame_size(size.into()).unwrap();
	}
    _ =&gt; (),
},
<span class="boring">}
</span></code></pre></pre>
<p>Here we're just checking if the player has hit Escape button and exit game if so. Also, when <code>WindowEvent::Resized</code> is 
received, we're notifying renderer about that, so it's render targets will be resized too. The final match arm is for 
every other event, nothing fancy here - just asking engine to continue listening for new events.</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>_ =&gt; *control_flow = ControlFlow::Poll,
<span class="boring">}
</span></code></pre></pre>
<p>So far so good. This small piece of code just creates a new window and fills it with black color, now we can start 
writing the game. </p>
<p><img src="fyrox/tutorials/fps/tutorial-1/./tutorial1-window.jpg" alt="Window" /></p>
<p>Let's start by creating a simple scene where we'll test our character controller. This is the time when 
<a href="https://github.com/FyroxEngine/Fyrox/tree/master/editor">Fyroxed</a> comes into play - Fyroxed is a native scene editor of the
engine. It is worth mentioning what &quot;scene editor&quot; means: unlike many other engines (Unity, UnrealEngine, etc.),
Fyroxed does <strong>not</strong> allow you to run your game inside it, instead you just edit your scene, save it in the editor and load it in
your game. Being able to run a game inside the editor was a very huge task for one person, and I just chose the 
easiest way. Alright, back to the interesting stuff. Build the editor first using instructions from its
<a href="https://github.com/FyroxEngine/Fyrox/tree/master/editor">GitHub page</a> using specific commit stated in the beginning of the article.</p>
<h2 id="creating-your-first-scene"><a class="header" href="#creating-your-first-scene">Creating your first scene</a></h2>
<p>This section is completely optional, if you eager to make the game - just use a 
<a href="fyrox/tutorials/fps/tutorial-1/./data.zip">pre-made scene</a> (download it and unpack in the folder of your game) and go to
the <a href="fyrox/tutorials/fps/tutorial-1/tutorial-part-1.html#using-the-scene">next section</a>. Open Fyroxed, it should look like this:</p>
<p><img src="fyrox/tutorials/fps/tutorial-1/./tutorial1-rusty-editor.jpg" alt="Fyroxed" /></p>
<p>It will ask you to choose a working directory.</p>
<p><img src="fyrox/tutorials/fps/tutorial-1/./tutorial1-configurator.jpg" alt="configurator" /></p>
<p>The working directory is simply a path to your game's executable, in most cases it will be the root folder of your
project.</p>
<p>Next, click <code>File -&gt; CreateScene</code>. Now you can start modifying your scene. All we need for now is a floor and maybe 
some decorations. To do that, you can either create everything from simple objects (cubes, cones, cylinders,
etc.) or load some assets made in 3D editors (like Blender, 3Ds max, etc.). Here we combine two approaches: floor will 
be just a squashed cube and decorations will be 3D models. Let's start from the floor. Click <code>Create -&gt; Mesh -&gt; Cube</code>, 
select the cube and use Scale tool from the toolbar to squash it to form the floor.</p>
<p><img src="fyrox/tutorials/fps/tutorial-1/./tutorial1-rusty-editor-floor.jpg" alt="Floor" /></p>
<p>Next we need to add physical body to the floor to not fall through it. This is very simple, click <code>Create -&gt; Physics -&gt; Rigid Body</code>
then right-click on the rigid body in the World Viewer and click <code>Create -&gt; Physics -&gt; Collider</code>. Next we need to bind the 
floor 3D model with the rigid body, to do that drag'n'drop the floor entity to the rigid body. Now we need to configure the
collider of the rigid body. Select it and go to Inspector, find Shape property and select Trimesh from the dropdown list.
Next, click <code>+</code> sign in Sources and then drag'n'drop floor entity to <code>Unassigned</code> entry while holding <code>Alt</code> on the keyboard.
By doing this, we've added a source of geometry for triangle mesh collider. Also, we need to make the rigid body
static, so it won't be affected by gravity and external forces, otherwise the floor will fall as any other
dynamic rigid body. To do that, simply select the body and change its <code>Body Type</code> property to <code>Static</code>.</p>
<p><img src="fyrox/tutorials/fps/tutorial-1/./tutorial1-rusty-editor-floor-body.jpg" alt="Floor Body" /></p>
<p>Ok, good, but it looks awful, let's add some texture to it, to do that, 
<a href="fyrox/tutorials/fps/tutorial-1/./floor.jpg">download floor texture</a>, place it to <code>data/textures</code> and apply it to the floor. 
To do that, use the asset browser: at its left side it shows file system of your project, locate <code>data/textures</code> folder 
and select <code>floor.jpg</code>. Now just drag-n-drop the texture to the floor, this is what you should get.</p>
<p><img src="fyrox/tutorials/fps/tutorial-1/./tutorial1-rusty-editor-floor-texture.jpg" alt="Floor Texture" /></p>
<p>Now let's add some decorations, to do that <a href="fyrox/tutorials/fps/tutorial-1/./barrel.zip">download 3D model</a> I prepared for
this tutorial and unpack it in <code>data/models</code>. Now go to the <code>data/models</code> in the asset browser and just drag-n-drop the
<code>barrel.FBX</code> to the scene. Now use the Scale and Move tools to adjust scale and position of the barrel, it should look 
like this: </p>
<p><img src="fyrox/tutorials/fps/tutorial-1/./tutorial1-rusty-editor-barrel-body.jpg" alt="Barrel Body" /></p>
<p>Barrel does not have any rigid body yet, and it won't interact with world. Let's fix this. As usual, click <code>Create -&gt; Physics -&gt; Rigid Body</code> 
then click on the added rigid body and add a cylinder collider by right-click on it and selecting <code>Create -&gt; Physics -&gt; Colider</code>.
Now select the collider and set its shape to Cylinder adjust its height and radius. As a final step drag'n'drop the <code>barrel.FBX</code> scene 
node on the rigid body node.</p>
<p>Now clone some barrels, to do that select a parent rigid body of some <code>barrel.FBX</code> in the <code>World Outliner</code>, 
right-click on the scene preview and press <code>Ctrl+C</code> to copy the barrel and <code>Ctrl+V</code> to paste. Repeat multiple times.</p>
<p><img src="fyrox/tutorials/fps/tutorial-1/./tutorial1-rusty-editor-barrels.jpg" alt="Barrel" /></p>
<p>Also add a light source, to do that go to <code>Create -&gt; Light -&gt; Point</code> and adjust its position using the Move tool.</p>
<p><img src="fyrox/tutorials/fps/tutorial-1/./tutorial1-rusty-editor-light.jpg" alt="Barrel" /></p>
<p>The final step: save your scene in <code>data/models</code>, to do that go to <code>File -&gt; Save</code> and select the folder and type name 
of the scene in the field it should be <code>scene.rgs</code>.</p>
<h2 id="using-the-scene"><a class="header" href="#using-the-scene">Using the scene</a></h2>
<p>Now it's the time to load the scene we've made earlier in the game. This is very simple, all we need to do is to load
scene as resource and create its instance. Change <code>fn new()</code> body to:</p>
<pre><pre class="playground"><code class="language-rust no_run edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::{algebra::Vector3, pool::Handle},
</span><span class="boring">    engine::Engine,
</span><span class="boring">    scene::{
</span><span class="boring">        base::BaseBuilder, camera::CameraBuilder, node::Node, transform::TransformBuilder,
</span><span class="boring">        Scene,
</span><span class="boring">    },
</span><span class="boring">};
</span><span class="boring">struct Stub {
</span><span class="boring">    camera: Handle&lt;Node&gt;,
</span><span class="boring">    scene: Handle&lt;Scene&gt;,
</span><span class="boring">}
</span><span class="boring">impl Stub {
</span>pub async fn new(engine: &amp;mut Engine) -&gt; Self {
    let mut scene = Scene::new();

    // Load a scene resource and create its instance.
    engine
        .resource_manager
        .request_model(&quot;data/models/scene.rgs&quot;)
        .await
        .unwrap()
        .instantiate_geometry(&amp;mut scene);

    // Next create a camera, it is our &quot;eyes&quot; in the world.
    // This can also be made in editor, but for educational purpose we'll made it by hand.
    let camera = CameraBuilder::new(
        BaseBuilder::new().with_local_transform(
            TransformBuilder::new()
                .with_local_position(Vector3::new(0.0, 1.0, -3.0))
                .build(),
        ),
    )
    .build(&amp;mut scene.graph);

    Self {
        camera,
        scene: engine.scenes.add(scene),
    }
}
<span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p>You may have noticed that the <code>Game</code> structure now has two new fields: </p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Game {
    scene: Handle&lt;Scene&gt;, // A handle to the scene
    camera: Handle&lt;Node&gt;, // A handle to the camera
}
<span class="boring">}
</span></code></pre></pre>
<p>These fields are just handles to the &quot;entities&quot; we've created in the <code>Game::new()</code>. Also, change <code>let mut game = Game::new();</code> to this:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut game = fyrox::core::futures::executor::block_on(Game::new(&amp;mut engine));
<span class="boring">}
</span></code></pre></pre>
<p>Here we execute async function <code>Game::new()</code> and it creates game's instance with the scene we've made previously.
Run the game and you should see this:</p>
<p><img src="fyrox/tutorials/fps/tutorial-1/./tutorial1-scene.jpg" alt="Barrel" /></p>
<p>Cool! Now let's disassemble <code>fn new()</code> line by line. First, we're creating an empty scene:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut scene = Scene::new();
<span class="boring">}
</span></code></pre></pre>
<p>The next few lines are the most interesting:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>engine
    .resource_manager
    .request_model(&quot;data/models/scene.rgs&quot;)
    .await
    .unwrap()
    .instantiate_geometry(&amp;mut scene);
<span class="boring">}
</span></code></pre></pre>
<p>Here we're asking the resource manager to load the scene we've made previously, awaiting while it loads and then instantiating
it on the <code>scene</code>. What does &quot;instantiation&quot; mean? In short, it means that we're creating a copy of a scene and adding the copy
to some other scene, the engine remembers connections between clones and original entities and is capable of restoring data
from resource for the instance. At this point we've successfully instantiated the scene. However, we won't see anything
yet - we need a camera:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let camera = CameraBuilder::new(
    BaseBuilder::new().with_local_transform(
        TransformBuilder::new()
            .with_local_position(Vector3::new(0.0, 1.0, -3.0))
            .build(),
    ),
)
.build(&amp;mut scene.graph);
<span class="boring">}
</span></code></pre></pre>
<p>Camera is our &quot;eyes&quot; in the world, here we're just creating a camera and moving it a bit up and back to be able to see the 
scene. Finally, we're adding the scene to the engine's container for scenes, and it gives us a handle to the scene. Later
we'll use the handle to borrow scene and modify it.</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Self {
    camera,
    scene: engine.scenes.add(scene),
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="character-controller"><a class="header" href="#character-controller">Character controller</a></h2>
<p>We've made a lot of things already, but still can't move in the scene. Let's fix this! We'll start writing the character
controller which will allow us to walk in our scene. Let's start with a chunk of code as usual:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::{
</span><span class="boring">        algebra::{UnitQuaternion, Vector3},
</span><span class="boring">        pool::Handle,
</span><span class="boring">    },
</span><span class="boring">    engine::{resource_manager::ResourceManager, Engine},
</span><span class="boring">    event::{DeviceEvent, ElementState, Event, VirtualKeyCode, WindowEvent},
</span><span class="boring">    event_loop::{ControlFlow, EventLoop},
</span><span class="boring">    resource::texture::TextureWrapMode,
</span><span class="boring">    scene::{
</span><span class="boring">        base::BaseBuilder,
</span><span class="boring">        camera::{CameraBuilder, SkyBox, SkyBoxBuilder},
</span><span class="boring">        collider::{ColliderBuilder, ColliderShape},
</span><span class="boring">        node::Node,
</span><span class="boring">        rigidbody::RigidBodyBuilder,
</span><span class="boring">        transform::TransformBuilder,
</span><span class="boring">        Scene,
</span><span class="boring">    },
</span><span class="boring">    window::WindowBuilder,
</span><span class="boring">};
</span><span class="boring">use std::time;
</span>
#[derive(Default)]
struct InputController {
    move_forward: bool,
    move_backward: bool,
    move_left: bool,
    move_right: bool,
    pitch: f32,
    yaw: f32,
}

struct Player {
    camera: Handle&lt;Node&gt;,
    rigid_body: Handle&lt;Node&gt;,
    controller: InputController,
}

impl Player {
    fn new(scene: &amp;mut Scene) -&gt; Self {
        // Create rigid body with a camera, move it a bit up to &quot;emulate&quot; head.
        let camera;
        let rigid_body_handle = RigidBodyBuilder::new(
            BaseBuilder::new()
                .with_local_transform(
                    TransformBuilder::new()
                        // Offset player a bit.
                        .with_local_position(Vector3::new(0.0, 1.0, -1.0))
                        .build(),
                )
                .with_children(&amp;[
                    {
                        camera = CameraBuilder::new(
                            BaseBuilder::new().with_local_transform(
                                TransformBuilder::new()
                                    .with_local_position(Vector3::new(0.0, 0.25, 0.0))
                                    .build(),
                            ),
                        )
                        .build(&amp;mut scene.graph);
                        camera
                    },
                    // Add capsule collider for the rigid body.
                    ColliderBuilder::new(BaseBuilder::new())
                        .with_shape(ColliderShape::capsule_y(0.25, 0.2))
                        .build(&amp;mut scene.graph),
                ]),
        )
        // We don't want the player to tilt.
        .with_locked_rotations(true)
        // We don't want the rigid body to sleep (be excluded from simulation)
        .with_can_sleep(false)
        .build(&amp;mut scene.graph);

        Self {
            camera,
            rigid_body: rigid_body_handle,
            controller: Default::default(),
        }
    }

    fn update(&amp;mut self, scene: &amp;mut Scene) {
        // Set pitch for the camera. These lines responsible for up-down camera rotation.
        scene.graph[self.camera].local_transform_mut().set_rotation(
            UnitQuaternion::from_axis_angle(&amp;Vector3::x_axis(), self.controller.pitch.to_radians()),
        );

        // Borrow rigid body node.
        let body = scene.graph[self.rigid_body].as_rigid_body_mut();

        // Keep only vertical velocity, and drop horizontal.
        let mut velocity = Vector3::new(0.0, body.lin_vel().y, 0.0);

        // Change the velocity depending on the keys pressed.
        if self.controller.move_forward {
            // If we moving forward then add &quot;look&quot; vector of the body.
            velocity += body.look_vector();
        }
        if self.controller.move_backward {
            // If we moving backward then subtract &quot;look&quot; vector of the body.
            velocity -= body.look_vector();
        }
        if self.controller.move_left {
            // If we moving left then add &quot;side&quot; vector of the body.
            velocity += body.side_vector();
        }
        if self.controller.move_right {
            // If we moving right then subtract &quot;side&quot; vector of the body.
            velocity -= body.side_vector();
        }

        // Finally new linear velocity.
        body.set_lin_vel(velocity);

        // Change the rotation of the rigid body according to current yaw. These lines responsible for
        // left-right rotation.
        body.local_transform_mut()
            .set_rotation(UnitQuaternion::from_axis_angle(
                &amp;Vector3::y_axis(),
                self.controller.yaw.to_radians(),
            ));
    }

    fn process_input_event(&amp;mut self, event: &amp;Event&lt;()&gt;) {
        match event {
            Event::WindowEvent { event, .. } =&gt; {
                if let WindowEvent::KeyboardInput { input, .. } = event {
                    if let Some(key_code) = input.virtual_keycode {
                        match key_code {
                            VirtualKeyCode::W =&gt; {
                                self.controller.move_forward = input.state == ElementState::Pressed;
                            }
                            VirtualKeyCode::S =&gt; {
                                self.controller.move_backward =
                                    input.state == ElementState::Pressed;
                            }
                            VirtualKeyCode::A =&gt; {
                                self.controller.move_left = input.state == ElementState::Pressed;
                            }
                            VirtualKeyCode::D =&gt; {
                                self.controller.move_right = input.state == ElementState::Pressed;
                            }
                            _ =&gt; (),
                        }
                    }
                }
            }
            Event::DeviceEvent { event, .. } =&gt; {
                if let DeviceEvent::MouseMotion { delta } = event {
                    self.controller.yaw -= delta.0 as f32;

                    self.controller.pitch =
                        (self.controller.pitch + delta.1 as f32).clamp(-90.0, 90.0);
                }
            }
            _ =&gt; (),
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>This is all the code we need for character controller, quite a lot actually, but as usual everything here is pretty
straightforward.</p>
<pre><pre class="playground"><code class="language-rust no_run edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::core::pool::Handle;
</span><span class="boring">use fyrox::engine::Engine;
</span><span class="boring">use fyrox::scene::Scene;
</span><span class="boring">struct Player;
</span><span class="boring">impl Player {
</span><span class="boring">    fn new(_scene: &amp;mut Scene) -&gt; Self {
</span><span class="boring">        Self
</span><span class="boring">    }
</span><span class="boring">    fn update(&amp;mut self, _scene: &amp;mut Scene) {}
</span><span class="boring">}
</span>// Also we must change Game structure a bit too and the new() code.
struct Game {
    scene: Handle&lt;Scene&gt;,
    player: Player, // New
}

impl Game {
    pub async fn new(engine: &amp;mut Engine) -&gt; Self {
        let mut scene = Scene::new();

        // Load a scene resource and create its instance.
        engine
            .resource_manager
            .request_model(&quot;data/models/scene.rgs&quot;)
            .await
            .unwrap()
            .instantiate_geometry(&amp;mut scene);

        Self {
            player: Player::new(&amp;mut scene), // New
            scene: engine.scenes.add(scene),
        }
    }

    pub fn update(&amp;mut self, engine: &amp;mut Engine) {
        self.player.update(&amp;mut engine.scenes[self.scene]); // New
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>We've moved camera creation to <code>Player</code>, because now the camera is attached to the player's body. Also, we must add this line
in the beginning of <code>event_loop.run(...)</code> to let <code>player</code> handle input events:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>game.player.process_input_event(&amp;event);        
<span class="boring">}
</span></code></pre></pre>
<p>So, let's try to understand what happens in this huge chunk of code. Let's start from the <code>InputController</code> struct,
it holds the state of the input for a single frame and rotations of player &quot;parts&quot;. </p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Default)]
struct InputController {
    move_forward: bool,
    move_backward: bool,
    move_left: bool,
    move_right: bool,
    pitch: f32,
    yaw: f32,
}
<span class="boring">}
</span></code></pre></pre>
<p>Next goes the <code>Player::new()</code> function. First, we're creating a simple chain of nodes of different kinds in the
<a href="https://en.wikipedia.org/wiki/Scene_graph">scene graph</a>. </p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let camera;
let rigid_body_handle = RigidBodyBuilder::new(
        BaseBuilder::new()
            .with_local_transform(
                TransformBuilder::new()
                    // Offset player a bit.
                    .with_local_position(Vector3::new(0.0, 1.0, -1.0))
                    .build(),
            )
            .with_children(&amp;[
                {
                    camera = CameraBuilder::new(
                        BaseBuilder::new().with_local_transform(
                            TransformBuilder::new()
                                .with_local_position(Vector3::new(0.0, 0.25, 0.0))
                                .build(),
                        ),
                    )
                    .build(&amp;mut scene.graph);
                    camera
                },
                // Add capsule collider for the rigid body.
                ColliderBuilder::new(BaseBuilder::new())
                    .with_shape(ColliderShape::capsule_y(0.25, 0.2))
                    .build(&amp;mut scene.graph),
            ]),
    )
    // We don't want the player to tilt.
    .with_locked_rotations(true)
    // We don't want the rigid body to sleep (be excluded from simulation)
    .with_can_sleep(false)
    .build(&amp;mut scene.graph);
<span class="boring">}
</span></code></pre></pre>
<p>Basically we're making something like this:</p>
<p><img src="fyrox/tutorials/fps/tutorial-1/./tutorial1-graph-example.png" alt="Graph" /></p>
<p>As you can see, the camera is attached to the rigid body and has a <strong>relative</strong> position of <code>(0.0, 0.25, 0.0)</code>. So when we'll
move rigid body, the camera will move too (and rotate of course). </p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Self {
    camera,
    rigid_body: rigid_body_handle,
    controller: Default::default(),
}
<span class="boring">}
</span></code></pre></pre>
<p>Next goes the <code>fn update(...)</code> function, it is responsible for movement of the player. It starts from these lines:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Set pitch for the camera. These lines responsible for up-down camera rotation.
scene.graph[self.camera].local_transform_mut().set_rotation(
    UnitQuaternion::from_axis_angle(&amp;Vector3::x_axis(), self.controller.pitch.to_radians()),
);
<span class="boring">}
</span></code></pre></pre>
<p>We're borrowing the camera from the graph (<code>scene.graph[self.camera]</code>) and modifying its <strong>local</strong> rotation, using a 
<a href="https://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation">quaternion</a> built from an axis, and an angle.
This rotates camera in vertical direction. Let's talk about borrowing in the engine. Almost every object in the 
engine &quot;lives&quot; in generational arenas (pool in fyrox's terminology). Pool is a contiguous chunk of memory, to be
able to &quot;reference&quot; an object in a pool Fyrox uses handles. Almost every entity has a single owner - the engine,
so to mutate or read data from an entity your have to borrow it first, like this:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Borrow rigid body node.
let body = scene.graph[self.rigid_body].as_rigid_body_mut();
<span class="boring">}
</span></code></pre></pre>
<p>This piece of code <code>scene.graph[self.rigid_body]</code> borrows <code>rigid_body</code> as either mutable or shared, depending on the context (basically
it is just an implementation of Index + IndexMut traits). Once we've borrowed objects, we can modify them. As the next
step we calculate new horizontal speed for the player:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Keep only vertical velocity, and drop horizontal.
let mut velocity = Vector3::new(0.0, body.lin_vel().y, 0.0);

// Change the velocity depending on the keys pressed.
if self.controller.move_forward {
    // If we moving forward then add &quot;look&quot; vector of the body.
    velocity += body.look_vector();
}
if self.controller.move_backward {
    // If we moving backward then subtract &quot;look&quot; vector of the body.
    velocity -= body.look_vector();
}
if self.controller.move_left {
    // If we moving left then add &quot;side&quot; vector of the body.
    velocity += body.side_vector();
}
if self.controller.move_right {
    // If we moving right then subtract &quot;side&quot; vector of the body.
    velocity -= body.side_vector();
}

// Finally new linear velocity.
body.set_lin_vel(velocity);
<span class="boring">}
</span></code></pre></pre>
<p>We don't need to modify vertical speed, because it should be controlled by the physics engine. Finally, we're setting
rotation of the rigid body:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Change the rotation of the rigid body according to current yaw. These lines responsible for
// left-right rotation.
body.local_transform_mut()
    .set_rotation(UnitQuaternion::from_axis_angle(
        &amp;Vector3::y_axis(),
        self.controller.yaw.to_radians(),
    ));
<span class="boring">}
</span></code></pre></pre>
<p>The next piece of code is a bit boring, but still should be addressed - it is input handling. In the <code>process_input_event</code>
we check input events and configure input controller accordingly. Basically we're just checking if W, S, A, D keys were 
pressed or released. In the <code>MouseMotion</code> arm, we're modifying yaw and pitch of the controller according to mouse 
velocity. Nothing fancy, except this line:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>self.controller.pitch = (self.controller.pitch + delta.1 as f32).clamp(-90.0, 90.0);
<span class="boring">}
</span></code></pre></pre>
<p>Here we're just restricting pitch to [-90; 90] degree range to not let flipping camera upside-down. Now let's run the 
game, you should see something like this and be able to walk and turn the camera.</p>
<p><img src="fyrox/tutorials/fps/tutorial-1/./tutorial1-controller.jpg" alt="Controller" /></p>
<h2 id="finishing-touch"><a class="header" href="#finishing-touch">Finishing touch</a></h2>
<p>One more thing before we end the tutorial. Black &quot;void&quot; around us isn't nice, let's add skybox for the camera to improve
that. Skybox is a very simple effect that significantly improves scene quality. To add a skybox, add this code first
somewhere before <code>impl Player</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    engine::{
</span><span class="boring">        resource_manager::{ResourceManager},
</span><span class="boring">    },
</span><span class="boring">    resource::texture::TextureWrapMode,
</span><span class="boring">    scene::{
</span><span class="boring">        camera::{SkyBox, SkyBoxBuilder},
</span><span class="boring">    },
</span><span class="boring">};
</span>async fn create_skybox(resource_manager: ResourceManager) -&gt; SkyBox {
    // Load skybox textures in parallel.
    let (front, back, left, right, top, bottom) = fyrox::core::futures::join!(
        resource_manager.request_texture(&quot;data/textures/skybox/front.jpg&quot;),
        resource_manager.request_texture(&quot;data/textures/skybox/back.jpg&quot;),
        resource_manager.request_texture(&quot;data/textures/skybox/left.jpg&quot;),
        resource_manager.request_texture(&quot;data/textures/skybox/right.jpg&quot;),
        resource_manager.request_texture(&quot;data/textures/skybox/up.jpg&quot;),
        resource_manager.request_texture(&quot;data/textures/skybox/down.jpg&quot;)
    );

    // Unwrap everything.
    let skybox = SkyBoxBuilder {
        front: Some(front.unwrap()),
        back: Some(back.unwrap()),
        left: Some(left.unwrap()),
        right: Some(right.unwrap()),
        top: Some(top.unwrap()),
        bottom: Some(bottom.unwrap()),
    }
        .build()
        .unwrap();

    // Set S and T coordinate wrap mode, ClampToEdge will remove any possible seams on edges
    // of the skybox.
    let skybox_texture = skybox.cubemap().unwrap();
    let mut data = skybox_texture.data_ref();
    data.set_s_wrap_mode(TextureWrapMode::ClampToEdge);
    data.set_t_wrap_mode(TextureWrapMode::ClampToEdge);

    skybox
}
<span class="boring">}
</span></code></pre></pre>
<p>Then modify signature of <code>Player::new</code> to </p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn new(scene: &amp;mut Scene, resource_manager: ResourceManager) -&gt; Self
<span class="boring">}
</span></code></pre></pre>
<p>We just added resource manager parameter here, and made the function async, because we'll load a bunch of textures 
in the <code>create_skybox</code> function. Add following line at camera builder (before <code>.build</code>):</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>.with_skybox(create_skybox(resource_manager).await)
<span class="boring">}
</span></code></pre></pre>
<p>Also modify player creation in <code>Game::new</code> to this</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>player: Player::new(&amp;mut scene, engine.resource_manager.clone()).await,
<span class="boring">}
</span></code></pre></pre>
<p>Next, download skybox textures from <a href="fyrox/tutorials/fps/tutorial-1/./skybox.zip">here</a> and extract the archive in 
<code>data/textures</code> (all textures from  the archive must be in <code>data/textures/skybox</code>). Now you can run the game, and you
should see something like this:</p>
<p><img src="fyrox/tutorials/fps/tutorial-1/./tutorial1-skybox.jpg" alt="Controller" /></p>
<p>This was the last step of this tutorial.</p>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>In this tutorial we've learned how to use the engine and the editor. Created simple character controller and walked on
the scene we've made in the editor. I hope you liked this tutorial, and if so, please consider supporting the project on 
<a href="https://patreon.com/mrdimas">Patreon</a> or <a href="https://liberapay.com/mrDIMAS">LiberaPay</a>. Source code is available on
<a href="https://github.com/FyroxEngine/Fyrox-tutorials">GitHub</a>. In the next tutorial we'll start adding weapons.</p>
<p>Discussion: <a href="https://www.reddit.com/r/rust/comments/lyj1tq/writing_a_3d_shooter_using_rg3d_game_engine_1/">Reddit</a>,
<a href="https://discord.gg/xENF5Uh">Discord</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fps-tutorial-part-2---weapons"><a class="header" href="#fps-tutorial-part-2---weapons">FPS Tutorial Part 2 - Weapons</a></h1>
<p><strong>WARNING: This tutorial is using obsolete engine features, which are subject to be removed in future versions!</strong></p>
<p><strong>Source code</strong>: <a href="https://github.com/FyroxEngine/Fyrox-tutorials/tree/main/tutorial2-character-controller">GitHub</a></p>
<h2 id="table-of-contents-1"><a class="header" href="#table-of-contents-1">Table of contents</a></h2>
<ul>
<li><a href="fyrox/tutorials/fps/tutorial-2/tutorial-part-2.html#introduction">Introduction</a></li>
<li><a href="fyrox/tutorials/fps/tutorial-2/tutorial-part-2.html#adding-weapons">Adding weapons</a></li>
<li><a href="fyrox/tutorials/fps/tutorial-2/tutorial-part-2.html#game-architecture">Game architecture</a></li>
<li><a href="fyrox/tutorials/fps/tutorial-2/tutorial-part-2.html#recoil">Recoil</a></li>
<li><a href="fyrox/tutorials/fps/tutorial-2/tutorial-part-2.html#impact-effects">Impact effects</a></li>
<li><a href="fyrox/tutorials/fps/tutorial-2/tutorial-part-2.html#conclusion">Conclusion</a></li>
</ul>
<h2 id="introduction-1"><a class="header" href="#introduction-1">Introduction</a></h2>
<p>Of course for a shooter game we need weapons and targets to shoot at. In this tutorial we'll add weapons to the game.
For simplicity, we'll add only one weapon, as you'll see later it is pretty easy to add more weapons yourself. This 
is the result we're aiming in the tutorial:</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/GmVAdBdnqeM" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<h2 id="adding-weapons"><a class="header" href="#adding-weapons">Adding weapons</a></h2>
<p>Add a new module <code>weapon.rs</code> near your <code>main.rs</code> and use it somewhere after other imports:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub mod weapon;
...
use weapon::Weapon;
<span class="boring">}
</span></code></pre></pre>
<p>Switch to <code>weapon.rs</code> and paste this code into it:</p>
<pre><pre class="playground"><code class="language-rust no_run edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span>use fyrox::scene::graph::Graph;
use fyrox::{
    core::{algebra::Vector3, math::Vector3Ext, pool::Handle},
    engine::resource_manager::ResourceManager,
    scene::{node::Node, Scene},
};

pub struct Weapon {
    model: Handle&lt;Node&gt;,
    shot_point: Handle&lt;Node&gt;,
    shot_timer: f32,
}

impl Weapon {
    pub async fn new(scene: &amp;mut Scene, resource_manager: ResourceManager) -&gt; Self {
        // Yeah, you need only few lines of code to load a model of any complexity.
        let model = resource_manager
            .request_model(&quot;data/models/m4.fbx&quot;)
            .await
            .unwrap()
            .instantiate_geometry(scene);

        let shot_point = scene.graph.find_by_name(model, &quot;Weapon:ShotPoint&quot;);

        Self {
            model,
            shot_point,
            shot_timer: 0.0,
        }
    }

    pub fn model(&amp;self) -&gt; Handle&lt;Node&gt; {
        self.model
    }

    pub fn shot_point(&amp;self) -&gt; Handle&lt;Node&gt; {
        self.shot_point
    }

    pub fn update(&amp;mut self, dt: f32) {
        self.shot_timer = (self.shot_timer - dt).min(0.0);
    }

    pub fn can_shoot(&amp;self) -&gt; bool {
        self.shot_timer &lt;= 0.0
    }

    pub fn shoot(&amp;mut self) {
        self.shot_timer = 1.0;
    }
}

<span class="boring">}
</span></code></pre></pre>
<p>This piece of code just loads a <a href="fyrox/tutorials/fps/tutorial-2/./m4.zip">weapon model</a> and saves an instance handle for 
further use. Also, each weapon should contain a helper node that tells from where it will &quot;emit&quot; bullets, the node 
was added in a 3D editor and has name <code>Weapon:ShotPoint</code>. Weapon implementation has helper methods that provide read-only
access to inner fields (<code>model</code>, <code>shot_point</code>). <code>update</code> method just decreases the timer's value which is used to change
the pace of shooting. You may ask &quot;why <code>shoot</code> method just modifies timer's value and does not create bullets, etc.?&quot; -
please be patient, I will explain this later in <a href="fyrox/tutorials/fps/tutorial-2/tutorial-part-2.html#game-architecture">game architecture</a> section of the tutorial.
OK, now we need to make a point where every weapon will be &quot;mounted&quot; on, go to <code>Player::new</code> and add these lines in 
the <code>BaseBuilder</code> of the <code>CameraBuilder</code> instance (you also need to import <code>PivotBuilder</code>):</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>.with_children(&amp;[{
    weapon_pivot = PivotBuilder::new(
        BaseBuilder::new().with_local_transform(
            TransformBuilder::new()
                .with_local_position(Vector3::new(
                    -0.1, -0.05, 0.015,
                ))
                .build(),
        ),
    )
    .build(&amp;mut scene.graph);
    weapon_pivot
}]),
<span class="boring">}
</span></code></pre></pre>
<p>What is going on here? We're just adding new child node to the camera and offset it by some vector. Every weapon will
be attached to this pivot. Please keep in mind that the offset given in <strong>local</strong> coordinates, which means that weapon
pivot will move with the camera, but with some offset relative to it. Also, do not forget to add this line after 
<code>let camera;</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let weapon_pivot;
<span class="boring">}
</span></code></pre></pre>
<p>Finally, add the weapon pivot to <code>Self { ... }</code> (and also add <code>weapon_pivot: Handle&lt;Node&gt;</code> to the <code>Player</code> struct):</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Self {
    camera,
    weapon_pivot, // &lt;- here
    rigid_body: rigid_body_handle.into(),
    controller: Default::default(),
}
<span class="boring">}
</span></code></pre></pre>
<p>Next we need a container for weapons, let's add it to the <code>Game</code> struct:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Game {
    scene: Handle&lt;Scene&gt;,
    player: Player,
    weapons: Pool&lt;Weapon&gt; // Weapons will live in a pool
}
<span class="boring">}
</span></code></pre></pre>
<p>Also do not forget to import <code>Pool</code> from <code>fyrox::core::pool</code> in <code>main.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>...
use fyrox::core::pool::{Handle, Pool};
...
<span class="boring">}
</span></code></pre></pre>
<p>Now we need to change <code>Game::new()</code> a bit to add a weapon to the player:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub async fn new(engine: &amp;mut Engine) -&gt; Self {
    let mut scene = Scene::new();

    // Load a scene resource and create its instance.
    engine
        .resource_manager
        .request_model(&quot;data/models/scene.rgs&quot;)
        .await
        .unwrap()
        .instantiate_geometry(&amp;mut scene);

    // Create player first.
    let player = Player::new(&amp;mut scene, engine.resource_manager.clone()).await;

    // Create weapon next.
    let weapon = Weapon::new(&amp;mut scene, engine.resource_manager.clone()).await;

    // &quot;Attach&quot; the weapon to the weapon pivot of the player.
    scene.graph.link_nodes(weapon.model(), player.weapon_pivot);

    // Create a container for the weapons.
    let mut weapons = Pool::new();

    // Put the weapon into it.
    weapons.spawn(weapon);

    Self {
        player,
        scene: engine.scenes.add(scene),
        weapons,
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>At first, we're loading the scene, next we're creating player as usual. Next we're creating a weapon and attach it to 
the weapon pivot we've made earlier. Finally, we're creating a container for the weapons: we'll use Pool to be able 
to borrow weapon later on when we need. So, let's run the game, and you should see something like this:</p>
<p><img src="fyrox/tutorials/fps/tutorial-2/./weapon.jpg" alt="Weapon" /></p>
<p>Alright, now we have a weapon, but it still can't shoot. Let's fix that. </p>
<h3 id="game-architecture"><a class="header" href="#game-architecture">Game architecture</a></h3>
<p>We at the point now where we need to choose correct approach of interaction between parts of the game. We already have
two kinds of entities: player and weapon. In naive approach to shoot a weapon, you'd pass a reference to a weapon in 
<code>Player::update()</code> and would call something like <code>weapon.shoot()</code>. Most likely that at some point you'll end up
in a situation when you need too much of a context in a single method. This is so-called strong coupling, this is
the thing that disappoints borrow checker too much, and it rejects your code because you're trying to borrow same things
multiple times. So we need a way to change strong coupling to loose coupling. To do that we'll use messages to delay 
execution of some actions that require too much of a context. In general, we'll replace direct function call with a 
message that will be put in a common queue and executed later on one by one at the top of call hierarchy (in 
<code>Game::update</code> in our case). Let's begin by adding a MPSC (Multiple Producer Single Consumer) queue to the <code>Game</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Game {
    scene: Handle&lt;Scene&gt;,
    player: Player,
    weapons: Pool&lt;Weapon&gt;,
    receiver: Receiver&lt;Message&gt;, // Single receiver, it cannot be cloned.
    sender: Sender&lt;Message&gt;, // Sender can be cloned and used from various places.
}
<span class="boring">}
</span></code></pre></pre>
<p>Now we need a <code>Message</code> enumeration, add <code>message.rs</code> module, import it in <code>main.rs</code> (<code>pub mod message;</code>) and fill it
with the following code:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::weapon::Weapon;
use fyrox::core::pool::Handle;

pub enum Message {
    ShootWeapon {
        weapons: Handle&lt;Weapon&gt;
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>For now, we have only one message kind - <code>ShootWeapon</code> with a single parameter, a handle of a weapon to shoot. We need
a place to handle messages, <code>Game::update</code> seems to be the most suitable - it is on top of &quot;call hierarchy&quot; and has 
most wide context. Let's change <code>Game::update</code> to this code:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn update(&amp;mut self, engine: &amp;mut Engine, dt: f32) {
    self.player.update(&amp;mut engine.scenes[self.scene]); 

    // v New code v 
    //
    for weapon in self.weapons.iter_mut() {
        weapon.update(dt);
    }

    // We're using `try_recv` here because we don't want to wait until next message -
    // if the queue is empty just continue to next frame.
    while let Ok(message) = self.receiver.try_recv() {
        match message {
            Message::ShootWeapon { weapon } =&gt; {
                self.shoot_weapon(weapon, engine);
            }
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>So, these first three new lines updating every weapon in the game, for now update of a weapon just updates shooting timer.
As you can see we've added new parameter to the function <code>dt: f32</code>, this is the time span from last frame. Do not forget
to pass this parameter in <code>fn main()</code>: <code>game.update(&amp;mut engine, TIMESTEP);</code>. Finally, at the end of the function we're
handling messages from the queue one by one. As you can see we're handling <code>ShootWeapon</code> message, but there is a 
mysterious line <code>self.shoot_weapon(weapon, engine)</code> which is not yet defined, let's fix that, add these lines to 
<code>impl Game</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span> fn shoot_weapon(&amp;mut self, weapon: Handle&lt;Weapon&gt;, engine: &amp;mut Engine) {
    let weapon = &amp;mut self.weapons[weapon];

    if weapon.can_shoot() {
        weapon.shoot();

        let scene = &amp;mut engine.scenes[self.scene];

        let weapon_model = &amp;scene.graph[weapon.model()];

        // Make a ray that starts at the weapon's position in the world and look toward
        // &quot;look&quot; vector of the weapon.
        let ray = Ray::new(
            scene.graph[weapon.shot_point()].global_position(),
            weapon_model.look_vector().scale(1000.0),
        );

        let mut intersections = Vec::new();

        scene.graph.physics.cast_ray(
            RayCastOptions {
                ray_origin: Point3::from(ray.origin),
                max_len: ray.dir.norm(),
                groups: Default::default(),
                sort_results: true, // We need intersections to be sorted from closest to furthest.
                ray_direction: ray.dir,
            },
            &amp;mut intersections,
        );

        // Ignore intersections with player's capsule.
        let trail_length = if let Some(intersection) = intersections
            .iter()
            .find(|i| i.collider != self.player.collider)
        {
            //
            // TODO: Add code to handle intersections with bots.
            //

            // For now just apply some force at the point of impact.
            let colliders_parent = scene.graph[intersection.collider].parent();
            let picked_rigid_body = scene.graph[colliders_parent].as_rigid_body_mut();
            picked_rigid_body.apply_force_at_point(
                ray.dir.normalize().scale(10.0),
                intersection.position.coords,
            );
            picked_rigid_body.wake_up();

            // Trail length will be the length of line between intersection point and ray origin.
            (intersection.position.coords - ray.origin).norm()
        } else {
            // Otherwise trail length will be just the ray length.
            ray.dir.norm()
        };

        create_shot_trail(&amp;mut scene.graph, ray.origin, ray.dir, trail_length);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Wow! Why is there so much code to shoot a weapon!? Actually, this is not all the code - check the last line</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>create_shot_trail(&amp;mut scene.graph, ray.origin, ray.dir, trail_length);
<span class="boring">}
</span></code></pre></pre>
<p>This is yet another function we must add, it is a standalone helper function that creates a shot trail:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::{
</span><span class="boring">        algebra::{UnitQuaternion, Vector3},
</span><span class="boring">        color::Color,
</span><span class="boring">        parking_lot::Mutex,
</span><span class="boring">        sstorage::ImmutableString,
</span><span class="boring">    },
</span><span class="boring">    material::{Material, PropertyValue},
</span><span class="boring">    scene::{
</span><span class="boring">        base::BaseBuilder,
</span><span class="boring">        graph::Graph,
</span><span class="boring">        mesh::{
</span><span class="boring">            surface::{SurfaceBuilder, SurfaceData},
</span><span class="boring">            MeshBuilder, RenderPath,
</span><span class="boring">        },
</span><span class="boring">        transform::TransformBuilder,
</span><span class="boring">    },
</span><span class="boring">};
</span>use std::sync::Arc;
fn create_shot_trail(
    graph: &amp;mut Graph,
    origin: Vector3&lt;f32&gt;,
    direction: Vector3&lt;f32&gt;,
    trail_length: f32,
) {
    let transform = TransformBuilder::new()
        .with_local_position(origin)
        // Scale the trail in XZ plane to make it thin, and apply `trail_length` scale on Y axis
        // to stretch is out.
        .with_local_scale(Vector3::new(0.0025, 0.0025, trail_length))
        // Rotate the trail along given `direction`
        .with_local_rotation(UnitQuaternion::face_towards(&amp;direction, &amp;Vector3::y()))
        .build();

    // Create unit cylinder with caps that faces toward Z axis.
    let shape = Arc::new(Mutex::new(SurfaceData::make_cylinder(
        6,     // Count of sides
        1.0,   // Radius
        1.0,   // Height
        false, // No caps are needed.
        // Rotate vertical cylinder around X axis to make it face towards Z axis
        &amp;UnitQuaternion::from_axis_angle(&amp;Vector3::x_axis(), 90.0f32.to_radians()).to_homogeneous(),
    )));

    // Create an instance of standard material for the shot trail.
    let mut material = Material::standard();
    material
        .set_property(
            &amp;ImmutableString::new(&quot;diffuseColor&quot;),
            // Set yellow-ish color.
            PropertyValue::Color(Color::from_rgba(255, 255, 0, 120)),
        )
        .unwrap();

    MeshBuilder::new(
        BaseBuilder::new()
            // Do not cast shadows.
            .with_cast_shadows(false)
            .with_local_transform(transform)
            // Shot trail should live ~0.25 seconds, after that it will be automatically
            // destroyed.
            .with_lifetime(0.25),
    )
    .with_surfaces(vec![SurfaceBuilder::new(shape)
        .with_material(Arc::new(Mutex::new(material)))
        .build()])
    // Make sure to set Forward render path, otherwise the object won't be
    // transparent.
    .with_render_path(RenderPath::Forward)
    .build(graph);
}
<span class="boring">}
</span></code></pre></pre>
<p>Okay... Let's disassemble this heap of code line by line. At first, we're borrowing the weapon by its handle and 
check if it can shoot (if the timer has reached zero), and &quot;shoot&quot; (reset the timer) if so:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span> let weapon = &amp;mut self.weapons[weapon];

    if weapon.can_shoot() {
        weapon.shoot();
    ...
<span class="boring">}
</span></code></pre></pre>
<p>Next we're using ray casting to find the target we're shooting at:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ...

let scene = &amp;mut engine.scenes[self.scene];

let weapon_model = &amp;scene.graph[weapon.model()];

// Make a ray that starts at the weapon's position in the world and look toward
// &quot;look&quot; vector of the weapon.
let ray = Ray::new(
    scene.graph[weapon.shot_point()].global_position(),
    weapon_model.look_vector().scale(1000.0),
);

let mut intersections = Vec::new();

scene.graph.physics.cast_ray(
    RayCastOptions {
        ray_origin: Point3::from(ray.origin),
        max_len: ray.dir.norm(),
        groups: Default::default(),
        sort_results: true, // We need intersections to be sorted from closest to furthest.
        ray_direction: ray.dir,
    },
    &amp;mut intersections,
);

...
<span class="boring">}
</span></code></pre></pre>
<p>To determine the &quot;target&quot;, we're have to make a ray first. It starts from the &quot;shot point&quot; we've attached to the weapon.
Direction of the ray is the &quot;look&quot; vector of the weapon model scaled by some large value which defines a &quot;length&quot; of the
ray. Finally, we're casting the ray. Next we have to check each intersection and find the target:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Ignore intersections with player's capsule.
let trail_length = if let Some(intersection) = intersections
    .iter()
    .find(|i| i.collider != self.player.collider)
{
    //
    // TODO: Add code to handle intersections with bots.
    //

    // For now just apply some force at the point of impact.
    let colliders_parent = scene.graph[intersection.collider].parent();
    let picked_rigid_body = scene.graph[colliders_parent].as_rigid_body_mut();
    picked_rigid_body.apply_force_at_point(
        ray.dir.normalize().scale(10.0),
        intersection.position.coords,
    );
    picked_rigid_body.wake_up();

    // Trail length will be the length of line between intersection point and ray origin.
    (intersection.position.coords - ray.origin).norm()
} else {
    // Otherwise trail length will be just the ray length.
    ray.dir.norm()
};
<span class="boring">}
</span></code></pre></pre>
<p>First intersection most likely will be player's capsule, because shot point may be inside player's capsule. We're 
filtering such intersection in the first three lines. To do that, we have to remember the handle of player's capsule
in <code>Player</code>: <code>collider: Handle&lt;Node&gt;</code> and fill the field in <code>Player::new</code> like this:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let collider;
...
// Add capsule collider for the rigid body.
{
    collider = ColliderBuilder::new(BaseBuilder::new())
        .with_shape(ColliderShape::capsule_y(0.25, 0.2))
        .build(&amp;mut scene.graph);
    collider
}

...

Self {
    ...
    collider, // &lt;-
    ...
}

<span class="boring">}
</span></code></pre></pre>
<p>Next goes <code>TODO</code> comment, remember this line, it will be replaced when we'll add bots in future tutorial.
Until we have no bots, we should somehow emulate shot impact, to do that we'll just apply some force at the point of
impact. Finally, we're calculating desired shot trail length - it is just distance between point of impact and ray's 
origin. In the <code>else</code> branch we're setting the length to be the length of the ray. Finally, we're creating a shot trail: </p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>create_shot_trail(&amp;mut scene.graph, ray.origin, ray.dir, trail_length);
<span class="boring">}
</span></code></pre></pre>
<p>Now let's dive into this function. It starts from the definition of local transform of the trail:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let transform = TransformBuilder::new()
    .with_local_position(origin)
    // Scale the trail in XZ plane to make it thin, and apply `trail_length` scale on Y axis
    // to stretch is out.
    .with_local_scale(Vector3::new(0.0025, 0.0025, trail_length))
    // Rotate the trail along given `direction`
    .with_local_rotation(UnitQuaternion::face_towards(&amp;direction, &amp;Vector3::y()))
    .build();
<span class="boring">}
</span></code></pre></pre>
<p>Its purpose is to shrink cylinder in XZ plane and stretch it out on Y axis to the length of the trail. Next we're making
geometry for the cylinder:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span> let shape = Arc::new(Mutex::new(SurfaceData::make_cylinder(
    6,     // Count of sides
    1.0,   // Radius
    1.0,   // Height
    false, // No caps are needed.
    // Rotate vertical cylinder around X axis to make it face towards Z axis
    &amp;UnitQuaternion::from_axis_angle(&amp;Vector3::x_axis(), 90.0f32.to_radians()).to_homogeneous(),
)));
<span class="boring">}
</span></code></pre></pre>
<p>Here we're creating unit vertical cylinder, rotate it to make it face towards Z axis. Finally, we're creating mesh node:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Create an instance of standard material for the shot trail.
let mut material = Material::standard();
material
    .set_property(
        &amp;ImmutableString::new(&quot;diffuseColor&quot;),
        // Set yellow-ish color.
        PropertyValue::Color(Color::from_rgba(255, 255, 0, 120)),
    )
    .unwrap();

MeshBuilder::new(
    BaseBuilder::new()
        .with_local_transform(transform)
        // Shot trail should live ~0.25 seconds, after that it will be automatically
        // destroyed.
        .with_lifetime(0.25),
)
.with_surfaces(vec![SurfaceBuilder::new(shape)
    .with_material(Arc::new(Mutex::new(material)))
    .build()])
// Do not cast shadows.
.with_cast_shadows(false)
// Make sure to set Forward render path, otherwise the object won't be
// transparent.
.with_render_path(RenderPath::Forward)
.build(graph);
<span class="boring">}
</span></code></pre></pre>
<p>The trail will live just 0.25 seconds, Fyrox has built-in functionality for short-living objects, you have to just set 
desired lifetime, and an object will be removed at the time. Also, we don't want the trail to cast shadows, and we want 
the trail to be transparent yellow, to do that we have to change render path of the mesh to <code>Forward</code>. In short, every
mesh by default rendered using <code>Deferred</code> renderer which does not support transparent objects due to technical reasons,
but Fyrox has <code>Forward</code> renderer for such objects. Check this <a href="https://www.3dgep.com/forward-plus/">article</a> to learn more 
about Deferred and Forward rendering techniques. Ok, now we have to &quot;teach&quot; player how to shoot. At first, let's add new 
field to <code>InputController</code>: <code>shoot: bool</code>. We'll be changing this flag by left mouse click, to do that let's add these lines
at the end of <code>Event::WindowEvent</code> match arm before <code>_ =&gt; {}</code> in <code>Player::process_input_event</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>&amp;WindowEvent::MouseInput { button, state, .. } =&gt; {
    if button == MouseButton::Left {
        self.controller.shoot = state == ElementState::Pressed;
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Now we need a way to send messages to the game from the player. We need a new field in <code>Player</code> struct 
<code>sender: Sender&lt;Message&gt;</code>. Also, we must change signature of <code>Player::new()</code> to this:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn new(
    scene: &amp;mut Scene,
    resource_manager: ResourceManager,
    sender: Sender&lt;Message&gt;,
) -&gt; Self 
<span class="boring">}
</span></code></pre></pre>
<p>Just pass the <code>sender</code> in the <code>Self { .. }</code> like this: </p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Self {
    ...
    sender, // &lt;- Pass sender 
    ...
}
<span class="boring">}
</span></code></pre></pre>
<p>Player must know about its weapons, let's fix this by adding new field to the <code>Player</code>: <code>weapon: Handle&lt;Weapon&gt;</code>, we'll
fill this field in the <code>Game::new()</code>, not in <code>Player::new()</code> because at the moment of creation of the player there are
no weapons:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>...

// Put the weapon into it - this operation moves the weapon in the pool and returns handle.
let weapon = weapons.spawn(weapon);

// &quot;Give&quot; the weapon to the player.
player.weapon = weapon;

...
<span class="boring">}
</span></code></pre></pre>
<p>Finally, at the end of <code>Player::update</code> we will handle the state of the input controller:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if self.controller.shoot {
    self.sender
        .send(Message::ShootWeapon {
            weapon: self.weapon,
        })
        .unwrap();
}
<span class="boring">}
</span></code></pre></pre>
<p>Ok, at this momemt you should be able to compile the game and as you run it, you should see something like this when
you'll press left mouse button:</p>
<p><img src="fyrox/tutorials/fps/tutorial-2/./shooting.jpg" alt="Weapon" /></p>
<p>Barrels should react to shots as in the video at the beginning of the tutorial. </p>
<h2 id="recoil"><a class="header" href="#recoil">Recoil</a></h2>
<p>Ok, the weapon shoots but looks kinda unnatural, to fix that we need to add a recoil. This is very simple to do, let's 
start by adding these fields in the <code>Weapon</code> struct:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>recoil_offset: Vector3&lt;f32&gt;,
recoil_target_offset: Vector3&lt;f32&gt;,
<span class="boring">}
</span></code></pre></pre>
<p>Initialize these fields with default values (zero vector):</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>recoil_offset: Default::default(),
recoil_target_offset: Default::default(),
<span class="boring">}
</span></code></pre></pre>
<p>First vector is the actual recoil offset that will be applied to the weapon model, second - target recoil value which
first vector will follow. Why do we need two vectors instead just one? The answer is very simple, we need to smoothly
change offset over time, and to do that offset will just &quot;follow&quot; target offset which will give us desired smooth 
movement. Let's add the code responsible for the recoil to the <code>Weapon::update</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Notice new `graph` parameter
pub fn update(&amp;mut self, dt: f32, graph: &amp;mut Graph) {  
    self.shot_timer = (self.shot_timer - dt).max(0.0);
    
    // v New code v
        
    // `follow` method defined in Vector3Ext trait and it just increases or
    // decreases vector's value in order to &quot;follow&quot; the target value with 
    // given speed.
    self.recoil_offset.follow(&amp;self.recoil_target_offset, 0.5);

    // Apply offset to weapon's model.
    graph[self.model]
        .local_transform_mut()
        .set_position(self.recoil_offset);

    // Check if we've reached target recoil offset.
    if self
        .recoil_offset
        .metric_distance(&amp;self.recoil_target_offset)
        &lt; 0.001
    {
        // And if so, reset offset to zero to return weapon at
        // its default position.
        self.recoil_target_offset = Default::default();
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>At first, in the first line we force the <code>recoil_offset</code> to follow <code>recoil_target_offset</code> with given speed. Next we're 
applying offset to weapon's model. Finally, we're checking if we've reached target offset and if so, just reset target
offset to return a weapon to its default position. Also we have to slightly modify <code>Weapon::shoot</code> to modify target
offset:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn shoot(&amp;mut self) {
    self.shot_timer = 0.1;

    // Set new offset after each shot.
    self.recoil_target_offset = Vector3::new(0.0, 0.0, -0.025); 
}
<span class="boring">}
</span></code></pre></pre>
<p>The last thing we need to do is to slightly modify code at the <code>Game::update</code> to pass new parameter to <code>Weapon::update</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span> pub fn update(&amp;mut self, engine: &amp;mut GameEngine, dt: f32) {
    let scene = &amp;mut engine.scenes[self.scene];

    self.player.update(scene);

    for weapon in self.weapons.iter_mut() {
        weapon.update(dt, &amp;mut scene.graph);
    }
        
    ...
<span class="boring">}
</span></code></pre></pre>
<p>Ok, run the game, and the weapon should feel more natural now. </p>
<h2 id="impact-effects"><a class="header" href="#impact-effects">Impact effects</a></h2>
<p>Shooting have become much better after we've added a recoil, but there is still no impact effects like sparks. Let's fix
that! This is the first time when we'll use particle systems. Let's add this function somewhere in <code>main.rs</code></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::{
</span><span class="boring">        algebra::{UnitQuaternion, Vector3},
</span><span class="boring">        color::Color,
</span><span class="boring">        color_gradient::{ColorGradient, GradientPoint},
</span><span class="boring">        pool::Handle,
</span><span class="boring">    },
</span><span class="boring">    engine::resource_manager::ResourceManager,
</span><span class="boring">    scene::{
</span><span class="boring">        base::BaseBuilder,
</span><span class="boring">        graph::Graph,
</span><span class="boring">        node::Node,
</span><span class="boring">        particle_system::{
</span><span class="boring">            emitter::{base::BaseEmitterBuilder, sphere::SphereEmitterBuilder},
</span><span class="boring">            ParticleSystemBuilder,
</span><span class="boring">        },
</span><span class="boring">        transform::TransformBuilder,
</span><span class="boring">    },
</span><span class="boring">};
</span><span class="boring">use std::path::Path;
</span>fn create_bullet_impact(
    graph: &amp;mut Graph,
    resource_manager: ResourceManager,
    pos: Vector3&lt;f32&gt;,
    orientation: UnitQuaternion&lt;f32&gt;,
) -&gt; Handle&lt;Node&gt; {
    // Create sphere emitter first.
    let emitter = SphereEmitterBuilder::new(
        BaseEmitterBuilder::new()
            .with_max_particles(200)
            .with_spawn_rate(3000)
            .with_size_modifier_range(-0.01..-0.0125)
            .with_size_range(0.0075..0.015)
            .with_lifetime_range(0.05..0.2)
            .with_x_velocity_range(-0.0075..0.0075)
            .with_y_velocity_range(-0.0075..0.0075)
            .with_z_velocity_range(0.025..0.045)
            .resurrect_particles(false),
    )
    .with_radius(0.01)
    .build();

    // Color gradient will be used to modify color of each particle over its lifetime.
    let color_gradient = {
        let mut gradient = ColorGradient::new();
        gradient.add_point(GradientPoint::new(0.00, Color::from_rgba(255, 255, 0, 0)));
        gradient.add_point(GradientPoint::new(0.05, Color::from_rgba(255, 160, 0, 255)));
        gradient.add_point(GradientPoint::new(0.95, Color::from_rgba(255, 120, 0, 255)));
        gradient.add_point(GradientPoint::new(1.00, Color::from_rgba(255, 60, 0, 0)));
        gradient
    };

    // Create new transform to orient and position particle system.
    let transform = TransformBuilder::new()
        .with_local_position(pos)
        .with_local_rotation(orientation)
        .build();

    // Finally create particle system with limited lifetime.
    ParticleSystemBuilder::new(
        BaseBuilder::new()
            .with_lifetime(1.0)
            .with_local_transform(transform),
    )
    .with_acceleration(Vector3::new(0.0, 0.0, 0.0))
    .with_color_over_lifetime_gradient(color_gradient)
    .with_emitters(vec![emitter])
    // We'll use simple spark texture for each particle.
    .with_texture(resource_manager.request_texture(Path::new(&quot;data/textures/spark.png&quot;)))
    .build(graph)
}
<span class="boring">}
</span></code></pre></pre>
<p>Ok, again a heap of code... As usual, everything here is pretty straightforward. At first, we're creating spherical
emitter - it is a spherical volume that responsible for spawning particles. It has a radius, and a bunch of basic properties
such as spawn rate, maximum amount of particles, initial velocity range, etc. Next we're creating color gradient to make
particles fade over their lifetime. Next, we're creating simple transform that will orient and position particle system 
in world space. Finally, we're creating particle system itself, using pre-made parts. For each particle we'll use simple
<a href="fyrox/tutorials/fps/tutorial-2/./spark.png">spark texture</a>, it should be placed in <code>data/textures</code>. Now we need to find
correct place to create this particle system. It should be placed right after we're applying force to target we've hit 
in <code>Game::shoot_weapon</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Add bullet impact effect.
let effect_orientation = vector_to_quat(intersection.normal);

create_bullet_impact(
    &amp;mut scene.graph,
    engine.resource_manager.clone(),
    intersection.position.coords,
    effect_orientation,
);
<span class="boring">}
</span></code></pre></pre>
<p>Ok, now run the game, and you should see something like this:</p>
<p><img src="fyrox/tutorials/fps/tutorial-2/./impact.jpg" alt="Weapon" /></p>
<p>One more thing that could be added is bullet shells that should come from a weapon when we're shooting, but I think the
tutorial is already pretty big already, and I'll leave this as a &quot;homework&quot;, but I'll just give some hints of how to do 
this. Make or download a shell model in FBX format, then write a function that will load it via resource manager, 
instantiate it and create a physical body for it (with cylinder collider for example), link a model with a body and call 
this function when shooting a weapon.</p>
<h2 id="conclusion-1"><a class="header" href="#conclusion-1">Conclusion</a></h2>
<p>In this tutorial we added weapon to the game, added recoil to make shooting more natural, and added impact effects. I 
hope you liked this tutorial, and if so, please consider supporting the project on
<a href="https://patreon.com/mrdimas">Patreon</a> or <a href="https://liberapay.com/mrDIMAS">LiberaPay</a>. Source code is available on
<a href="https://github.com/FyroxEngine/Fyrox-tutorials">GitHub</a>. In the next tutorial we'll add sounds to the game and something
special (let it be a surprise).</p>
<p>Discussion: <a href="https://www.reddit.com/r/rust/comments/m2055c/writing_a_3d_shooter_using_rg3d_2_adding_shooting/">Reddit</a>,
<a href="https://discord.gg/xENF5Uh">Discord</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fps-tutorial-part-1---bots-and-ai"><a class="header" href="#fps-tutorial-part-1---bots-and-ai">FPS Tutorial Part 1 - Bots and AI</a></h1>
<p><strong>WARNING: This tutorial is using obsolete engine features, which are subject to be removed in future versions!</strong></p>
<p><strong>Source code</strong>: <a href="https://github.com/FyroxEngine/Fyrox-tutorials/tree/main/tutorial3-character-controller">GitHub</a></p>
<h2 id="table-of-contents-2"><a class="header" href="#table-of-contents-2">Table of contents</a></h2>
<ul>
<li><a href="fyrox/tutorials/fps/tutorial-3/tutorial-part-3.html#introduction">Introduction</a></li>
<li><a href="fyrox/tutorials/fps/tutorial-3/tutorial-part-3.html#bots">Bots</a></li>
<li><a href="fyrox/tutorials/fps/tutorial-3/tutorial-part-3.html#animations">Animations</a></li>
<li><a href="fyrox/tutorials/fps/tutorial-3/tutorial-part-3.html#simple-ai">Simple AI</a></li>
<li><a href="fyrox/tutorials/fps/tutorial-3/tutorial-part-3.html#conclusion">Conclusion</a></li>
</ul>
<h2 id="introduction-2"><a class="header" href="#introduction-2">Introduction</a></h2>
<p>In the previous tutorial we've added weapons, but we still have no bots to shoot at. Let's fix that! In this tutorial
we'll add bots and a very simple AI. Bots will be a bit dumb, but it will be fixed in future tutorials. This is the
result we're aiming in the tutorial:</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/dtudhbRBIq0" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<h2 id="bots"><a class="header" href="#bots">Bots</a></h2>
<p>Previous tutorials were children's play in comparison to this, prepare for some advanced stuff. Let's begin by adding
a separate module for bots - add <code>bot.rs</code> and fill it with following code:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use fyrox::engine::resource_manager::MaterialSearchOptions;
use fyrox::{
    animation::{
        machine::{Machine, Parameter, PoseNode, State, Transition},
        Animation,
    },
    core::{
        algebra::{UnitQuaternion, Vector3},
        pool::Handle,
    },
    engine::resource_manager::ResourceManager,
    physics3d::{
        rapier::dynamics::RigidBodyBuilder, rapier::geometry::ColliderBuilder, ColliderHandle,
        RigidBodyHandle,
    },
    resource::model::Model,
    scene::{base::BaseBuilder, node::Node, Scene},
};

pub struct Bot {
    rigid_body: Handle&lt;Node&gt;,
    collider: Handle&lt;Node&gt;,
}

impl Bot {
    pub async fn new(
        scene: &amp;mut Scene,
        position: Vector3&lt;f32&gt;,
        resource_manager: ResourceManager,
    ) -&gt; Self {
        // Load bot 3D model as usual.
        let model = resource_manager
            .request_model(&quot;data/models/zombie.fbx&quot;)
            .await
            .unwrap()
            .instantiate_geometry(scene);

        scene.graph[model]
            .local_transform_mut()
            // Move the model a bit down to make sure bot's feet will be on ground.
            .set_position(Vector3::new(0.0, -0.45, 0.0))
            // Scale the model because it is too big.
            .set_scale(Vector3::new(0.0047, 0.0047, 0.0047));

        let collider;
        let rigid_body = RigidBodyBuilder::new(
            BaseBuilder::new()
                .with_local_transform(
                    TransformBuilder::new()
                        .with_local_position(Vector3::new(position.x, position.y, position.z))
                        .build(),
                )
                .with_children(&amp;[
                    // Attach model to the rigid body.
                    model,
                    // Add capsule collider for the rigid body.
                    {
                        collider = ColliderBuilder::new(BaseBuilder::new())
                            .with_shape(ColliderShape::capsule_y(0.25, 0.2))
                            .build(&amp;mut scene.graph);
                        collider
                    },
                ]),
        )
        // We don't want a bot to tilt.
        .with_locked_rotations(true)
        .with_can_sleep(false)
        .build(&amp;mut scene.graph);

        Self {
            rigid_body,
            collider,
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Ok, before we dive into the code, we need to add some more code in <code>main.rs</code>, let's begin by adding a container for
bots in <code>Game</code>: <code>bots: Pool&lt;Bot&gt;,</code>. Next we need to add some more code to <code>Game::new</code> where we'll add a bot instance in
the game. Also, you can add more than one bot at different positions if you want. Do not forget to download bot model
with textures from <a href="fyrox/tutorials/fps/tutorial-3/./zombie.zip">here</a> and unpack <code>fbx</code> file in <code>data/models</code> and other files
(textures), in <code>data/textures</code>.</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Add some bots.
let mut bots = Pool::new();

bots.spawn(
    Bot::new(
        &amp;mut scene,
        Vector3::new(-1.0, 1.0, -1.0),
        engine.resource_manager.clone(),
    )
    .await,
);

...

Self {
    ...
    bots
}
<span class="boring">}
</span></code></pre></pre>
<p>As usual, let's disassemble the code line-by-line. Creation of bot begins from loading its 3D model in the scene:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let model = resource_manager
    .request_model(&quot;data/models/zombie.fbx&quot;)
    .await
    .unwrap()
    .instantiate_geometry(scene);
<span class="boring">}
</span></code></pre></pre>
<p>Nothing really new here, loading and instantiation of a 3D model of <em>any</em> complexity is the same as before. Next we have
to slightly modify the model, shift it a bit down and shrink:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>scene.graph[model]
    .local_transform_mut()
    // Move the model a bit down to make sure bot's feet will be on ground.
    .set_position(Vector3::new(0.0, -0.45, 0.0))
    // Scale the model because it is too big.
    .set_scale(Vector3::new(0.0047, 0.0047, 0.0047));
<span class="boring">}
</span></code></pre></pre>
<p>Here we're borrow model in the scene graph, and modify its local transform. Next we're creating rigid body with a capsule
collider, and attaching the model to the rigid body:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let collider;
let rigid_body = RigidBodyBuilder::new(
    BaseBuilder::new()
        .with_local_transform(
            TransformBuilder::new()
                .with_local_position(Vector3::new(position.x, position.y, position.z))
                .build(),
        )
        .with_children(&amp;[
            // Attach model to the rigid body.
            model,
            // Add capsule collider for the rigid body.
            {
                collider = ColliderBuilder::new(BaseBuilder::new())
                    .with_shape(ColliderShape::capsule_y(0.25, 0.2))
                    .build(&amp;mut scene.graph);
                collider
            },
        ]),
)
// We don't want a bot to tilt.
.with_locked_rotations(true)
.with_can_sleep(false)
.build(&amp;mut scene.graph);
<span class="boring">}
</span></code></pre></pre>
<p>Finally, we're returning bot's instance:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Self {
    pivot,
    rigid_body,
    collider,
}
<span class="boring">}
</span></code></pre></pre>
<p>Ok, now for the bots instantiation, for simplicity we create a single bot in <code>Game::new</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut bots = Pool::new();

bots.spawn(
    Bot::new(
        &amp;mut scene,
        Vector3::new(-1.0, 1.0, 1.5),
        engine.resource_manager.clone(),
    )
    .await,
);
<span class="boring">}
</span></code></pre></pre>
<p>As you can see, we'll store bots in a pool as many other game entities, this will allow us to borrow bots later on when 
we'll be adding AI. Ok, now run the game, and you should see something like this:</p>
<p><img src="fyrox/tutorials/fps/tutorial-3/./bot.jpg" alt="Weapon" /></p>
<p>Wow... a T-posing bot... Is this some kind of Cyberpunk 2077 reference? This is boring, let's add some animations to 
make it more &quot;alive&quot;.</p>
<h3 id="animations"><a class="header" href="#animations">Animations</a></h3>
<p>Let's start from definition of animation. Animation is a set of tracks, where each track responsible for animation
of a single node and contains key frames placed on a timeline with some transition rules between key frames. Animation
usually changes just position/rotation/scale of a node. When animation is playing it calculates intermediate values for
each parameter using interpolation techniques (linear and spherical interpolation). Animations in general is very simple
and powerful technique, but at many times it still does not enough. If you will just switch multiple animations from one
to one, it will look very bad and unnatural. This is where animation blending machines come into play.</p>
<p><img src="fyrox/tutorials/fps/tutorial-3/./animation.png" alt="Weapon" /></p>
<p>Fyrox provides very powerful mechanism for animations - animation blending machines. If you're already familiar with 
Mecanim in Unity game engine or similar thing in Unreal Engine, then you'll probably already understood what will be
in this paragraph. Animation blending machine (ABM) is a state machine that allows you to blend multiple animations
in one and apply it to a set of bones (or nodes in general). ABM is a graph where each node is a state, each state
has a source of animation pose which in its turn may be another subgraph of pose emitting nodes. States connected 
between each other using transition edges which have some parameters like transition time, a rule for transition, etc.
At each moment of time either state or transition can be active. In other words this means that ABM is either
transitioning from a state to state or hold a state. This leads to another fact - ABM cannot jump from a state to state
if they're not connected with transition edge. ABMs in general can be represented like this:</p>
<p><img src="fyrox/tutorials/fps/tutorial-3/./machine.png" alt="Weapon" /></p>
<p>States are marked yellow, animation nodes - blue, animations - green. As you can see there can be multiple transitions
between states, each transition has corresponding <code>Rule</code> parameter which is a simple boolean value which tells a machine
when it is possible to start transition. Each state is supplied with animation node (<code>PlayAnimation</code>, <code>BlendAnimations</code>,
<code>BlendAnimationsByIndex</code>, etc.) which does exactly what the name states. <code>PlayAnimation</code> just plays given animation, 
<code>BlendAnimations</code> - blends multiple animations with different weights into one, BlendAnimationsByIndex - blends multiple
animations as the BlendAnimations, but each animation has transition time, and the node uses an index parameter to switch
between attached animations. Please keep in mind that <code>BlendAnimations</code> node can have various sources of pose, as you can 
see in the picture, it uses two <code>PlayAnimation</code> nodes as source of poses, but nothing keeps you from adding new pose source
which will be yet another <code>BlendAnimations</code>. So everything depends on your needs and ABM just gives you enough flexibility.</p>
<p>Ok, back to the game. Let's create a simple ABM for bots. For simplicity, it will contain only three states - Idle, Walk,
Attack. Put this code somewhere at the end of <code>bot.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Simple helper method to create a state supplied with PlayAnimation node.
fn create_play_animation_state(
    animation_resource: Model,
    name: &amp;str,
    machine: &amp;mut Machine,
    scene: &amp;mut Scene,
    model: Handle&lt;Node&gt;,
) -&gt; (Handle&lt;Animation&gt;, Handle&lt;State&gt;) {
    // Animations retargetting just makes an instance of animation and binds it to
    // given model using names of bones.
    let animation = *animation_resource
        .retarget_animations(model, scene)
        .get(0)
        .unwrap();
    // Create new PlayAnimation node and add it to machine.
    let node = machine.add_node(PoseNode::make_play_animation(animation));
    // Make a state using the node we've made.
    let state = machine.add_state(State::new(name, node));
    (animation, state)
}

pub struct BotAnimationMachineInput {
    // Whether a bot is walking or not.
    pub walk: bool,
    // Whether a bot is attacking or not.
    pub attack: bool,
}

pub struct BotAnimationMachine {
    machine: Machine,
}

impl BotAnimationMachine {
    // Names of parameters that will be used for transition rules in machine.
    const IDLE_TO_WALK: &amp;'static str = &quot;IdleToWalk&quot;;
    const WALK_TO_IDLE: &amp;'static str = &quot;WalkToIdle&quot;;
    const WALK_TO_ATTACK: &amp;'static str = &quot;WalkToAttack&quot;;
    const IDLE_TO_ATTACK: &amp;'static str = &quot;IdleToAttack&quot;;
    const ATTACK_TO_IDLE: &amp;'static str = &quot;AttackToIdle&quot;;
    const ATTACK_TO_WALK: &amp;'static str = &quot;AttackToWalk&quot;;

    pub async fn new(
        scene: &amp;mut Scene,
        model: Handle&lt;Node&gt;,
        resource_manager: ResourceManager,
    ) -&gt; Self {
        let mut machine = Machine::new(model);

        // Load animations in parallel.
        let (walk_animation_resource, idle_animation_resource, attack_animation_resource) = fyrox::core::futures::join!(
            resource_manager.request_model(&quot;data/animations/zombie_walk.fbx&quot;),
            resource_manager.request_model(&quot;data/animations/zombie_idle.fbx&quot;),
            resource_manager.request_model(&quot;data/animations/zombie_attack.fbx&quot;),
        );

        // Now create three states with different animations.
        let (_, idle_state) = create_play_animation_state(
            idle_animation_resource.unwrap(),
            &quot;Idle&quot;,
            &amp;mut machine,
            scene,
            model,
        );

        let (walk_animation, walk_state) = create_play_animation_state(
            walk_animation_resource.unwrap(),
            &quot;Walk&quot;,
            &amp;mut machine,
            scene,
            model,
        );

        let (attack_animation, attack_state) = create_play_animation_state(
            attack_animation_resource.unwrap(),
            &quot;Attack&quot;,
            &amp;mut machine,
            scene,
            model,
        );

        // Next, define transitions between states.
        machine.add_transition(Transition::new(
            // A name for debugging.
            &quot;Idle-&gt;Walk&quot;,
            // Source state.
            idle_state,
            // Target state.
            walk_state,
            // Transition time in seconds.
            0.4,
            // A name of transition rule parameter.
            Self::IDLE_TO_WALK,
        ));
        machine.add_transition(Transition::new(
            &quot;Walk-&gt;Idle&quot;,
            walk_state,
            idle_state,
            0.4,
            Self::WALK_TO_IDLE,
        ));
        machine.add_transition(Transition::new(
            &quot;Walk-&gt;Attack&quot;,
            walk_state,
            attack_state,
            0.4,
            Self::WALK_TO_ATTACK,
        ));
        machine.add_transition(Transition::new(
            &quot;Idle-&gt;Attack&quot;,
            idle_state,
            attack_state,
            0.4,
            Self::IDLE_TO_ATTACK,
        ));
        machine.add_transition(Transition::new(
            &quot;Attack-&gt;Idle&quot;,
            attack_state,
            idle_state,
            0.4,
            Self::ATTACK_TO_IDLE,
        ));
        machine.add_transition(Transition::new(
            &quot;Attack-&gt;Walk&quot;,
            attack_state,
            walk_state,
            0.4,
            Self::ATTACK_TO_WALK,
        ));

        // Define entry state.
        machine.set_entry_state(idle_state);

        Self { machine }
    }

    pub fn update(&amp;mut self, scene: &amp;mut Scene, dt: f32, input: BotAnimationMachineInput) {
        self.machine
            // Set transition parameters.
            .set_parameter(Self::WALK_TO_IDLE, Parameter::Rule(!input.walk))
            .set_parameter(Self::IDLE_TO_WALK, Parameter::Rule(input.walk))
            .set_parameter(Self::WALK_TO_ATTACK, Parameter::Rule(input.attack))
            .set_parameter(Self::IDLE_TO_ATTACK, Parameter::Rule(input.attack))
            .set_parameter(Self::ATTACK_TO_IDLE, Parameter::Rule(!input.attack))
            .set_parameter(Self::ATTACK_TO_WALK, Parameter::Rule(!input.attack))
            // Update machine and evaluate final pose.
            .evaluate_pose(&amp;scene.animations, dt)
            // Apply the pose to the graph.
            .apply(&amp;mut scene.graph);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Ok, this might be the biggest heap of code we've ever been dealing with at once. There is lots of stuff happening, 
let's thoroughly &quot;scan&quot; this code. It starts from the simple helper method to create states:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Simple helper method to create a state supplied with PlayAnimation node.
fn create_play_animation_state(
    animation_resource: Model,
    name: &amp;str,
    machine: &amp;mut Machine,
    scene: &amp;mut Scene,
    model: Handle&lt;Node&gt;,
) -&gt; (Handle&lt;Animation&gt;, Handle&lt;State&gt;) {
    // Animations retargetting just makes an instance of animation and binds it to
    // given model using names of bones.
    let animation = *animation_resource
        .retarget_animations(model, scene)
        .get(0)
        .unwrap();
    // Create new PlayAnimation node and add it to machine.
    let node = machine.add_node(PoseNode::make_play_animation(animation));
    // Make a state using the node we've made.
    let state = machine.add_state(State::new(name, node));
    (animation, state)
}
<span class="boring">}
</span></code></pre></pre>
<p>Here we're using new method of Model resource - <a href="https://github.com/FyroxEngine/Fyrox/blob/master/src/resource/model.rs#L110">retarget_animations</a>,
in short, it creates an instance of animation, and binds animations tracks to nodes in given sub graph that starts from
a node given as first parameter. Next we're adding a PlayAnimation node to machine and making a new state node. Now we're
adding a structure with input parameter for ABM:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct BotAnimationMachineInput {
    // Whether a bot is walking or not.
    pub walk: bool,
    // Whether a bot is attacking or not.
    pub attack: bool,
}
<span class="boring">}
</span></code></pre></pre>
<p>This structure will contain more flags in the future, but now on to <code>BotAnimationMachine::new()</code>. At first, we're creating
new ABM instance, nothing fancy here. Next we're loading animations in parallel: </p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut machine = Machine::new();

// Load animations in parallel.
let (walk_animation_resource, idle_animation_resource, attack_animation_resource) = fyrox::core::futures::join!(
    resource_manager.request_model(&quot;data/animations/zombie_walk.fbx&quot;),
    resource_manager.request_model(&quot;data/animations/zombie_idle.fbx&quot;),
    resource_manager.request_model(&quot;data/animations/zombie_attack.fbx&quot;),
);
<span class="boring">}
</span></code></pre></pre>
<p>As you may have noticed, there is no difference between animation resource and model resource, this is because any 3D
model can have animations. The animations we're loading, contain only bones and key frames for them, but not mesh of a bot.
We simply don't need a mesh, because we've already created the mesh earlier. This separation of animations and mesh is 
very handy, because it saves CPU cycles and disk space. Ok, next we're creating states for ABM:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Now create three states with different animations.
let (_, idle_state) = create_play_animation_state(
    idle_animation_resource.unwrap(),
    &quot;Idle&quot;,
    &amp;mut machine,
    scene,
    model,
);

let (walk_animation, walk_state) = create_play_animation_state(
    walk_animation_resource.unwrap(),
    &quot;Walk&quot;,
    &amp;mut machine,
    scene,
    model,
);

let (attack_animation, attack_state) = create_play_animation_state(
    attack_animation_resource.unwrap(),
    &quot;Attack&quot;,
    &amp;mut machine,
    scene,
    model,
);
<span class="boring">}
</span></code></pre></pre>
<p>These states are those yellow-ish rectangles on diagram up above. As you can see we're creating three states: idle, walk,
attack. Next we need to connect states between each other. </p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Next, define transitions between states.
machine.add_transition(Transition::new(
    // A name for debugging.
    &quot;Idle-&gt;Walk&quot;,
    // Source state.
    idle_state,
    // Target state.
    walk_state,
    // Transition time in seconds.
    0.4,
    // A name of transition rule parameter.
    Self::IDLE_TO_WALK,
));

... // Rest are intentionally omitted 
<span class="boring">}
</span></code></pre></pre>
<p>Ok, comments should clarify what is going on here, but one thing I want to mention specifically. As you may have noticed,
transition is that black arrow on the diagram up above, and it is linked with a parameter. Parameter have a name, and as
you'll see later the name will be used to modify parameters. Finally, we're setting entry state to idle and return 
ABM instance:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Define entry state.
machine.set_entry_state(idle_state);

Self { machine }
<span class="boring">}
</span></code></pre></pre>
<p>Now for another important part, we have to &quot;feed&quot; machine with actual parameters for each transition:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn update(&amp;mut self, scene: &amp;mut Scene, dt: f32, input: BotAnimationMachineInput) {
    self.machine
        // Set transition parameters.
        .set_parameter(Self::WALK_TO_IDLE, Parameter::Rule(!input.walk))
        .set_parameter(Self::IDLE_TO_WALK, Parameter::Rule(input.walk))
        .set_parameter(Self::WALK_TO_ATTACK, Parameter::Rule(input.attack))
        .set_parameter(Self::IDLE_TO_ATTACK, Parameter::Rule(input.attack))
        .set_parameter(Self::ATTACK_TO_IDLE, Parameter::Rule(!input.attack))
        .set_parameter(Self::ATTACK_TO_WALK, Parameter::Rule(!input.attack))
        // Update machine and evaluate final pose.
        .evaluate_pose(&amp;scene.animations, dt)
        // Apply the pose to the graph.
        .apply(&amp;mut scene.graph);
}
<span class="boring">}
</span></code></pre></pre>
<p>Here we're setting each transition rule one by one, then forcing machine to evaluate animation pose and apply it to 
the graph. You may ask how machine knows which nodes (bones) should be affected? Remember what was the definition of 
animation and its tracks? Right, each track knows about the node it affects, animation blending machine just combines
multiple sources of poses into one and animation for same node blends into a final pose and final pose contains animation
for each node that was used in all tracks used in ABM. </p>
<p>Next we need to use the machine we've made. Add a new field to <code>Bot</code>: <code>machine: BotAnimationMachine</code> and initialize it in
&quot;constructor&quot;:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Self {
    machine: BotAnimationMachine::new(scene, model, resource_manager).await,
    ...
}
<span class="boring">}
</span></code></pre></pre>
<p>Next we need to update machine, add following method to <code>impl Bot</code>: </p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn update(&amp;mut self, scene: &amp;mut Scene, dt: f32) {
    // For now these are set to false which will force bot to be in idle state.
    let input = BotAnimationMachineInput {
        walk: false,
        attack: false,
    };

    self.machine.update(scene, dt, input);
}
<span class="boring">}
</span></code></pre></pre>
<p>This method will update machine and &quot;feed&quot; it with actual state, for now the state has flags combination that forces
bot to be in idle state. This will be fixed when we'll add simple AI later in this tutorial. Finally, we need to update
each bot we have, go to <code>Game::update</code> and add following lines there (somewhere after update of weapons):</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for bot in self.bots.iter_mut() {
    bot.update(scene, dt);
}
<span class="boring">}
</span></code></pre></pre>
<p>Now run the game, and you should see that bots now is in idle state and animation is playing, it should look like this:</p>
<p><img src="fyrox/tutorials/fps/tutorial-3/./animation.jpg" alt="Weapon" /></p>
<h2 id="simple-ai"><a class="header" href="#simple-ai">Simple AI</a></h2>
<p>Ok, now we have to use ABM we've made at full capacity, to do that we'll write simple AI - bot will just follow player
in a straight line and attack if they're close enough. Let's start by modifying <code>Bot::update</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn update(&amp;mut self, scene: &amp;mut Scene, dt: f32, target: Vector3&lt;f32&gt;) {
    let attack_distance = 0.6;

    // Simple AI - follow target by a straight line.
    let self_position = scene.graph[self.rigid_body].global_position();
    let direction = target - self_position;

    // Distance to target.
    let distance = direction.norm();

    if distance != 0.0 &amp;&amp; distance &lt; 1.5 {
        self.follow_target = true;
    }

    if self.follow_target &amp;&amp; distance != 0.0 {
        let rigid_body = scene.graph[self.rigid_body].as_rigid_body_mut();

        // Make sure bot is facing towards the target.
        rigid_body
            .local_transform_mut()
            .set_rotation(UnitQuaternion::face_towards(
                &amp;Vector3::new(direction.x, 0.0, direction.z),
                &amp;Vector3::y_axis(),
            ));

        // Move only if we're far enough from the target.
        if distance &gt; attack_distance {
            // Normalize direction vector and scale it by movement speed.
            let xz_velocity = direction.scale(1.0 / distance).scale(0.9);

            let new_velocity =
                Vector3::new(xz_velocity.x, rigid_body.lin_vel().y, xz_velocity.z);

            rigid_body.set_lin_vel(new_velocity);
        }
    }

    // For now these are set to false which will force bot to be in idle state.
    let input = BotAnimationMachineInput {
        walk: self.follow_target &amp;&amp; distance &gt; attack_distance,
        attack: distance &lt; attack_distance,
    };

    self.machine.update(scene, dt, input);
}
<span class="boring">}
</span></code></pre></pre>
<p>Also add a new field to <code>Player</code>: <code>follow_target: bool</code> and initialize it in the constructor: </p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Self {
    follow_target: false,
    ...
}
<span class="boring">}
</span></code></pre></pre>
<p>So, the AI algorithm is very simple - stand still until a target (player) come closer, once it's close enough, switch
<code>follow_target</code> flag to true and begin to follow the target. To do that, all we have to do is to find a vector between
target and position of a bot, make sure bots is facing towards the target and move it if it is far enough. So let's 
begin digging the code:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let attack_distance = 0.6;

// Simple AI - follow target by a straight line.
let self_position = scene.graph[self.pivot].global_position();
let direction = target - self_position;

// Distance to target.
let distance = direction.norm();

if distance != 0.0 &amp;&amp; distance &lt; 1.5 {
    self.follow_target = true;
}
<span class="boring">}
</span></code></pre></pre>
<p>At the beginning we define a melee attack distance, bot will attack target only if it close enough. Next, we're 
building vector to from bot's position to target, calculate distance by taking length of the vector and check if 
we should switch <code>follow_target</code> flag. Next goes the most interesting parts of the AI:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if self.follow_target &amp;&amp; distance != 0.0 {
    let rigid_body = scene.graph[self.rigid_body].as_rigid_body_mut();

    // Make sure bot is facing towards the target.
    rigid_body
        .local_transform_mut()
        .set_rotation(UnitQuaternion::face_towards(
            &amp;Vector3::new(direction.x, 0.0, direction.z),
            &amp;Vector3::y_axis(),
        ));

    ...
<span class="boring">}
</span></code></pre></pre>
<p>Here we just borrow rigid body a bot, and make sure it rotated towards the target. Next we're moving bot if it is
far enough from the target:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    ...

    // Move only if we're far enough from the target.
    if distance &gt; attack_distance {
        // Normalize direction vector and scale it by movement speed.
        let xz_velocity = direction.scale(1.0 / distance).scale(0.9);

        let new_velocity =
            Vector3::new(xz_velocity.x, rigid_body.lin_vel().y, xz_velocity.z);

        rigid_body.set_lin_vel(new_velocity);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>This part is pretty simple too, all we have to do is to check how far the bot is, normalize direction vector, scale it
by movement speed and form new velocity vector using new XZ velocity + current Y velocity of a bot to preserve velocity
added by gravity (otherwise bot would just fly, you can experiment with this part to make flying zombies). One last
thing before we build and run the game, change lines of how we're updating bots to following lines:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let target = scene.graph[self.player.pivot].global_position();

for bot in self.bots.iter_mut() {
    bot.update(scene, dt, target);
}
<span class="boring">}
</span></code></pre></pre>
<p>As you can see, here we're using player's position as target. In future tutorials we'll improve AI to be able to 
automatically select targets to attack. Also, we'll &quot;teach&quot; bots to use weapons. Now it's the time to build and run 
the game and you should see something like this (something like in the video at the beginning of the tutorial):</p>
<p><img src="fyrox/tutorials/fps/tutorial-3/./ai.jpg" alt="Weapon" /></p>
<h2 id="conclusion-2"><a class="header" href="#conclusion-2">Conclusion</a></h2>
<p>In this tutorial we've added bots, animations, and a simple AI. This was the most advanced tutorial so far, but I 
promise that this series is far from completion. I hope you liked this tutorial, and if so, please consider supporting 
the project on <a href="https://patreon.com/mrdimas">Patreon</a> or <a href="https://liberapay.com/mrDIMAS">LiberaPay</a>. Source code is 
available on <a href="https://github.com/FyroxEngine/Fyrox-tutorials">GitHub</a>.</p>
<p>Discussion: <a href="https://www.reddit.com/r/rust/comments/m2ydjc/bots_and_ai_writing_a_3d_shooter_using_rg3d_3/">Reddit</a>, 
<a href="https://discord.gg/xENF5Uh">Discord</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="role-playing-game-tutorial"><a class="header" href="#role-playing-game-tutorial">Role-Playing Game Tutorial</a></h1>
<p>This tutorial starts the series of tutorials about writing a role-playing game in Rust using Fyrox game engine. Strangely,
but Fyrox has a reputation of an engine for 3D shooters. In this series I'll try to prove that it is a general purpose
game engine.</p>
<h2 id="fyrox-and-fyroxed-version-1"><a class="header" href="#fyrox-and-fyroxed-version-1">Fyrox and Fyroxed version</a></h2>
<p>Fyrox changes rapidly and tutorial's code could not compile with the newest versions of the engine, to prevent that
and keep the code compilable over time the versions of both the engine and the editor are set to specific commits 
in the main repo.</p>
<p><strong>Fyrox version</strong>: 0.26
<strong>Source code</strong>: <a href="https://github.com/FyroxEngine/Fyrox-tutorials/">GitHub</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rpg-tutorial-part-1---character-controller"><a class="header" href="#rpg-tutorial-part-1---character-controller">RPG Tutorial Part 1 - Character Controller</a></h1>
<p><strong>Source code</strong>: <a href="https://github.com/FyroxEngine/Fyrox-tutorials/tree/main/rpg-tutorial1-character-controller">GitHub</a></p>
<h2 id="table-of-contents-3"><a class="header" href="#table-of-contents-3">Table of contents</a></h2>
<ul>
<li><a href="fyrox/tutorials/rpg/tutorial-1/tutorial-part-1.html#introduction">Introduction</a></li>
<li><a href="fyrox/tutorials/rpg/tutorial-1/tutorial-part-1.html#framework">Framework</a></li>
<li><a href="fyrox/tutorials/rpg/tutorial-1/tutorial-part-1.html#assets">Assets</a></li>
<li><a href="fyrox/tutorials/rpg/tutorial-1/tutorial-part-1.html#player-and-camera-controller">Player and camera controller</a></li>
<li><a href="fyrox/tutorials/rpg/tutorial-1/tutorial-part-1.html#camera-movement">Camera movement</a></li>
<li><a href="fyrox/tutorials/rpg/tutorial-1/tutorial-part-1.html#player-locomotion">Player locomotion</a></li>
<li><a href="fyrox/tutorials/rpg/tutorial-1/tutorial-part-1.html#animations">Animations</a></li>
<li><a href="fyrox/tutorials/rpg/tutorial-1/tutorial-part-1.html#conclusion">Conclusion</a></li>
</ul>
<h2 id="introduction-3"><a class="header" href="#introduction-3">Introduction</a></h2>
<p>In this series of tutorials we will make a game similar to The Elder Scrolls series (but much, much smaller indeed),
we'll have a main character, a simple world with intractable items and a few kind of enemies. I'll show you how to add an inventory,
a quests journal, and the quests itself. This series should have at least 5 tutorials, but this might change. At the end
of the series we'll have a playable RPG which you will be able to use to continue making your own game. It is very ambitious,
but totally doable with the current state of the engine.</p>
<p>Most of the role-playing games (RPGs for short) using 3rd person camera which allows you to see your character entirely.
In this tutorial we'll make something similar. Check the video with final result of the tutorial:</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/l2ZbDpoIdqk" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<p>As you can see, at the end of the tutorial we'll be able to walk and explore a small fantasy world. Let's start by creating
a new cargo project:</p>
<p><code>cargo init rpg-tutorial</code></p>
<p>Add <code>fyrox</code> as dependency:</p>
<pre><code class="language-toml">[dependencies]
fyrox = &quot;0.26.0&quot;
</code></pre>
<h2 id="framework"><a class="header" href="#framework">Framework</a></h2>
<p>Now let's create the window and initialize the engine. We'll skip most engine initialization by using new <code>Framework</code> helper
that hides most of the engine initialization and provides unified interface for your games allowing you to focus on
your game code. <code>Framework</code> is not mandatory, you may use the <a href="https://fyrox.rs/tutorials/2021/03/05/tutorial1.html#creating-a-window">previous</a>
variant with manual engine initialization and &quot;opened&quot; main loop.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">extern crate fyrox;
</span>use fyrox::{
    core::{color::Color, futures::executor::block_on, pool::Handle, uuid::Uuid},
    engine::executor::Executor,
    event::{Event, WindowEvent},
    event_loop::ControlFlow,
    plugin::{Plugin, PluginConstructor, PluginContext},
    scene::{node::TypeUuidProvider, Scene},
};

struct Game {
    scene: Handle&lt;Scene&gt;,
}

struct GameConstructor;

impl PluginConstructor for GameConstructor {
    fn create_instance(&amp;self, _: Handle&lt;Scene&gt;, context: PluginContext) -&gt; Box&lt;dyn Plugin&gt; {
        Box::new(Game::new(context))
    }
}

impl TypeUuidProvider for GameConstructor {
    fn type_uuid() -&gt; Uuid {
        todo!()
    }
}

impl Game {
    fn new(context: PluginContext) -&gt; Self {
        let mut scene = Scene::new();

        scene.ambient_lighting_color = Color::opaque(150, 150, 150);
        
        Self {
            scene: context.scenes.add(scene),
        }
    }
}

impl Plugin for Game {
    fn update(&amp;mut self, context: &amp;mut PluginContext, _: &amp;mut ControlFlow) {
        
    }

    fn id(&amp;self) -&gt; Uuid {
        GameConstructor::type_uuid()
    }

    fn on_os_event(
        &amp;mut self,
        event: &amp;Event&lt;()&gt;,
        _context: PluginContext,
        _control_flow: &amp;mut ControlFlow,
    ) {
       
    }
}

fn main() {
    let mut executor = Executor::new();
    executor.add_plugin_constructor(GameConstructor);
    executor.get_window().set_title(&quot;RPG&quot;);
    executor.run();
}
</code></pre></pre>
<p>It is much easier to initialize the engine now compared to the initialization described in the series of tutorials about
writing a 3D shooter. If you run it, you'll see a window with black background with an &quot;RPG&quot; title.</p>
<h2 id="assets-1"><a class="header" href="#assets-1">Assets</a></h2>
<p>For any kind of game you need a lot of various assets, in our case we need a 3D model for our character, a set of
animations, a level, a set of textures for terrain, trees and bushes, barrels, etc. I prepared all assets as a single
ZIP archive which can be downloaded <a href="fyrox/tutorials/rpg/tutorial-1/./data.zip">here</a>. Once you've downloaded it, unpack it in <code>./data</code> folder.</p>
<h2 id="player-and-camera-controller"><a class="header" href="#player-and-camera-controller">Player and camera controller</a></h2>
<p>Now we can start adding Player to our game. Create a folder <code>player</code> under your <code>src</code> directory and add <code>mod.rs</code> with
following content:</p>
<pre><pre class="playground"><code class="language-rust no_run edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span>
<span class="boring">#[cfg(test)]
</span>use crate::player::camera::CameraController;

// Import everything we need for the tutorial.
use fyrox::{
    animation::{
        machine::{Machine, Parameter, PoseNode, State, Transition},
        Animation,
    },
    core::{
        algebra::{UnitQuaternion, Vector3},
        pool::Handle,
    },
    engine::resource_manager::ResourceManager,
    event::{DeviceEvent, ElementState, KeyboardInput, VirtualKeyCode},
    resource::model::Model,
    scene::{
        base::BaseBuilder, collider::ColliderBuilder, collider::ColliderShape,
        graph::physics::CoefficientCombineRule, node::Node, rigidbody::RigidBodyBuilder,
        transform::TransformBuilder, Scene, graph::Graph
    },
};

<span class="boring">#[cfg(test)]
</span>mod camera;

<span class="boring">struct CameraController;
</span><span class="boring">impl CameraController {
</span><span class="boring">    async fn new(_: &amp;mut Graph, _: ResourceManager) -&gt; Self { Self }
</span><span class="boring">}
</span>
pub struct Player {
    model: Handle&lt;Node&gt;,
    camera_controller: CameraController,
}

impl Player {
    pub async fn new(resource_manager: ResourceManager, scene: &amp;mut Scene) -&gt; Self {
        // Load paladin 3D model and create its instance in the scene.
        let model = resource_manager
            .request_model(&quot;data/models/paladin/paladin.fbx&quot;)
            .await
            .unwrap()
            .instantiate_geometry(scene);

        scene.graph[model]
            .local_transform_mut()
            // Move the model a bit down because its center is at model's feet
            // and we'd get floating model without this offset.
            .set_position(Vector3::new(0.0, -0.75, 0.0))
            // Scale down paladin's model because it is too big. 
            .set_scale(Vector3::new(0.02, 0.02, 0.02));
        
        Self {
            model,

            // As a final stage create camera controller.
            camera_controller: CameraController::new(&amp;mut scene.graph, resource_manager).await,
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Let's disassemble this heap of code line by line. At first, we're creating pivot for our character, we'll use it as a
&quot;mounting point&quot; for character's 3D model, also it will have a physical body, but that will be added later in this
tutorial. Next, we're loading paladin 3D model and creating its instance in the scene, we need only geometry without
animations, so we use <code>instantiate_geometry</code> here, animations will be added later in this tutorial. Next we scale the
model a bit, because it is too big. Also, we're moving the model a bit down because its center is at paladin's feet so
when we're attaching the model to the pivot, it will &quot;stay&quot; on the pivot. We want it to stay on ground, so we're moving
it down by height of the model. Finally, we're attaching the model to the pivot, forcing the engine to move
the model together with pivot. In the end we're creating camera controller, it needs its own module, so add <code>camera.rs</code>
module under <code>src/player</code> with following content:</p>
<pre><pre class="playground"><code class="language-rust no_run edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span>// Import everything we need for the tutorial.
use fyrox::{
    core::{
        algebra::{UnitQuaternion, Vector3},
        pool::Handle,
    },
    engine::resource_manager::ResourceManager,
    event::DeviceEvent,
    resource::texture::TextureWrapMode,
    scene::{
        base::BaseBuilder,
        camera::{CameraBuilder, SkyBox, SkyBoxBuilder},
        graph::Graph,
        node::Node,
        transform::TransformBuilder,
        pivot::PivotBuilder
    },
};

async fn create_skybox(resource_manager: ResourceManager) -&gt; SkyBox {
    // Load skybox textures in parallel.
    let (front, back, left, right, top, bottom) = fyrox::core::futures::join!(
        resource_manager.request_texture(&quot;data/textures/skybox/front.jpg&quot;),
        resource_manager.request_texture(&quot;data/textures/skybox/back.jpg&quot;),
        resource_manager.request_texture(&quot;data/textures/skybox/left.jpg&quot;),
        resource_manager.request_texture(&quot;data/textures/skybox/right.jpg&quot;),
        resource_manager.request_texture(&quot;data/textures/skybox/up.jpg&quot;),
        resource_manager.request_texture(&quot;data/textures/skybox/down.jpg&quot;)
    );

    // Unwrap everything.
    let skybox = SkyBoxBuilder {
        front: Some(front.unwrap()),
        back: Some(back.unwrap()),
        left: Some(left.unwrap()),
        right: Some(right.unwrap()),
        top: Some(top.unwrap()),
        bottom: Some(bottom.unwrap()),
    }
        .build()
        .unwrap();

    // Set S and T coordinate wrap mode, ClampToEdge will remove any possible seams on edges
    // of the skybox.
    let cubemap = skybox.cubemap();
    let mut data = cubemap.as_ref().unwrap().data_ref();
    data.set_s_wrap_mode(TextureWrapMode::ClampToEdge);
    data.set_t_wrap_mode(TextureWrapMode::ClampToEdge);

    skybox
}

pub struct CameraController {
    pivot: Handle&lt;Node&gt;,
    hinge: Handle&lt;Node&gt;,
    camera: Handle&lt;Node&gt;,
}

impl CameraController {
    pub async fn new(graph: &amp;mut Graph, resource_manager: ResourceManager) -&gt; Self {
        let camera;
        let hinge;
        let pivot = PivotBuilder::new(BaseBuilder::new()
            .with_children(&amp;[{
                hinge = PivotBuilder::new(BaseBuilder::new()
                    .with_local_transform(
                        TransformBuilder::new()
                            .with_local_position(Vector3::new(0.0, 0.55, 0.0))
                            .build(),
                    )
                    .with_children(&amp;[{
                        camera = CameraBuilder::new(
                            BaseBuilder::new().with_local_transform(
                                TransformBuilder::new()
                                    .with_local_position(Vector3::new(0.0, 0.0, -2.0))
                                    .build(),
                            ),
                        )
                        .with_z_far(48.0)
                        .with_skybox(create_skybox(resource_manager).await)
                        .build(graph);
                        camera
                    }]))
                    .build(graph);
                hinge
            }]))
            .build(graph);

        Self {
            pivot,
            hinge,
            camera,
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>To understand what this code does let's look closely at this picture:</p>
<p><img src="fyrox/tutorials/rpg/tutorial-1/./camera-layout.png" alt="Camera Layout" /></p>
<p>The pivot is marked yellow here, the hinge - green, and finally the camera is just a trapeze. Lines with arrows shows
how the nodes linked together. As you can see we're attaching the hinge to the pivot and move it up slightly (usually to the
height of the character). Next we're attaching the camera to the hinge and move it back so in default position it will
be behind the character. To understand why we need such layout, let's find out how we need to move and rotate the
camera. We need to rotate the camera around imaginary axis that goes through hinge (&quot;in&quot; the screen on the picture) -
in this layout the camera will always look at character's head and rotate around <strong>local</strong> hinge's X axis. So to do that
we need to rotate the hinge around X axis, not the camera. Here's the picture to help your understanding this better.</p>
<p><img src="fyrox/tutorials/rpg/tutorial-1/./camera-layout-rotated.png" alt="Camera Layout" /></p>
<p>That was just one of the axes, now we need to understand how to rotate the camera around Y axis, but preserving the
rotation around X axis. This is very simple, we have the pivot for that. Remember that each of the nodes (pivot, hinge, camera)
are linked together, so if we'll rotate the pivot around Y axis the hinge will rotate too as well as the camera. Fow
now our camera controller does not have an ability to rotate, we'll add this later in the tutorial.</p>
<p>Now let's load a level where our character will &quot;live&quot;, add <code>level.rs</code> with following content:</p>
<pre><pre class="playground"><code class="language-rust no_run edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span>use fyrox::{
    core::pool::Handle,
    engine::resource_manager::{ResourceManager},
    scene::{node::Node, Scene},
};

pub struct Level {
    root: Handle&lt;Node&gt;,
}

impl Level {
    pub async fn new(resource_manager: ResourceManager, scene: &amp;mut Scene) -&gt; Self {
        let root = resource_manager
            .request_model(&quot;data/levels/level.rgs&quot;)
            .await
            .unwrap()
            .instantiate_geometry(scene);

        Self { root }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>This small piece of code just loads the scene I made for this tutorial. It has a terrain and some decorations, including
houses, trees, bushes, barrels, etc. The scene was made in the Fyroxed and can be freely edited without any
problems. Just open the scene and modify it as you need.</p>
<p>Now we need to &quot;glue&quot; all the pieces (the player, and the level) together, let's go back to <code>main.rs</code> and change it to
the following code:</p>
<pre><pre class="playground"><code class="language-rust no_run edition2018"><span class="boring">extern crate fyrox;
</span><span class="boring">#[cfg(test)]
</span>use crate::{level::Level, player::Player};
use fyrox::{
    core::{color::Color, futures::executor::block_on, pool::Handle, uuid::Uuid},
    engine::{resource_manager::ResourceManager, executor::Executor},
    event::{Event, WindowEvent},
    event_loop::ControlFlow,
    plugin::{Plugin, PluginConstructor, PluginContext},
    scene::{node::TypeUuidProvider, Scene},
};

<span class="boring">#[cfg(test)]
</span>mod level;
<span class="boring">#[cfg(test)]
</span>mod player;

<span class="boring">struct Player;
</span><span class="boring">impl Player {
</span><span class="boring">   async fn new(_: ResourceManager, _: &amp;mut Scene) -&gt; Self { Self }
</span><span class="boring">}
</span>
<span class="boring">struct Level;
</span><span class="boring">impl Level {
</span><span class="boring">   async fn new(_: ResourceManager, _: &amp;mut Scene) -&gt; Self { Self }
</span><span class="boring">}
</span>
struct Game {
    scene: Handle&lt;Scene&gt;,
    level: Level,
    player: Player,
}

struct GameConstructor;

impl PluginConstructor for GameConstructor {
    fn create_instance(&amp;self, _: Handle&lt;Scene&gt;, context: PluginContext) -&gt; Box&lt;dyn Plugin&gt; {
        Box::new(Game::new(context))
    }
}

impl TypeUuidProvider for GameConstructor {
    fn type_uuid() -&gt; Uuid {
        todo!()
    }
}

impl Game {
    fn new(context: PluginContext) -&gt; Self {
        let mut scene = Scene::new();

        scene.ambient_lighting_color = Color::opaque(150, 150, 150);

        let player = block_on(Player::new(context.resource_manager.clone(), &amp;mut scene));

        Self {
            player,
            level: block_on(Level::new(context.resource_manager.clone(), &amp;mut scene)),
            scene: context.scenes.add(scene),
        }
    }
}

impl Plugin for Game {
    fn update(&amp;mut self, context: &amp;mut PluginContext, _: &amp;mut ControlFlow) {

    }

    fn id(&amp;self) -&gt; Uuid {
        GameConstructor::type_uuid()
    }

    fn on_os_event(
        &amp;mut self,
        event: &amp;Event&lt;()&gt;,
        _context: PluginContext,
        _control_flow: &amp;mut ControlFlow,
    ) {
       
    }
}

fn main() {
    let mut executor = Executor::new();
    executor.add_plugin_constructor(GameConstructor);
    executor.get_window().set_title(&quot;RPG&quot;);
    executor.run();
}

</code></pre></pre>
<p>As you can see, everything is pretty straightforward: at first we're creating a new scene, set its ambient lighting to
&quot;daylight&quot;, next we're creating the player and the level. Finally, we're adding the scene to the engine and now if you
run the game you should see something like this:</p>
<p><img src="fyrox/tutorials/rpg/tutorial-1/./scene.jpg" alt="Scene" /></p>
<p>For now everything is static, let's fix that by adding the ability to move the character and rotate the camera.</p>
<h2 id="camera-movement"><a class="header" href="#camera-movement">Camera movement</a></h2>
<p>Let's start from the camera movement and rotation. We need two new fields in the <code>CameraController</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Stub {
</span>// An angle around local Y axis of the pivot.
yaw: f32,
// An angle around local X axis of the hinge.
pitch: f32,
<span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p>Do not forget to initialize them with zeros:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Self {
    ...,
    yaw: 0.0,
    pitch: 0.0,
}
<span class="boring">}
</span></code></pre></pre>
<p>Now we need to handle device events coming from the OS to rotate the camera. Add following method to the <code>impl CameraController</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn handle_device_event(&amp;mut self, device_event: &amp;DeviceEvent) {
    if let DeviceEvent::MouseMotion { delta } = device_event {
        const MOUSE_SENSITIVITY: f32 = 0.015;

        self.yaw -= (delta.0 as f32) * MOUSE_SENSITIVITY;
        self.pitch = (self.pitch + (delta.1 as f32) * MOUSE_SENSITIVITY)
            // Limit vertical angle to [-90; 90] degrees range
            .max(-90.0f32.to_radians())
            .min(90.0f32.to_radians());
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>In this method we use only <code>MouseMotion</code> events, because CameraController does not move - it can only rotate. The method
is pretty straightforward. We're changing yaw and pitch using mouse offsets in two axes. X axis changes yaw, Y axis changes
pitch. Pitch should be limited in specific range to prevent camera to rotate 360 degrees around object, we need angle
to be in <code>[-90; 90]</code> range.</p>
<p>Once we've changed yaw and pitch, we need to apply rotations to the hinge and the camera. To do that, we need to add
a new method to the <code>impl CameraController</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn update(&amp;mut self, graph: &amp;mut Graph) {
    // Apply rotation to the pivot.
    graph[self.pivot]
        .local_transform_mut()
        .set_rotation(UnitQuaternion::from_axis_angle(
            &amp;Vector3::y_axis(),
            self.yaw,
        ));

    // Apply rotation to the hinge.
    graph[self.hinge]
        .local_transform_mut()
        .set_rotation(UnitQuaternion::from_axis_angle(
            &amp;Vector3::x_axis(),
            self.pitch,
        ));
}
<span class="boring">}
</span></code></pre></pre>
<p>It is a very simple method, it borrows nodes, and applies rotations around specific axes. Now we need to call those two
methods from somewhere. The most suitable place is <code>impl Player</code>, because <code>Player</code> owns an instance of <code>CameraController</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn handle_device_event(&amp;mut self, device_event: &amp;DeviceEvent) {
    self.camera_controller.handle_device_event(device_event)
}

pub fn update(&amp;mut self, scene: &amp;mut Scene) {
    self.camera_controller.update(&amp;mut scene.graph);
}
<span class="boring">}
</span></code></pre></pre>
<p>For now both methods are just proxies, but it will be changed pretty soon. Now we need to call the proxies, but from where?
The most suitable place is <code>on_tick</code> and <code>on_device_event</code> of the <code>GameState</code> trait implementation for our <code>Game</code> structure:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn on_tick(&amp;mut self, engine: &amp;mut Engine, dt: f32, _control_flow: &amp;mut ControlFlow) {
    let scene = &amp;mut engine.scenes[self.scene];

    self.player.update(scene);
}

fn on_device_event(
    &amp;mut self,
    _engine: &amp;mut Engine,
    _device_id: DeviceId,
    event: DeviceEvent,
) {
    self.player.handle_device_event(&amp;event);
}
<span class="boring">}
</span></code></pre></pre>
<p>Now you can run the game, and the camera should rotate when you're moving your mouse. Now it's the time to add an ability
to walk for our character.</p>
<h2 id="player-locomotion"><a class="header" href="#player-locomotion">Player locomotion</a></h2>
<p>Our player still can't move, in this section we'll fix it. Player's movement for third person camera differs from the
movement of first person. For the third person camera we must move the player either where the camera looks or according
to pressed keys on the keyboard. Let's start by adding input controller, it will hold info about needed movement:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Default)]
struct InputController {
    walk_forward: bool,
    walk_backward: bool,
    walk_left: bool,
    walk_right: bool,
}
<span class="boring">}
</span></code></pre></pre>
<p>Add new field to the <code>Player</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>input_controller: InputController,
<span class="boring">}
</span></code></pre></pre>
<p>And initialize it with <code>Default::default</code> in the <code>Player::new</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Self {
    ...,
    input_controller: Default::default(),
}
<span class="boring">}
</span></code></pre></pre>
<p>Now we need to change the state of the input controller, to do that we'll use keyboard events. Add following method to
the <code>impl Player</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn handle_key_event(&amp;mut self, key: &amp;KeyboardInput) {
    if let Some(key_code) = key.virtual_keycode {
        match key_code {
            VirtualKeyCode::W =&gt; {
                self.input_controller.walk_forward = key.state == ElementState::Pressed
            }
            VirtualKeyCode::S =&gt; {
                self.input_controller.walk_backward = key.state == ElementState::Pressed
            }
            VirtualKeyCode::A =&gt; {
                self.input_controller.walk_left = key.state == ElementState::Pressed
            }
            VirtualKeyCode::D =&gt; {
                self.input_controller.walk_right = key.state == ElementState::Pressed
            }
            _ =&gt; (),
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Now we need to call this method, we'll do it from <code>on_window_event</code> in the <code>GameState</code> trait implementation for our
<code>Game</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn on_window_event(&amp;mut self, _engine: &amp;mut Engine, event: WindowEvent) {
    match event {
        WindowEvent::KeyboardInput { input, .. } =&gt; {
            self.player.handle_key_event(&amp;input);
        }
        _ =&gt; (),
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Ok, now we have input controller functioning. Now we can start adding movement logic to the player. Let's start by adding
a physical body to the player. We'll use a capsule rigid body with locked rotations for that. Add these lines somewhere
in <code>Player::new</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::algebra::Vector3,
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    scene::{
</span><span class="boring">        Scene,
</span><span class="boring">        base::BaseBuilder,
</span><span class="boring">        collider::{ColliderBuilder, ColliderShape},
</span><span class="boring">        graph::physics::CoefficientCombineRule,
</span><span class="boring">        rigidbody::RigidBodyBuilder,
</span><span class="boring">        transform::TransformBuilder,
</span><span class="boring">    },
</span><span class="boring">};
</span><span class="boring">fn f(scene: &amp;mut Scene) {
</span><span class="boring">let model = Handle::NONE;
</span>let collider;
let body = RigidBodyBuilder::new(
    BaseBuilder::new()
        .with_local_transform(
            TransformBuilder::new()
                .with_local_position(Vector3::new(0.0, 2.0, 0.0))
                .build(),
        )
        .with_children(&amp;[
            {
                // Attach the model to the pivot. This will force model to move together with the pivot.
                model
            },
            {
                // Create capsule collider with friction disabled. We need to disable friction because linear
                // velocity will be set manually, but the physics engine will reduce it using friction so it
                // won't let us to set linear velocity precisely.
                collider = ColliderBuilder::new(BaseBuilder::new())
                    .with_shape(ColliderShape::capsule_y(0.55, 0.15))
                    .with_friction_combine_rule(CoefficientCombineRule::Min)
                    .with_friction(0.0)
                    .build(&amp;mut scene.graph);
                collider
            },
        ]),
)
.with_locked_rotations(true)
.with_can_sleep(false)
.build(&amp;mut scene.graph);
<span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p>Now, once our character has physical body, we can move it. Add these lines to the end of <code>Player::update</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let body = scene.graph[self.body].as_rigid_body_mut();

let look_vector = body
    .look_vector()
    .try_normalize(f32::EPSILON)
    .unwrap_or(Vector3::z());

let side_vector = body
    .side_vector()
    .try_normalize(f32::EPSILON)
    .unwrap_or(Vector3::x());

let position = **body.local_transform().position();

let mut velocity = Vector3::default();

if self.input_controller.walk_right {
    velocity -= side_vector;
}
if self.input_controller.walk_left {
    velocity += side_vector;
}
if self.input_controller.walk_forward {
    velocity += look_vector;
}
if self.input_controller.walk_backward {
    velocity -= look_vector;
}

let speed = 1.35 * dt;
let velocity = velocity
    .try_normalize(f32::EPSILON)
    .and_then(|v| Some(v.scale(speed)))
    .unwrap_or(Vector3::default());

// Apply linear velocity.
body.set_lin_vel(Vector3::new(
    velocity.x / dt,
    body.lin_vel().y,
    velocity.z / dt,
));

let is_moving = velocity.norm_squared() &gt; 0.0;
if is_moving {
    // Since we have free camera while not moving, we have to sync rotation of pivot
    // with rotation of camera so character will start moving in look direction.
    body.local_transform_mut()
        .set_rotation(UnitQuaternion::from_axis_angle(
            &amp;Vector3::y_axis(),
            self.camera_controller.yaw,
        ));

    // Apply additional rotation to model - it will turn in front of walking direction.
    let angle: f32 = if self.input_controller.walk_left {
        if self.input_controller.walk_forward {
            45.0
        } else if self.input_controller.walk_backward {
            135.0
        } else {
            90.0
        }
    } else if self.input_controller.walk_right {
        if self.input_controller.walk_forward {
            -45.0
        } else if self.input_controller.walk_backward {
            -135.0
        } else {
            -90.0
        }
    } else if self.input_controller.walk_backward {
        180.0
    } else {
        0.0
    };

    scene.graph[self.model].local_transform_mut().set_rotation(
        UnitQuaternion::from_axis_angle(&amp;Vector3::y_axis(), angle.to_radians()),
    );
}

// Sync camera controller position with player's position.
scene.graph[self.camera_controller.pivot]
    .local_transform_mut()
    .set_position(position + velocity);
<span class="boring">}
</span></code></pre></pre>
<p>There is lots of code, let's thoroughly go through. At first, we're getting two vectors from the pivot: X and Z axes of
the global transform of the pivot. We'll use them to move the character. Next we're using the state of the input
controller to form a new velocity vector. Then we're normalizing velocity vector and multiply it with desired speed of
movement. Normalization is needed to make the vector unit length to prevent speed variations in various directions. Next
we're applying the velocity to the rigid body, also we're locking any angular movement to prevent player's capsule
from tilting.</p>
<p>If the player is not moving, we're not syncing its rotation with camera's rotation - this allows us to look at the
character from any side while not moving. However, if the player is moving, we must sync its rotation with the rotation
of the camera controller. If we'd do this straightforward (by just syncing rotations) it would look very unnatural,
especially in case of side movements. To fix this we have this large chain of <code>if..else</code> that selects appropriate
additional rotation for the player's model. This rotation allows us, for example, look forward and move the character
backwards.</p>
<p>As the final step we're syncing position of the camera controller with the position of the pivot. Now if you run the game
you'll be able to walk around using <code>[W][S][A][D]</code> keys. However, it looks very ugly - the character's model is in T-pose,
let's fix this.</p>
<h2 id="animations-1"><a class="header" href="#animations-1">Animations</a></h2>
<p>At this point our character can move, and we can rotate the camera around it, but the character is still in T-pose and
does not have any animation. In this section we'll animate it. To keep this tutorial at reasonable length, we'll
add just an idle and walk animations and smooth transitions between them. Add following code at the end of <code>player.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    animation::{
</span><span class="boring">        machine::{Machine, Parameter, PoseNode, State, Transition},
</span><span class="boring">        Animation,
</span><span class="boring">    },
</span><span class="boring">    core::pool::Handle,
</span><span class="boring">    engine::resource_manager::ResourceManager,
</span><span class="boring">    resource::model::Model,
</span><span class="boring">    scene::{node::Node, Scene},
</span><span class="boring">};
</span>
// Simple helper method to create a state supplied with PlayAnimation node.
fn create_play_animation_state(
    animation_resource: Model,
    name: &amp;str,
    machine: &amp;mut Machine,
    scene: &amp;mut Scene,
    model: Handle&lt;Node&gt;,
) -&gt; (Handle&lt;Animation&gt;, Handle&lt;State&gt;) {
    // Animations retargetting just makes an instance of animation and binds it to
    // given model using names of bones.
    let animation = *animation_resource
        .retarget_animations(model, scene)
        .get(0)
        .unwrap();
    // Create new PlayAnimation node and add it to machine.
    let node = machine.add_node(PoseNode::make_play_animation(animation));
    // Make a state using the node we've made.
    let state = machine.add_state(State::new(name, node));
    (animation, state)
}

pub struct AnimationMachineInput {
    // Whether a bot is walking or not.
    pub walk: bool,
}

pub struct AnimationMachine {
    machine: Machine,
}

impl AnimationMachine {
    // Names of parameters that will be used for transition rules in machine.
    const IDLE_TO_WALK: &amp;'static str = &quot;IdleToWalk&quot;;
    const WALK_TO_IDLE: &amp;'static str = &quot;WalkToIdle&quot;;

    pub async fn new(
        scene: &amp;mut Scene,
        model: Handle&lt;Node&gt;,
        resource_manager: ResourceManager,
    ) -&gt; Self {
        let mut machine = Machine::new(model);

        // Load animations in parallel.
        let (walk_animation_resource, idle_animation_resource) = fyrox::core::futures::join!(
            resource_manager.request_model(&quot;data/models/paladin/walk.fbx&quot;),
            resource_manager.request_model(&quot;data/models/paladin/idle.fbx&quot;),
        );

        // Now create two states with different animations.
        let (_, idle_state) = create_play_animation_state(
            idle_animation_resource.unwrap(),
            &quot;Idle&quot;,
            &amp;mut machine,
            scene,
            model,
        );

        let (walk_animation, walk_state) = create_play_animation_state(
            walk_animation_resource.unwrap(),
            &quot;Walk&quot;,
            &amp;mut machine,
            scene,
            model,
        );

        // Next, define transitions between states.
        machine.add_transition(Transition::new(
            // A name for debugging.
            &quot;Idle-&gt;Walk&quot;,
            // Source state.
            idle_state,
            // Target state.
            walk_state,
            // Transition time in seconds.
            0.4,
            // A name of transition rule parameter.
            Self::IDLE_TO_WALK,
        ));
        machine.add_transition(Transition::new(
            &quot;Walk-&gt;Idle&quot;,
            walk_state,
            idle_state,
            0.4,
            Self::WALK_TO_IDLE,
        ));

        // Define entry state.
        machine.set_entry_state(idle_state);

        Self { machine }
    }

    pub fn update(&amp;mut self, scene: &amp;mut Scene, dt: f32, input: AnimationMachineInput) {
        self.machine
            // Set transition parameters.
            .set_parameter(Self::WALK_TO_IDLE, Parameter::Rule(!input.walk))
            .set_parameter(Self::IDLE_TO_WALK, Parameter::Rule(input.walk))
            // Update machine and evaluate final pose.
            .evaluate_pose(&amp;scene.animations, dt)
            // Apply the pose to the graph.
            .apply(&amp;mut scene.graph);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>This is a simple animation blending machine, for more info check
<a href="https://fyrox.rs/tutorials/2021/03/11/tutorial3.html#animations">&quot;Animations&quot; section of &quot;Writing a 3D shooter using Fyrox #3&quot;</a>
tutorial, it has detailed explanation how animation blending machines work. In short, here we're loading two animations,
and create two transitions between them and then applying final pose to the character.</p>
<p>Now we need to create an instance of the <code>AnimationMachine</code>, add a field to the <code>Player</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>...,
animation_machine: AnimationMachine,
<span class="boring">}
</span></code></pre></pre>
<p>And initialize it in the <code>Player::new</code>, before <code>camera_controller</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>...,
animation_machine: AnimationMachine::new(scene, model, resource_manager.clone()).await,
...
<span class="boring">}
</span></code></pre></pre>
<p>The last thing we need to do is to update animation machine each frame, we'll do this in <code>Player::update</code>, at the end
of the method:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>self.animation_machine
        .update(scene, dt, AnimationMachineInput { walk: is_moving });
<span class="boring">}
</span></code></pre></pre>
<p>Now if you run the game, you should see the character idling if not moving, and it should play &quot;walking&quot; animation if
moving. That's it for this tutorial, in the next tutorial we'll &quot;teach&quot; the character to use swords.</p>
<h2 id="conclusion-3"><a class="header" href="#conclusion-3">Conclusion</a></h2>
<p>In this tutorial we've learned how create a walking character. Created simple character controller and walked on
the scene. I hope you liked this tutorial, and if so, please consider supporting the project on
<a href="https://patreon.com/mrdimas">Patreon</a> or do a one-time donation via <a href="https://www.buymeacoffee.com/mrDIMAS">BuyMeACoffee</a>.
The source code for this tutorial is available on <a href="https://github.com/FyroxEngine/Fyrox-tutorials">GitHub</a>.</p>
<p>Discussion: <a href="https://www.reddit.com/r/rust/comments/ois776/media_writing_a_roleplaying_game_using_rg3d_game/">Reddit</a>,
<a href="https://discord.gg/xENF5Uh">Discord</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="2d-platformer-tutorial"><a class="header" href="#2d-platformer-tutorial">2D Platformer Tutorial</a></h1>
<h2 id="table-of-contents-4"><a class="header" href="#table-of-contents-4">Table of Contents</a></h2>
<ul>
<li><a href="fyrox/tutorials/platformer/part1.html#2d-platformer-tutorial">2D Platformer Tutorial</a>
<ul>
<li><a href="fyrox/tutorials/platformer/part1.html#table-of-contents">Table of Contents</a></li>
<li><a href="fyrox/tutorials/platformer/part1.html#introduction">Introduction</a></li>
<li><a href="fyrox/tutorials/platformer/part1.html#project">Project</a></li>
<li><a href="fyrox/tutorials/platformer/part1.html#using-the-editor">Using the Editor</a></li>
<li><a href="fyrox/tutorials/platformer/part1.html#scripts---player">Scripts - Player</a></li>
<li><a href="fyrox/tutorials/platformer/part1.html#animation">Animation</a></li>
<li><a href="fyrox/tutorials/platformer/part1.html#final-steps">Final Steps</a></li>
<li><a href="fyrox/tutorials/platformer/part1.html#standalone-game">Standalone Game</a></li>
<li><a href="fyrox/tutorials/platformer/part1.html#conclusion">Conclusion</a></li>
</ul>
</li>
</ul>
<h2 id="introduction-4"><a class="header" href="#introduction-4">Introduction</a></h2>
<p>In this tutorial, we'll make a 2D platformer using the new plugin and scripting system that has become available in Fyrox 0.25 and
improved in Fyrox 0.26. Here's what you'll get after finishing the tutorial:</p>
<iframe width="560" height="315" src="https://youtube.com/embed/EcvtwEkBxNU" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<p>You can find the source code of the tutorial <a href="https://github.com/FyroxEngine/Fyrox-tutorials/tree/main/platformer">here</a>, you can
test it yourself by cloning the repository and <code>cargo run --package editor --release</code> in the <code>platformer</code> directory.</p>
<h2 id="project"><a class="header" href="#project">Project</a></h2>
<p>Let's start by making a new project using the special tiny tool - <code>fyrox-template</code> - it allows you to generate all boilerplate
parts in a single call. Install it using the following command:</p>
<pre><code class="language-shell">cargo install fyrox-template
</code></pre>
<p>Navigate to a folder where you want the project to be created and do the following command:</p>
<pre><code class="language-shell">fyrox-template init --name platformer --style 2d
</code></pre>
<p>The tool accepts two arguments - project name and a style, we're interested in 2D game so the style is set to 2D. After
the project is generated, you should memorize two commands:</p>
<ul>
<li><code>cargo run --package editor --release</code> - launches the editor with your game attached, the editor allows you to run your game
inside it and edit game entities. It is intended to be used only for development.</li>
<li><code>cargo run --package executor --release</code> - creates and runs the production binary of your game that can be shipped (for
example - to a store).</li>
</ul>
<p>Navigate to the <code>platformer</code> directory and run <code>cargo run --package editor --release</code>, after some time you should see the editor:</p>
<p><img src="fyrox/tutorials/platformer/editor.png" alt="editor" /></p>
<p>Great! Now we can start making our game. Go to <code>game/src/lib.rs</code> - it is where your game logic is located, as you can see
the <code>fyrox-template</code> generate quite some code for you. There are tiny comments about which place is for what. For more info
about each method, please refer <a href="https://docs.rs/fyrox/latest/fyrox/plugin/trait.Plugin.html">to the docs</a>.</p>
<h2 id="using-the-editor"><a class="header" href="#using-the-editor">Using the Editor</a></h2>
<p>For now, we don't even need to write a single line of code, we can create a scene entirely in the editor. This section will guide
you through the process of scene creation, as a final result we'll get something similar to this:</p>
<p><img src="fyrox/tutorials/platformer/editor_with_scene.png" alt="editor with scene" /></p>
<p>At first, we need some assets, I prepared all required (and some more) in a separate zip archive, so you don't need to search
assets all over the internet. Download assets from <a href="fyrox/tutorials/platformer/assets.zip">here</a> and unpack them in a <code>data</code> folder in the root folder of
your project.</p>
<p>Let's start filling the scene. Run the editor and remove all content from the generated scene. Since we're making a 2D game, switch the editor's
camera mode to <code>Orthographic</code> at the right top corner of the scene preview window. Now we need to populate the scene with some objects,
we'll start by adding a simple ground block. Right-click on <code>__ROOT__</code> of the scene in <code>World Viewer</code> and select
<code>Add Child -&gt; Physics2D -&gt; Rigid Body</code>. This will create a rigid body for the ground block, select the rigid body, and
set <code>Body Type</code> to <code>Static</code> in <code>Inspector</code>, by doing this we're telling the physics engine that our ground block should not move
and be rock-solid. Every rigid body requires a collider, otherwise, the physics engine will not know how to handle collisions, 
right-click on the rigid body in <code>Inspector</code> and click <code>Add Child -&gt; Physics2D -&gt; Collider</code>. We've just added a new collider to the rigid
body, by default it has a <code>Cuboid</code> shape with a <code>1.0</code> meter in height and width. Finally, we need to add some graphics to the rigid body,
right-click on the rigid body and click <code>Add Child -&gt; 2D -&gt; Rectangle</code>. This adds a simple 2D sprite, select it and set a texture
to it by drag'n'dropping it from the asset browser on the white field of the <code>Texture</code> field in the <code>Inspector</code>. For my scene, I'm gonna
be using three sprites.</p>
<ul>
<li><code>data/tiles/13.png</code> - left ground block</li>
<li><code>data/tiles/14.png</code> - center ground block</li>
<li><code>data/tiles/15.png</code> - right ground block</li>
</ul>
<p>You can use any other textures and build your level as you like. After doing all these steps you should get something like this:</p>
<p><img src="fyrox/tutorials/platformer/editor_step1.png" alt="editor_step1" /></p>
<p>Clone the block by selecting its rigid body and pressing <code>Ctrl+C</code> followed by <code>Ctrl+V</code>, navigate to sprite in the copy and change its
texture to either the left or right end of the block. Use <code>Move Tool</code> to move the block somewhere you like (you can also use grid-snapping
by going to <code>File -&gt; Setting</code> and setting <code>Snap To Grid</code> for <code>Move Interaction Mode</code>). Do this one more time for the opposite end and you
should get something like this:</p>
<p><img src="fyrox/tutorials/platformer/editor_step2.png" alt="editor_step2" /></p>
<p>Repeat these steps if you like, to add more platforms. You can also add some background objects, by creating a new sprite
(right click <code>__ROOT__</code> and click <code>Add Child -&gt; 2D -&gt; Rectangle</code>) and assigning a texture to it:</p>
<p><img src="fyrox/tutorials/platformer/editor_step3.png" alt="editor_step3" /></p>
<p>As the last step of world editing, let's add some dynamic objects, like boxes. Pick some random ground block, select its rigid body, and
clone it. Switch body type of the copy to <code>Dynamic</code>. Now change its sprite texture to a box (drag'n'drop <code>data/objects/Crate.png</code> to
<code>Texture</code> field) and clone the box a few times, you should get something like this:</p>
<p><img src="fyrox/tutorials/platformer/editor_step4.png" alt="editor_step4" /></p>
<p>Now for the player. As always, let's start by creating a new rigid body, adding a 2D collider to it, and setting its shape to capsule with the following
parameters - <code>Begin = 0.0, 0.0</code> and <code>End = 0.0, 0.3</code>. Add a 2D sprite (rectangle) to the rigid body and set its texture to a texture from
<code>data/characters/adventurer/Individual Sprites</code>. We also need a camera, otherwise, we won't see anything. Add it as a child to a player's
rigid body. By default our camera will have no background, there'll be a black &quot;void&quot;, this is not great and let's fix that. Select the camera
and set the <code>Skybox</code> property to <code>Some</code>. Now go to asset browser and find <code>data/background/BG.png</code>, drag'n'drop it to the <code>Front</code> field of the
<code>Skybox</code> property. Don't forget to adjust the far plane distance to something like <code>20.0</code>, otherwise, you'll see just a portion of the background image.
If everything is done correctly, you should get something like this:</p>
<p><img src="fyrox/tutorials/platformer/editor_step5.png" alt="editor_step5" /></p>
<p>Save your scene by goint to <code>File -&gt; Save Scene</code>. Now we can run the game using the <code>Play/Stop</code> button at the top of the 
scene previewer. You should see pretty much the same as in the scene preview, except
for service graphics, such as rigid body shapes, node bounds, and so on. Now we can start writing scripts.</p>
<p>As the last preparation step, let's import all entities at the beginning, so you don't need to find them manually, add the following code
at the beginning of the <code>game/src/lib.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span>use fyrox::plugin::PluginConstructor;
use fyrox::{
    core::{
        algebra::{Vector2, Vector3},
        futures::executor::block_on,
        inspect::{Inspect, PropertyInfo},
        pool::Handle,
        reflect::Reflect,
        uuid::{uuid, Uuid},
        visitor::prelude::*,
    },
    engine::resource_manager::ResourceManager,
    event::{ElementState, Event, VirtualKeyCode, WindowEvent},
    impl_component_provider,
    plugin::{Plugin, PluginContext, PluginRegistrationContext},
    resource::texture::Texture,
    scene::{
        dim2::{rectangle::Rectangle, rigidbody::RigidBody},
        node::{Node, TypeUuidProvider},
        Scene, SceneLoader,
    },
    script::{ScriptContext, ScriptTrait},
};
<span class="boring">}
</span></code></pre></pre>
<h2 id="scripts---player"><a class="header" href="#scripts---player">Scripts - Player</a></h2>
<p>Our scene has pretty much everything we need to start adding scripts, we'll start from the <code>Player</code> script and make our character
move. Navigate to <code>game/src/lib.rs</code> and at the end of the file add the following code snippet:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::{
</span><span class="boring">        inspect::{Inspect, PropertyInfo},
</span><span class="boring">        uuid::{uuid, Uuid},
</span><span class="boring">        reflect::Reflect,
</span><span class="boring">        visitor::prelude::*,
</span><span class="boring">    },
</span><span class="boring">    event::Event,
</span><span class="boring">    impl_component_provider,
</span><span class="boring">    gui::inspector::PropertyChanged,
</span><span class="boring">    scene::node::TypeUuidProvider,
</span><span class="boring">    script::{ScriptContext, ScriptTrait},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">struct Game;
</span><span class="boring">
</span><span class="boring">impl Game {
</span><span class="boring">    fn type_uuid() -&gt; Uuid {
</span><span class="boring">        todo!()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[derive(Visit, Reflect, Inspect, Debug, Clone, Default)]
struct Player;

impl_component_provider!(Player,);

impl TypeUuidProvider for Player {
    // Returns unique script id for serialization needs.
    fn type_uuid() -&gt; Uuid {
        uuid!(&quot;c5671d19-9f1a-4286-8486-add4ebaadaec&quot;)
    }
}

impl ScriptTrait for Player {
    // Called once at initialization.
    fn on_init(&amp;mut self, context: ScriptContext) {}

    // Called whenever there is an event from OS (mouse click, keypress, etc.)
    fn on_os_event(&amp;mut self, event: &amp;Event&lt;()&gt;, context: ScriptContext) {}

    // Called every frame at fixed rate of 60 FPS.
    fn on_update(&amp;mut self, context: ScriptContext) {}

    // Returns unique script ID for serialization needs.
    fn id(&amp;self) -&gt; Uuid {
        Self::type_uuid()
    }

    // Returns unique id of parent plugin.
    fn plugin_uuid(&amp;self) -&gt; Uuid {
        Game::type_uuid()
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>This is a typical &quot;skeleton&quot; of any script, for now, its methods are pretty much empty, we'll fill it with actual code very soon.
Let's go over the most important parts. The snippet starts from the <code>Player</code> structure definition which has <code>#[derive(Visit, Inspect, Debug, Clone, Default)]</code>
attributes:</p>
<ul>
<li><code>Visit</code> - implements serialization/deserialization functionality, it is used by the editor to save your object to a scene file.</li>
<li><code>Inspect</code> - generates metadata for the fields of your type - in other words, it allows the editor to &quot;see&quot; what's inside
your structure and show additional information attached to the fields via proc-macro attributes.</li>
<li><code>Reflect</code> - implements compile-time reflection that allows the editor to mutate your objects.</li>
<li><code>Debug</code> - provides debugging functionality, it is mostly for the editor to let it print stuff into the console.</li>
<li><code>Clone</code> - makes your structure clone-able, why do we need this? We can clone objects and we also want the script instance to be
copied.</li>
<li><code>Default</code> implementation is very important - the scripting system uses it to create your scripts in the default state.
This is necessary to set some data to it and so on. If it's a special case, you can always implement your own <code>Default</code>'s
implementation if it's necessary for your script.</li>
<li><code>TypeUuidProvider</code> is used to attach some unique id for your type, every script *<em>must</em> have a unique ID, otherwise, the engine will
not be able to save and load your scripts. To generate a new UUID, use <a href="https://www.uuidgenerator.net/">Online UUID Generator</a> or
any other tool that can generate UUIDs.</li>
</ul>
<p>Finally, we implement <code>ScriptTrait</code> for the <code>Player</code>. It has a bunch of methods, their names speak for themselves. Learn more about
every method in <a href="https://docs.rs/fyrox/latest/fyrox/script/trait.ScriptTrait.html">documentation</a></p>
<p>Before we can use the script in the editor, we must tell the engine that our script exists - we must register it. Remember that
<code>register</code> method in the <code>PluginConstructor</code> trait implementation? It is exactly for script registration, replace its implementation with the following
code snippet:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn register(&amp;mut self, context: PluginRegistrationContext) {
    let script_constructors = &amp;context.serialization_context.script_constructors;
    script_constructors.add::&lt;Player&gt;(&quot;Player&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p>Now the engine knows about our script and will be able to use it. It is pretty much useless in the current state, but we can already
assign it to the player. Select the player's rigid body node and find <code>Script</code> in the <code>Inspector</code>, select <code>Player</code> from the respective
drop-down list and that's pretty much it - now the script is assigned:</p>
<p><img src="fyrox/tutorials/platformer/script_selection.png" alt="script_selection" /></p>
<p>Let's learn how to edit script properties from the editor. In the next section, we'll be adding keyframe animation for your character,
it is a perfect opportunity to learn how the engine and the editor operate with user-defined properties in scripts. To animate the player
we need to get its sprite first. Let's start by adding the required field in the <code>Player</code> structure:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Visit, Reflect, Inspect, Debug, Clone, Default)]
struct Player {
    sprite: Handle&lt;Node&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>After adding this, the editor will be able to see the field and give you the ability to edit it in the Inspector. 
To assign the correct handle of the sprite to the respective field in script properties, hold <code>Alt</code> and start dragging
the sprite node from the world viewer to the respective field in the player script. Release the mouse button and if 
everything is ok, the field should &quot;say&quot; something different than &quot;Unassigned&quot;.</p>
<p>Alright, at this point we know how to work with script properties, now we can start adding basic movement for the player.
Go to the <code>Player</code> structure and add the following fields:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Foo {
</span>move_left: bool,
move_right: bool,
jump: bool,
<span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p>These fields will store the state of keyboard keys responsible for player movement. Now for <code>on_os_event</code>, add the following code there:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let Event::WindowEvent { event, .. } = event {
    if let WindowEvent::KeyboardInput { input, .. } = event {
        if let Some(keycode) = input.virtual_keycode {
            let is_pressed = input.state == ElementState::Pressed;

            match keycode {
                VirtualKeyCode::A =&gt; self.move_left = is_pressed,
                VirtualKeyCode::D =&gt; self.move_right = is_pressed,
                VirtualKeyCode::Space =&gt; self.jump = is_pressed,
                _ =&gt; (),
            }
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>The code responds to OS events and modifies internal movement flags accordingly. Now we need to use the flags somehow, it's time for
<code>on_update</code>. The method is called each frame and allows you to put game logic there:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{core::algebra::Vector2, scene::dim2::rigidbody::RigidBody, script::ScriptContext};
</span><span class="boring">
</span><span class="boring">struct Foo {
</span><span class="boring">    move_left: bool,
</span><span class="boring">    move_right: bool,
</span><span class="boring">    jump: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Foo {
</span>// Called every frame at fixed rate of 60 FPS.
fn on_update(&amp;mut self, context: ScriptContext) {
    // The script can be assigned to any scene node, but we assert that it will work only with
    // 2d rigid body nodes.
    if let Some(rigid_body) = context.scene.graph[context.handle].cast_mut::&lt;RigidBody&gt;() {
        let x_speed = match (self.move_left, self.move_right) {
            (true, false) =&gt; 3.0,
            (false, true) =&gt; -3.0,
            _ =&gt; 0.0,
        };

        if self.jump {
            rigid_body.set_lin_vel(Vector2::new(x_speed, 4.0));
        } else {
            rigid_body.set_lin_vel(Vector2::new(x_speed, rigid_body.lin_vel().y));
        }
    }
}
<span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p>Finally, some interesting code. At first, we check if the node to which the script is assigned is a 2d rigid body, next
we're checking movement flags and form horizontal speed, and applying velocity to the body. Velocity is applied in two ways: if
the jump button was pressed - apply horizontal velocity and some vertical velocity for jumping. If the jump button wasn't pressed -
just change horizontal velocity - this will allow the player to free fall.</p>
<p>Run the editor and enter play mode, press <code>[A][D][Space]</code> buttons to check if everything works correctly - the player should move
horizontally and be able to jump. You can jump to the boxes on the right and push them off the ledge.</p>
<p>The movement is working, but the player does not change orientation, if we'll go to the left - it looks ok (despite the lack of animation),
but if we'll move to the right - it looks like the player moves backward. Let's fix that by changing the horizontal scaling of the player's
sprite. Add the following code at the end of the <code>if let ...</code> block of the code above:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// It is always a good practice to check whether the handles are valid, at this point we don't know
// for sure what's the value of the `sprite` field. It can be unassigned and the following code won't
// execute. A simple `context.scene.graph[self.sprite]` would just panicked in this case.
if let Some(sprite) = context.scene.graph.try_get_mut(self.sprite) {
    // We want to change player orientation only if he's moving.
    if x_speed != 0.0 {
        let local_transform = sprite.local_transform_mut();
        let current_scale = **local_transform.scale();

        local_transform.set_scale(Vector3::new(
            // Just change X scaling to mirror player's sprite.
            current_scale.x.copysign(-x_speed),
            current_scale.y,
            current_scale.z,
        ));
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>The comments should clarify what's going on here, but in short, we're changing the horizontal scaling of the player's sprite if the player is
moving. The line <code>current_scale.x.copysign(-x_speed)</code> could be confusing, what it does? It replaces the sign of current horizontal scaling
using the opposite sign of <code>x_speed</code>.</p>
<p>Now if you run the game, the player will &quot;look&quot; in correct direction depending on the velocity vector.</p>
<h2 id="animation-2"><a class="header" href="#animation-2">Animation</a></h2>
<p>Since we're making a 2D game, we'll be using simple animations based on the continuous change of keyframes. In other words, we'll be changing
the texture of the player's body sprite. The engine does not provide such functionality yet, simply because it was focused primarily on 3D games
for quite a long period. It is easy to make such an animation &quot;system&quot; ourselves.</p>
<p>Put this code snippet somewhere at the end of <code>lib.rs</code> of the <code>game</code> project and we'll start learning what it's doing:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Default, Reflect, Inspect, Visit, Debug, Clone)]
pub struct KeyFrameTexture {
    texture: Option&lt;Texture&gt;,
}

impl KeyFrameTexture {
    fn restore_resources(&amp;mut self, resource_manager: ResourceManager) {
        // It is very important to restore texture handle after loading, otherwise the handle will
        // remain in &quot;shallow&quot; state when it just has path to data, but not the actual resource handle.
        resource_manager
            .state()
            .containers_mut()
            .textures
            .try_restore_optional_resource(&amp;mut self.texture);
    }
}

#[derive(Inspect, Reflect, Visit, Debug, Clone)]
pub struct Animation {
    name: String,
    keyframes: Vec&lt;KeyFrameTexture&gt;,
    current_frame: u32,
    speed: f32,

    // We don't want this field to be visible from the editor, because this is internal parameter.
    #[inspect(skip)]
    t: f32,
}

impl Default for Animation {
    fn default() -&gt; Self {
        Self {
            name: &quot;Unnamed&quot;.to_string(),
            speed: 10.0,
            ..Default::default()
        }
    }
}

impl Animation {
    pub fn current_frame(&amp;self) -&gt; Option&lt;&amp;KeyFrameTexture&gt; {
        self.keyframes.get(self.current_frame as usize)
    }

    fn restore_resources(&amp;mut self, resource_manager: ResourceManager) {
        for key_frame in self.keyframes.iter_mut() {
            key_frame.restore_resources(resource_manager.clone());
        }
    }

    pub fn update(&amp;mut self, dt: f32) {
        self.t += self.speed * dt;

        if self.t &gt;= 1.0 {
            self.t = 0.0;

            // Increase frame index and make sure it will be clamped in available bounds.
            self.current_frame = (self.current_frame + 1) % self.keyframes.len() as u32;
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>The code snippet is quite big, but this is pretty much everything we need for simple keyframe animation.
We start by defining the <code>KeyFrameTexture</code> structure - it is a simple new-type-ish structure that holds a single
field - optional texture handle.</p>
<p><code>restore_resources</code> restores texture handle on deserialization. Sounds complicated, why do we need to do anything after
deserialization? Well, the answer is simple - we don't store texture data in the texture, instead, we just save the path
to an external resource and request the resource manager to load the texture.</p>
<p>Finally, we're at the <code>Animation</code> structure, nothing unusual there, it just stores a list of keyframes, an index
of a current keyframe, speed, and some service fields. The implementation of it is very straightforward too,
the most interesting method is <code>update</code>. Inside it, we're updating the internal <code>t</code> parameter which holds the &quot;fraction&quot;
of the next frame's index, when it reaches <code>1.0</code> we're increasing the index of the current frame and wrapping it so it
never exceeds the maximum amount of keyframes - instead, it will start counting from 0.</p>
<p>It's time to start using the new animation system, just add the following fields to the <code>Player</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate fyrox;
</span><span class="boring">struct Animation;
</span><span class="boring">struct Player {
</span>animations: Vec&lt;Animation&gt;,
current_animation: u32,
<span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p>Currently, we just pass default values.</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>..Default::default()
<span class="boring">}
</span></code></pre></pre>
<p>The Player will use multiple animations in future tutorials, but for now, it will use only two - idle and run.
Now we need to somehow switch animations. Go to <code>on_update</code> in <code>Player</code> and add the following lines after
the <code>x_speed</code> declaration:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Player {
</span><span class="boring">    current_animation: usize,
</span><span class="boring">}
</span><span class="boring">impl Player {
</span><span class="boring">    pub fn on_update(&amp;mut self) {
</span><span class="boring">      let x_speed = 0.0;
</span>if x_speed != 0.0 {
    self.current_animation = 0;
} else {
    self.current_animation = 1;
}
<span class="boring">   }
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p>Here we assume that the run animation will be at index <code>0</code> and the idle animation at index <code>1</code>. We also need to
apply the texture from the current animation to the player's sprite, and add the following lines at the end of <code>on_update</code></p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let Some(current_animation) = self.animations.get_mut(self.current_animation as usize) {
    current_animation.update(context.dt);

    if let Some(sprite) = context
        .scene
        .graph
        .try_get_mut(self.sprite)
        .and_then(|n| n.cast_mut::&lt;Rectangle&gt;())
    {
        // Set new frame to the sprite.
        sprite.set_texture(
            current_animation
                .current_frame()
                .and_then(|k| k.texture.clone()),
        )
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>The code is pretty straightforward - we start by trying to get a reference to the current animation by its index,
and if we're succeeded, we update it. At the next step, we're getting sprite and assigning a current frame of
the current animation. Experienced game developers could immediately ask - why not use sprite sheets and get
better performance and stuff. Well, the main purpose of this tutorial is to teach how to use the engine to
achieve some goal, such as <em>making a game</em>. You can always optimize your game later when you'll have something
working and playable.</p>
<h2 id="final-steps"><a class="header" href="#final-steps">Final Steps</a></h2>
<p>Three more steps before we can run the game, we need to call <code>restore_resources</code> for each animation. To do that,
the script trait has the <code>on_restore_resources</code> method, add the following code to <code>impl ScriptTrait for Player</code></p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn restore_resources(&amp;mut self, resource_manager: ResourceManager) {
    for animation in self.animations.iter_mut() {
        animation.restore_resources(resource_manager.clone());
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>As a second step, replace the contents of the <code>editor/src/main.rs</code> with the following code snippet:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail">//! Editor with your game connected to it as a plugin.
use fyrox::{
    event_loop::EventLoop,
    gui::inspector::editors::{
        collection::VecCollectionPropertyEditorDefinition,
        inspectable::InspectablePropertyEditorDefinition,
    },
};
use fyroxed_base::{Editor, StartupData};
use platformer::{Animation, GameConstructor, KeyFrameTexture};

fn main() {
    let event_loop = EventLoop::new();
    let mut editor = Editor::new(
        &amp;event_loop,
        Some(StartupData {
            working_directory: Default::default(),
            scene: &quot;data/scene.rgs&quot;.into(),
        }),
    );
    editor.add_game_plugin(GameConstructor);

    // Register property editors here.
    let property_editors = &amp;editor.inspector.property_editors;
    property_editors.insert(InspectablePropertyEditorDefinition::&lt;KeyFrameTexture&gt;::new());
    property_editors.insert(InspectablePropertyEditorDefinition::&lt;Animation&gt;::new());
    property_editors.insert(VecCollectionPropertyEditorDefinition::&lt;KeyFrameTexture&gt;::new());
    property_editors.insert(VecCollectionPropertyEditorDefinition::&lt;Animation&gt;::new());

    editor.run(event_loop)
}
</code></pre></pre>
<p>The most interesting code here is this:</p>
<pre><pre class="playground"><code class="language-rust no_run compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Register property editors here.
let property_editors = &amp;editor.inspector.property_editors;
property_editors.insert(InspectablePropertyEditorDefinition::&lt;KeyFrameTexture&gt;::new());
property_editors.insert(InspectablePropertyEditorDefinition::&lt;Animation&gt;::new());
property_editors.insert(VecCollectionPropertyEditorDefinition::&lt;KeyFrameTexture&gt;::new());
property_editors.insert(VecCollectionPropertyEditorDefinition::&lt;Animation&gt;::new());
<span class="boring">}
</span></code></pre></pre>
<p>Here we're registering <em>property editors</em> for our game types. This very important step, tells the editor how to
visualize your data. In most cases, you'll be using those two generic types - <code>InspectablePropertyEditorDefinition</code>
and <code>VecCollectionPropertyEditorDefinition</code>. Which is responsible for what?</p>
<ul>
<li><code>InspectablePropertyEditorDefinition</code> - is responsible for showing properties of any object that implements
<code>Inspect</code> trait. All of your game entities must implement such traits.</li>
<li><code>VecCollectionPropertyEditorDefinition</code> - it is responsible for showing <code>Vec&lt;T: Inspect&gt;</code> collection, every
collection item <strong>must</strong> implement <code>Inspect</code> trait. This is a bit tedious, especially in the case of simple collections
like <code>Vec&lt;f32&gt;</code>, but that's a limitation of the current implementation. It can be mitigated by using a new-type technique,
which was shown earlier.</li>
</ul>
<p>This is yet another place for manual work, but it must be done, the editor cannot use &quot;magic&quot; to understand which widget
to use to visualize your data, there's no magic here.</p>
<p>Now we need to go to the editor again and add the animations to the <code>Player</code>, select the player's rigid body, and
find the <code>Script</code> section in the <code>Inspector</code>. Add two animations there like so:</p>
<p><img src="fyrox/tutorials/platformer/editor_step6.png" alt="editor_step6" /></p>
<h2 id="conclusion-4"><a class="header" href="#conclusion-4">Conclusion</a></h2>
<p>In this tutorial, we've learned the basics of the new scripting system of the engine that was added in Fyrox 0.25. The game
we've built it very simple, but it is just the beginning.
It is easy to add more scripts for enemies, weapons, collectible items, and so on.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="obsolete-features"><a class="header" href="#obsolete-features">Obsolete Features</a></h1>
<p>The following chapters contains information about obsolete features that should not be used.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="installation-obsolete"><a class="header" href="#installation-obsolete">Installation (Obsolete)</a></h2>
<p><strong>WARNING: This section considered obsolete - Fyrox 0.25+ has project generator that handles installation for you.
This section is intended to be used only if you're using the engine as a framework!</strong></p>
<p>Since the engine is distributed as a library, it has to be added to <code>[dependecies]</code> section of <code>Cargo.toml</code> of
your project to start using it, there is no pre-built executables or library files. If you don't know what is
<code>Cargo.toml</code> or <code>cargo</code>, please <a href="https://doc.rust-lang.org/cargo/">read this</a> before continue.</p>
<h3 id="using-stable-version"><a class="header" href="#using-stable-version">Using stable version</a></h3>
<p>To begin using the engine, just add following lines to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
fyrox = &quot;^0.27&quot;
</code></pre>
<p>This will force Cargo to use the latest <strong>stable</strong> version of the engine.</p>
<h3 id="using-latest-unstable-version"><a class="header" href="#using-latest-unstable-version">Using latest unstable version</a></h3>
<p>Sometimes you want to use the latest features that are not yet released in a stable version, then you can use
the engine directly from its repository, simply add the following line to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
fyrox = { git = &quot;https://github.com/FyroxEngine/Fyrox&quot; } 
</code></pre>
<p>This will update your build files fairly often. If you don't want game breaking changes to occur because of engine updates or want to not compile daily,
change <code>fyrox = { git = &quot;https://github.com/FyroxEngine/Fyrox&quot; }</code> to <code>fyrox = { git = &quot;https://github.com/FyroxEngine/Fyrox&quot;, rev = &quot;&quot; }</code> with the commit
hash in the quotes.</p>
<h2 id="editor-installation"><a class="header" href="#editor-installation">Editor installation</a></h2>
<p>The engine offers an editor, to install a standalone version it, use <code>cargo install</code>:</p>
<pre><code class="language-shell">cargo install fyroxed
</code></pre>
<p>Standalone version does not allow you to run your game inside it, but only allows you to edit scenes.</p>
<p>After that you can run the editor with a single command:</p>
<pre><code class="language-shell">fyroxed
</code></pre>
<p>Check the next chapter to create a simple application.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-game-loop"><a class="header" href="#custom-game-loop">Custom game loop</a></h1>
<p><strong>WARNING: Manual engine initialization considered obsolete, use plugins and scripts instead.</strong></p>
<p>The plugin might be limiting for some cases, in such situations the engine could be initialized manually. It
requires some decent amount of code and could error-prone for beginners. You should use custom game loop only if
you're experienced game developer!</p>
<p>Here is an example of custom game loop with comments that will guide your through all aspects of it:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">extern crate fyrox;
</span><span class="boring">use fyrox::{
</span><span class="boring">    core::instant::Instant,
</span><span class="boring">    engine::{resource_manager::ResourceManager, Engine, EngineInitParams, SerializationContext},
</span><span class="boring">    event::{Event, WindowEvent},
</span><span class="boring">    event_loop::{ControlFlow, EventLoop},
</span><span class="boring">    utils::{
</span><span class="boring">        log::{Log, MessageKind},
</span><span class="boring">        translate_event,
</span><span class="boring">    },
</span><span class="boring">};
</span><span class="boring">use std::{sync::Arc};
</span>
fn main() {
    let event_loop = EventLoop::new();

    // Create window builder first.
    let window_builder = fyrox::window::WindowBuilder::new()
        .with_title(&quot;Example - Custom Game Loop&quot;)
        .with_resizable(true);

    // Then initialize the engine.
    let serialization_context = Arc::new(SerializationContext::new());
    let mut engine = Engine::new(EngineInitParams {
        window_builder,
        resource_manager: ResourceManager::new(serialization_context.clone()),
        serialization_context,
        events_loop: &amp;event_loop,
        vsync: false,
    })
    .unwrap();

    // Define game loop variables.
    let clock = Instant::now();
    let fixed_timestep = 1.0 / 60.0;
    let mut elapsed_time = 0.0;

    // Finally run our event loop which will respond to OS and window events and update
    // engine state accordingly. Engine lets you to decide which event should be handled,
    // this is minimal working example if how it should be.
    event_loop.run(move |event, _, control_flow| {
        match event {
            Event::MainEventsCleared =&gt; {
                // This main game loop - it has fixed time step which means that game
                // code will run at fixed speed even if renderer can't give you desired
                // 60 fps.
                let mut dt = clock.elapsed().as_secs_f32() - elapsed_time;
                while dt &gt;= fixed_timestep {
                    dt -= fixed_timestep;
                    elapsed_time += fixed_timestep;

                    // ************************
                    // ************************
                    // Put your game logic here.
                    // ************************
                    // ************************

                    // It is very important to update the engine every frame!
                    engine.update(fixed_timestep, control_flow);
                }

                // It is very important to &quot;pump&quot; messages from UI. Even if don't need to
                // respond to such message, you should call this method, otherwise UI
                // might behave very weird.
                while let Some(_ui_event) = engine.user_interface.poll_message() {
                    // ************************
                    // ************************
                    // Put your data model synchronization code here. It should
                    // take message and update data in your game according to
                    // changes in UI.
                    // ************************
                    // ************************
                }

                // Rendering must be explicitly requested and handled after RedrawRequested event is received.
                engine.get_window().request_redraw();
            }
            Event::RedrawRequested(_) =&gt; {
                // Run renderer at max speed - it is not tied to game code.
                engine.render().unwrap();
            }
            Event::WindowEvent { event, .. } =&gt; {
                match event {
                    WindowEvent::CloseRequested =&gt; *control_flow = ControlFlow::Exit,
                    WindowEvent::Resized(size) =&gt; {
                        // It is very important to handle Resized event from window, because
                        // renderer knows nothing about window size - it must be notified
                        // directly when window size has changed.
                        if let Err(e) = engine.set_frame_size(size.into()) {
                            Log::writeln(
                                MessageKind::Error,
                                format!(&quot;Unable to set frame size: {:?}&quot;, e),
                            );
                        }
                    }
                    // Handle rest of events here if necessary.
                    _ =&gt; (),
                }

                // It is very important to &quot;feed&quot; user interface (UI) with events coming
                // from main window, otherwise UI won't respond to mouse, keyboard, or any
                // other event.
                if let Some(os_event) = translate_event(&amp;event) {
                    engine.user_interface.process_os_event(&amp;os_event);
                }
            }
            // Continue polling messages from OS.
            _ =&gt; *control_flow = ControlFlow::Poll,
        }
    });
}
</code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
