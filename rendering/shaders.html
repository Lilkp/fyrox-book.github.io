<!DOCTYPE HTML>
<html lang="en" class="navy sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Shaders - Fyrox Book</title>


        <!-- Custom HTML head -->
        <!-- Google tag (gtag.js) -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-ETGWNBR03Y"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-ETGWNBR03Y');
        </script>

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('navy')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Fyrox Book</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/fyrox-book/fyrox-book.github.io/tree/main" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/fyrox-book/fyrox-book.github.io/edit/main/src/rendering/shaders.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="shaders"><a class="header" href="#shaders">Shaders</a></h1>
<p>Shader is a set of programs that run directly on graphics adapter. Each program from the set is called
<em>sub-shader</em>. Sub-shaders linked with render pass, each render pass defines "where" to draw an object.
"where" means that you can set up your own render pass and the renderer will use the sub-shader with
your render pass. For the ease of use there are a number of <a href="#predefined-render-passes">predefined render passes</a>.</p>
<p>Shaders have properties of various types that can be used together with materials to draw an object.</p>
<h2 id="shaders-language"><a class="header" href="#shaders-language">Shaders language</a></h2>
<p>The engine uses GLSL shading language for every sub-shader. There are numerous GLSL guides over the
internet, so there is no need to "re-post" the well documented info again.</p>
<p>There are very few differences:</p>
<ol>
<li>No need to define a version of the shader. Every shader source will be pre-processed, and it will
get correct version automatically. Preprocessing is needed because the same shader could run on OpenGL
and WebGL (OpenGL ES) which have some differences.</li>
<li>There is a "standard" library of useful methods which is automatically included in every shader source
at preprocessing stage. The library source could be found
<a href="https://github.com/FyroxEngine/Fyrox/blob/1b886caf831b87fb17958bac7f38a6b2d305646c/fyrox-graphics/src/gl/shaders/shared.glsl">here</a>.
It is well documented, and you may find some functions useful for you job.</li>
</ol>
<h2 id="structure"><a class="header" href="#structure">Structure</a></h2>
<p>Shader has rigid structure that could be described in this code snippet:</p>
<pre><code class="language-json">(
    // A set of properties, there could be any number of properties.
    properties: [
        (
            // Each property must have a name. This name must match with respective
            // uniforms! That's is the whole point of having properties.
            name: "diffuseTexture",
            // Value has limited set of possible variants.
            value: Sampler(default: None, fallback: White)
        )
    ],
    // A set of render passes (see next section for more info)
    passes: [
        (
            // Name must match with the name of either standard render pass (see below) or
            // one of your passes.
            name: "Forward",
            // A set of parameters that regulate renderer pipeline state.
            // This is mandatory field of each render pass.
            draw_parameters: DrawParameters(
                // A face to cull. Either Front or Back.
                cull_face: Some(Back),
                // Color mask. Defines which colors should be written to render target.
                color_write: ColorMask(
                    red: true,
                    green: true,
                    blue: true,
                    alpha: true,
                ),
                // Whether to modify depth buffer or not.
                depth_write: true,
                // Whether to use stencil test or not.
                stencil_test: None,
                // Whether to perform depth test when drawing.
                depth_test: true,
                // Blending options.
                blend: Some(BlendFunc(
                    sfactor: SrcAlpha,
                    dfactor: OneMinusSrcAlpha,
                )),
                // Stencil options.
                stencil_op: StencilOp(
                    fail: Keep,
                    zfail: Keep,
                    zpass: Keep,
                    write_mask: 0xFFFF_FFFF,
                ),
            ),
            // Vertex shader code.
            vertex_shader:
                r#"
                layout(location = 0) in vec3 vertexPosition;
                layout(location = 1) in vec2 vertexTexCoord;
                uniform mat4 fyrox_worldViewProjection;
                out vec2 texCoord;
                void main()
                {
                    texCoord = vertexTexCoord;
                    gl_Position = fyrox_worldViewProjection * vertexPosition;
                }
                "#;
            // Pixel shader code.
            pixel_shader:
                r#"
                // Note that the name of this uniform match the name of the property up above.
                uniform sampler2D diffuseTexture;
                out vec4 FragColor;
                in vec2 texCoord;
                void main()
                {
                    FragColor = diffuseColor * texture(diffuseTexture, texCoord);
                }
                "#;
        )
    ],
)
</code></pre>
<p>The engine can load such shaders if you save it in a file with <code>.shader</code> extension. After that, you can assign
the shader to your material in the Material Editor:</p>
<p><img src="./shader.png" alt="shader" /></p>
<p>Alternatively, you can load the shader from code. To do this, you can use this code:</p>
<pre><pre class="playground"><code class="language-rust  no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn load_shader(resource_manager: &amp;ResourceManager) -&gt; ShaderResource {
    resource_manager.request::&lt;Shader&gt;("path/to/my/cool.shader")
}
<span class="boring">}</span></code></pre></pre>
<p>After that you can use the shader to build a material from it:</p>
<pre><pre class="playground"><code class="language-rust  no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_material(resource_manager: &amp;ResourceManager) -&gt; MaterialResource {
    let shader = resource_manager.request::&lt;Shader&gt;("path/to/my/cool.shader");
    MaterialResource::new(Material::from_shader(shader))
}
<span class="boring">}</span></code></pre></pre>
<p>This material instance can be used for rendering. For example, you can assign it a surface of some mesh.</p>
<h2 id="properties"><a class="header" href="#properties">Properties</a></h2>
<p>Property is a named variable of some type. Properties are directly tied with the uniforms in the sub-shaders,
for each you can have a property called <code>time</code>, and then you can define <code>uniform float time;</code> in your sub-shader
and the engine will pass a property value to that uniform for you before drawing an object. Properties placed in
a "global namespace", which means that every sub-shader has "access" to the properties.</p>
<h2 id="built-in-properties"><a class="header" href="#built-in-properties">Built-in properties</a></h2>
<p>There are number of built-in properties, that Fyrox will try to assign automatically if they're defined
in your shader:</p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>fyrox_worldMatrix</td><td><code>mat4</code></td><td>Local-to-world transformation.</td></tr>
<tr><td>fyrox_worldViewProjection</td><td><code>mat4</code></td><td>Local-to-clip-space transform.</td></tr>
<tr><td>fyrox_boneMatrices</td><td><code>sampler2D</code></td><td>Array of bone matrices packed into a texture. Use <code>S_FetchMatrix</code> built-in method to fetch a matrix by its index.</td></tr>
<tr><td>fyrox_useSkeletalAnimation</td><td><code>bool</code></td><td>Whether skinned meshes is rendering or not.</td></tr>
<tr><td>fyrox_cameraPosition</td><td><code>vec3</code></td><td>Position of the camera in world coordinates.</td></tr>
<tr><td>fyrox_cameraUpVector</td><td><code>vec3</code></td><td>Up vector of the camera in world coordinates.</td></tr>
<tr><td>fyrox_cameraSideVector</td><td><code>vec3</code></td><td>Side vector of the camera in world coordinates.</td></tr>
<tr><td>fyrox_zNear</td><td><code>float</code></td><td>Near clipping plane of the camera.</td></tr>
<tr><td>fyrox_zFar</td><td><code>float</code></td><td>Far clipping plane of the camera.</td></tr>
<tr><td>fyrox_sceneDepth</td><td><code>sampler2D</code></td><td>2D texture with the depth values of the scene. Available only after GBuffer pass.</td></tr>
<tr><td>fyrox_usePOM</td><td><code>bool</code></td><td>Whether to use parallax mapping or not.</td></tr>
<tr><td>fyrox_blendShapesStorage</td><td><code>sampler3D</code></td><td>3D texture of layered blend shape storage. Use <code>S_FetchBlendShapeOffsets</code> built-in method to fetch info.</td></tr>
<tr><td>fyrox_blendShapesWeights</td><td><code>float[128]</code></td><td>Weights of all available blend shapes.</td></tr>
<tr><td>fyrox_blendShapesCount</td><td><code>int</code></td><td>Total amount of blend shapes.</td></tr>
<tr><td>fyrox_lightPosition</td><td><code>vec3</code></td><td>Light position on world coordinates.</td></tr>
<tr><td>fyrox_lightCount</td><td><code>int</code></td><td>Total light count participating in the rendering. Available in forward render pass only.</td></tr>
<tr><td>fyrox_lightsColorRadius</td><td><code>vec4[16]</code></td><td><code>xyz</code> - RGB color of the light, <code>a</code> - effective radius of the light. Available in forward render pass only.</td></tr>
<tr><td>fyrox_lightsPosition</td><td><code>vec3[16]</code></td><td>Array of world-space positions of the lights participating in the rendering. Available in forward render pass only.</td></tr>
<tr><td>fyrox_lightsDirection</td><td><code>vec3[16]</code></td><td>Array of directions (world-space) of the lights participating in the rendering. Available in forward render pass only.</td></tr>
<tr><td>fyrox_lightsParameters</td><td><code>vec2[16]</code></td><td>Array of parameters of lights participating in the rendering, where <code>x</code> - hotspot angle, <code>y</code> - full cone angle delta. Available in forward render pass only.</td></tr>
<tr><td>fyrox_ambientLight</td><td><code>vec4</code></td><td>Ambient lighting.</td></tr>
</tbody></table>
</div>
<p>To use any of the properties, just define a uniform with an appropriate name:</p>
<pre><code class="language-glsl">uniform mat4 fyrox_worldMatrix;
uniform vec3 fyrox_cameraPosition;
</code></pre>
<p>This list will be extended in future releases.</p>
<h2 id="predefined-render-passes"><a class="header" href="#predefined-render-passes">Predefined render passes</a></h2>
<p>Predefined render passes helps you to create your own shader without a need to create your own render pass
and to quickly start writing your shaders.</p>
<ul>
<li><strong>GBuffer</strong> - A pass that fills a set with render target sized textures with various data about each rendered
object. These textures then are used for physically-based lighting. Use this pass when you want the standard
lighting to work with your objects.</li>
<li><strong>Forward</strong> - A pass that draws an object directly in render target. This pass is very limiting, it does not
support lighting, shadows, etc. It should be only used to render translucent objects.</li>
<li><strong>SpotShadow</strong> - A pass that emits depth values for an object, later this depth map will be used to render shadows.</li>
<li><strong>PointShadow</strong> - A pass that emits distance from a fragment to a point light, later this depth map will be used
to render shadows.</li>
<li><strong>DirectionalShadow</strong> - A pass that emits depth values for an object, later this depth map will be used to render
shadows for directional light sources using cascaded shadow mapping.</li>
</ul>
<h2 id="drawing-parameters"><a class="header" href="#drawing-parameters">Drawing parameters</a></h2>
<p>Drawing parameters defines which GPU functions to use and at which state. For example, to render transparent
objects you need to enable blending with specific blending rules. Or you need to disable culling to draw objects
from both sides. This is when draw parameters come in handy.</p>
<p>There are relatively large list of drawing parameters, and it could confuse a person who didn't get
used to work with graphics. The following list should help you to use drawing parameters correctly.</p>
<ul>
<li><code>cull_face</code>:
<ul>
<li>Defines which side of polygon should be culled.</li>
<li><strong>Possible values:</strong> <code>None</code>, <code>Some(CullFace::Back)</code>, <code>Some(CullFace::Front)</code></li>
</ul>
</li>
<li><code>color_write</code>:
<ul>
<li>Defines which components of color should be written to a render target</li>
<li><strong>Possible values:</strong> <code>ColorMask { .. }</code></li>
</ul>
</li>
<li><code>depth_write</code>:
<ul>
<li>Whether to modify depth buffer or not.</li>
<li><strong>Possible values:</strong> <code>true/false</code></li>
</ul>
</li>
<li><code>stencil_test</code>:
<ul>
<li>Whether to use stencil test or not.</li>
<li><strong>Possible values:</strong>
<ul>
<li><code>None</code></li>
<li><code>Some(StencilFunc { .. })</code></li>
</ul>
</li>
</ul>
</li>
<li><code>depth_test</code>:
<ul>
<li>Whether to perform depth test when drawing.</li>
<li><strong>Possible values:</strong> <code>true/false</code></li>
</ul>
</li>
<li><code>blend</code>:
<ul>
<li>Blending options.</li>
<li><strong>Possible values:</strong>
<ul>
<li><code>None</code></li>
<li><code>Some(BlendFunc { .. } )</code></li>
</ul>
</li>
</ul>
</li>
<li><code>stencil_op</code>:
<ul>
<li>Stencil options.</li>
<li><strong>Possible values:</strong> <code>StencilOp { .. } </code></li>
</ul>
</li>
</ul>
<h2 id="vertex-shader"><a class="header" href="#vertex-shader">Vertex shader</a></h2>
<p>Vertex shader operates on single vertices, it must provide at least the position of the vertex
in clipping space. In other words it has to do at least this:</p>
<pre><code class="language-glsl">layout(location = 0) in vec3 vertexPosition;

uniform mat4 fyrox_worldViewProjection; // Note the built-in variable.

void main()
{
    gl_Position = fyrox_worldViewProjection * vertexPosition;
}
</code></pre>
<p>This is the simplest vertex shader, using vertex shaders you can create various graphical effects that affects
vertices.</p>
<h2 id="pixel-shader"><a class="header" href="#pixel-shader">Pixel Shader</a></h2>
<p>Pixel shader (or more precisely - fragment shader), operates on a small fragment of your render target. In general
pixels shaders just writes some color to a render target (or multiple targets) using some program.</p>
<pre><code class="language-glsl">out vec4 FragColor;

void main()
{
    FragColor = vec4(1, 0, 0, 1);
}
</code></pre>
<p>This is the simplest pixel shader, it just fills the render target with red color.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../rendering/rendering.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../rendering/materials.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../rendering/rendering.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../rendering/materials.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="../ace.js"></script>
        <script src="../editor.js"></script>
        <script src="../mode-rust.js"></script>
        <script src="../theme-dawn.js"></script>
        <script src="../theme-tomorrow_night.js"></script>

        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
